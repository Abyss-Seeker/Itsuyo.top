[{"title":"Anime Browser bug修复 + UI升级~","url":"/2025/06/03/Anime-Browser-bug%E4%BF%AE%E5%A4%8D-UI%E5%8D%87%E7%BA%A7/","content":"更新了Anime Browser的UI（全是AI的功劳，感谢deepseek大鲸鱼）\n修复了之前百分百报错（）的问题（也是大鲸鱼）\n有一说一我害怕前端真的要失业了，这个UI真的编的。。。太牛了；加上我之前也用过python的gradio，结合AI指导，很快就能手搓一个很专业的UI，太恐怖了。。。\n\n基本上就是，你有一点基础，能找到一开始版本的bug然后让它一点点改，很快就能整出一个像模像样的UI\n太恐怖了，真的\n期待。\n","categories":["重要告示"],"tags":["更新","工具"]},{"title":"CyberPongK游戏已上线","url":"/2025/06/22/CyberPongK%E6%B8%B8%E6%88%8F%E5%B7%B2%E4%B8%8A%E7%BA%BF/","content":"半夜 累了，正好今天cursor额度没用完，就先生成了一个。。之后再写篇感想blog嘿嘿\nCursor牛逼。\n\n    \n        🎯 点我跳转到游戏 🎯\n    \n    🎮 CYBERPONGK 🎮\n    直面强敌，守住底线，转战回击\n\n\n    🚀 游戏特色\n    \n• ⚡ 动态难度系统 - 从&quot;万泉部诗人&quot;到&quot;空&amp;白&quot;，五个精心设计的难度等级，满足不同玩家的挑战需求。（这AI可能有点幽默细胞在）\n\n• 🤖 AI增强模式 - 激活敌方回球增强协议，体验更具挑战性的对战体验，考验你的反应速度和策略。\n\n• 🎯 特殊事件系统 - 收集随机出现的事件道具，获得挡板增长、闪电效果、不死图腾等特殊能力。\n\n• 📱 移动端优化 - 专为移动设备优化的虚拟控制按钮，支持触摸操作，随时随地享受游戏乐趣。\n\n\n\n\n    🎮 游戏模式\n    \n• 🏠 桌面版 - 使用鼠标控制挡板，体验完整的游戏功能\n\n• 📱 移动版 - 虚拟按钮控制，触摸优化，移动端专属体验\n\n\n\n\n    🎯 操作说明\n    \n• 🖱️ 桌面操作\n  - 鼠标移动控制挡板\n\n• 👆 移动操作\n  - 上下箭头按钮控制\n  - 触摸反馈优化\n  - 防误触设计（并没有，这AI在吹什么牛逼）\n  - 流畅60fps体验\n\n\n\n\n    \n        \n            🖥️ 电脑版游戏 🖥️\n        \n        \n            📱 移动版游戏 📱\n        \n    \n\n\n\n    💡 提示：为了最佳游戏体验，建议在移动设备上打开敌方回球增强模式\n\n\n\n    🤖 本文由Cursor爸爸求你不要取代我的工作智能生成，内容仅供参考\n\n","categories":["重要告示"],"tags":["更新","游戏","AI"]},{"title":"IB倒计时","url":"/2025/04/23/IB%E5%80%92%E8%AE%A1%E6%97%B6/","content":"转眼间，IB大考已纷至沓来，两年，乃至说是十二年的奋斗将在一个月内画上暂时的句号。\n这段略有不堪的，令人回味的经历就这么地沉睡在了昨天，而我们将带着梦想走向未来。\n百感交集。\n祝大家好运。\n\n  \n    查看倒计时\n  \n\n\n\n  /* 为链接添加悬停效果 */\n  a:hover {\n    text-decoration: underline;\n    text-shadow: 0 0 8px rgba(255, 215, 0, 0.6);\n    transition: all 0.3s ease;\n  }\n","categories":["重要告示"],"tags":["工具"]},{"title":"Hello World","url":"/2024/09/06/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["试验文章"]},{"title":"Uma Card Maker 重构升级！","url":"/2025/04/22/Uma-Card-Maker-%E9%87%8D%E6%9E%84%E5%8D%87%E7%BA%A7%EF%BC%81/","content":"细心的朋友们大概注意到了以前Uma Card Maker其实边框形状没那么好。。。总之就是有问题\n这一次就当练习（中间甚至丢了几次文件），重新抠了图等等，同时用AI工具之类的把一些有点糊的icon清晰度调高了\n所以现在效果更好啦！欢迎来玩~\n（顺便还改了博客架构，这个debug好烦）\n点我跳转\n","categories":["重要告示"],"tags":["更新","工具"]},{"title":"孩子们，我回来了","url":"/2025/02/14/%E5%AD%A9%E5%AD%90%E4%BB%AC%EF%BC%8C%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86/","content":"该怎么说呢。。。4个月没有动这个blog，自己也感觉有点懈怠了。正好趁换了电脑的动机，让我们把它复活吧！\n最近经历了不少事情，包括大学申请啊之类的。结果的话，，目前看来也不算差吧，差强人意了。\n最近训练了一些GPT-SoVits的角色语音包，真的挺好用的，感谢大佬！想到可以分享给别人，嗯，我就准备再把这个网站启用起来了…也算是留点有用的网络遗产~\n不知道该说什么好，虽然没有多少人能看见，但是还是很感谢大家一直以来的捧场，嘿嘿~\n哦以及情人节快乐哈哈哈哈~\n\n\n❤Love❤！\n\n","categories":["不重要告示"],"tags":["废话","碎碎念"]},{"title":"Anime_Browser工具发布！","url":"/2025/02/25/Anime-Browser%E5%B7%A5%E5%85%B7%E5%8F%91%E5%B8%83%EF%BC%81/","content":"\n\n那是一个月黑风高的夜晚。\n\n我追完了爱生活！虹咲学院同好会！的第一季。\n沉浸在可爱女孩的一声声“篱奈篱~”，“爱桑~”，“kazumin⭐~”，和夹脚中\n我想去看第二季\n”仅限港澳台地区“\n🤯\n我觉得，这不好。颤抖的手伸向*花动漫。\n入眼的是不堪入目的广告，搜索以后发现，哈，加载不出来。\n😭\n我又幻想了，幻想自己活在一个有学园偶像的世界。实际只是被IB强*致死前的幻想罢了。\n就在这时，我想到，万能的API。。。肯定有大佬实装了！（等等这用词\n激动的心，我搜到了。\n就决定是你了！！！OIAPI！！！\n但是API，很多人不知道，不会用。我仿佛想到B站上有人会说：\n”主播主播，你找到的API的确很强力，但还是太吃操作了“\n”有没有更加简单的方法？“\n有的，兄弟，有的，这样的还有九一个\n就是用我（用GPT和大佬的API）编的，包没广告的，山寨*花动漫 Anime Browser！！！！！\nhttps://itsuyo.top/anime-browser/\n\n顺便可以看一下Tools工具界面，里面还有更多其他工具哦~\n","categories":["重要告示"],"tags":["工具"]},{"title":"更新了Resources页面！","url":"/2025/02/15/%E6%9B%B4%E6%96%B0%E4%BA%86Resources%E9%A1%B5%E9%9D%A2%EF%BC%81/","content":"\n\n\n在左侧菜单栏中新加入了Resources页面！以后的模型啊啥的会都丢在里面，以及一些小资源之类的。。\n大半夜的写不动了想赶紧睡觉zzz\n会持续更新~\n","categories":["重要告示"],"tags":["更新","资源"]},{"title":"MTC漫音社：宣传第一弹！","url":"/2024/10/12/%E6%BC%AB%E9%9F%B3%E7%A4%BEMTC%E5%AE%A3%E4%BC%A0/","content":"MTC漫音社简介欢迎访问 MTC漫音社 的官方网站！作为一个有着多年历史的国际部的扛把子二次元社团！看过日漫的多少应该都羡慕里面的一些社团吧，CL的演剧部凉宫的SOS团啥的，，咱学校感觉好多人搞社团都很有目的性，要么为了彰显自己啥leadership ability要么申大学啥的，社团都变成牟hour和经验的工具了-这绝对不是我们想在漫音看到的！\n我们希望的是组建一个能让大家有归属感，像个大家庭一样的社团！，所以请大家，作为我们的家庭成员()，绝对不要拘谨！有啥事就说，有什么想分享的直接发，咱这人都挺好的（虽然偶尔开开车看着不正经hhh）。\n希望这里的高年级老登们都可以善待新人，多多交流，低年级的各位也请放心参加我们的社团活动，多和孤独的我们交流啦！非常感谢能看到这里！\n漫音里面啥圈子都有的，绝对能找到你的同好，请相信我们的多样性和浓度哈哈哈哈\n\n我们的团队主要负责人\n社长: Horus联系方式: Horus_YEE\n副社长: QiiQ联系方式: jasperSHSID\n\n\n成员展示优秀成员\nHorus: 领导我社于10&#x2F;10义卖会上获得了1784元的营业额\nJasper: 技术宅拯救世界\n\n典型恶劣成员\nRio: 踢人，不愿意女装，每天导管\n\n\n加入我们如果你对我们的社团感兴趣，请填写加入申请表。加入我们，开启你的新旅程！\n","categories":["MTC"],"tags":["社团宣传","社团活动"]},{"title":"第一篇博客喵","url":"/2024/09/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E5%96%B5/","content":"可爱的二次元世界欢迎来到我的二次元世界！这里充满了奇幻与梦想，让我们一起探索吧！\n🌸 角色介绍🧚‍♀️ 萝莉精灵 - 艾莉丝艾莉丝是一位天真可爱的精灵，她的笑容能融化一切烦恼。她喜欢 花朵 和 甜点，特别是草莓蛋糕！\n\n年龄: 150岁（看起来像15岁）\n爱好: 编织花环、飞翔\n座右铭: “用心感受世界的美好”\n\n🦄 神秘少年 - 凯尔凯尔是一位神秘的少年，擅长剑术和魔法。他冷酷而又温柔，总是能在关键时刻出现。\n\n年龄: 17岁\n爱好: 练习剑术、阅读古籍\n座右铭: “不论黑暗，终将迎来黎明”\n\n✨ 魔法世界的规则\n魔法：每个人都可以学习基本的魔法，掌握高级魔法需要时间和努力。\n冒险：勇敢的冒险者会获得无尽的财富和荣誉，但也要小心危险。\n友情：在二次元的世界里，友情比什么都重要。\n\n📚 推荐动漫\n《爱丽丝梦游仙境》 - 描述了艾莉丝的奇幻冒险。\n《剑与魔法的传说》 - 讲述凯尔的传奇故事。\n《梦幻花园》 - 一部温馨的花卉动画片。\n\n🎉 互动时间有什么问题或者想聊的内容吗？留言告诉我吧！\n&lt;details&gt;&lt;summary&gt;点击展开更多内容&lt;/summary&gt;这里可以放置更多的内容，比如隐藏的彩蛋或者小知识哦！&lt;/details&gt;","categories":["试验文章"],"tags":["废话"]},{"title":"高考加油,金榜题名!","url":"/2025/06/07/%E9%AB%98%E8%80%83%E5%8A%A0%E6%B2%B9-%E9%87%91%E6%A6%9C%E9%A2%98%E5%90%8D/","content":"用AI写了一个舟风格（存疑）的高考加油网页：\n\n  \n    高考倒计时\n  \n\n\n\n  a:hover {\n    transform: translateY(-3px);\n    box-shadow: 0 8px 20px rgba(42, 82, 152, 0.5);\n    text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);\n  }\n  a:active {\n    transform: translateY(1px);\n    box-shadow: 0 2px 10px rgba(0,0,0,0.2);\n  }\n\n\n祝大家一切顺利！\n","categories":["重要告示"],"tags":["高考加油"]},{"title":"更新了Tools页面！","url":"/2024/09/09/%E6%9B%B4%E6%96%B0%E4%BA%86Tools%E9%A1%B5%E9%9D%A2%EF%BC%81/","content":"\n\n\n在左侧菜单栏中新加入了Tools页面！我将会在里面共享一些我制作的小工具，以及我作为一个动漫迷兼编程新手收藏的有趣的或有用的站点等，但愿能对你有帮助~！\n会持续更新~\n","categories":["重要告示"],"tags":["更新","工具"]},{"title":"Novel Reader已上线-轻量级，方便的txt小说文件阅读体验！","url":"/2025/07/15/Novel-Reader%E5%B7%B2%E4%B8%8A%E7%BA%BF-%E8%BD%BB%E9%87%8F%E7%BA%A7%EF%BC%8C%E6%96%B9%E4%BE%BF%E7%9A%84txt%E5%B0%8F%E8%AF%B4%E6%96%87%E4%BB%B6%E9%98%85%E8%AF%BB%E4%BD%93%E9%AA%8C%EF%BC%81/","content":"想做这个很久了，主要下载下来的txt都真的！很！难！读！\n所以，我向众神祈祷，回应我的只有cursor和我的暑假。\n祝大家玩得开心，希望能帮到大家！\nNovel Reader —— 轻量级、便捷的TXT小说阅读器在线体验地址 @https://itsuyo.top/novel-reader/\n主要功能\n本地TXT导入：一键导入本地txt小说文件，支持大文件极速加载。\n自动分章：支持自定义章节分割规则，自动识别章节目录。\n章节目录导航：左侧目录栏可快速跳转任意章节，支持书签高亮。\n阅读进度记忆：自动保存阅读进度和书签，刷新&#x2F;关闭页面后依然保留。\n书签功能：一键添加&#x2F;移除书签，重要章节随时标记。\n多种主题切换：支持明亮&#x2F;暗色模式，夜间阅读更护眼。\n字体大小调节：支持A+&#x2F;A-按钮，随心调整阅读字号。\n响应式设计：完美适配PC与移动端，极小屏幕下自动简化界面。\n分栏拖拽：章节目录宽度可自由拖拽调整，适应不同阅读习惯。\n设置弹窗：支持自定义章节分割、章节名提取规则（正则&#x2F;普通模式）。\n\n亮点特色\n极简界面：无广告、无多余干扰，专注纯净阅读体验。\n本地化存储：所有数据均保存在本地浏览器，无需注册登录，隐私安全。\n高性能：即使百万字大文件也能流畅操作。\n移动端友好：按钮自适应缩放，主站返回按钮在极小屏幕下仅显示icon，绝不遮挡内容。\n开源可自定义：前端代码结构清晰，便于二次开发。\n\n\n\n立即体验：https://itsuyo.top/novel-reader/\n\n","categories":["重要告示"],"tags":["工具","小说"]},{"title":"Novel Reader更新：适配移动端","url":"/2025/07/18/Novel-Reader%E6%9B%B4%E6%96%B0%EF%BC%9A%E9%80%82%E9%85%8D%E7%A7%BB%E5%8A%A8%E7%AB%AF/","content":"稍微重构了一下前端，让它能更好地应对各种极端情况。\n更重要的是：做了移动端的适配！现在移动端竖屏也能用了~\n嗯就这样。。\n","categories":["DevLog"],"tags":["更新","工具"]},{"title":"第一次的赛马娘Only，与神奇的戒断反应","url":"/2025/08/03/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9A%84%E8%B5%9B%E9%A9%AC%E5%A8%98Only%EF%BC%8C%E4%B8%8E%E7%A5%9E%E5%A5%87%E7%9A%84%E6%88%92%E6%96%AD%E5%8F%8D%E5%BA%94/","content":"其实本来是还想P一张题图的，结果刚打开PS就跳红框了。得，又得重搞，最后就不高兴了，见谅（）\n在暑假开始前我就决定把我的漫展一血（bushi）送给马娘only。中间半路杀出来个BW，有朋友帮我买了入场邀请函就去了，不过和刻板印象里的一样，感觉虽然人很多，但是没什么特别能让我驻足的东西。。那边的coser都很顶级，但一是没看到很多特别喜欢的IP（就马娘一个），其次感觉太大了反而让我没法找到组织，同时一些地方又有点商业气息，所以和朋友匆匆逛了圈就回来了。\n其实一开始听到马娘only是马娘有个UP主粉丝群里的群友推荐，给拉到群里了。当时还有点摇摆不定。后来发现那位群友家住得其实离我不远，还是同龄，正好也去BW，就一起在路上面基了。一开始还有点害怕说网上的群友都会是怎样的人（严格上算是第一次现实里面和别人面基吧），但发现是个长得高高的，还挺友好而且礼貌的人。那时候感叹说其实周边还是好人多-想想也是，只是没人担得起遇到骗子的后果，所以有点人人自危的感觉，戒备心不能没。。\n在BW回去的路上他问我有买马娘only票不，我还没，当时已经对马娘only挺期待的了，所以二话不说直接一张特典票安排上了（看看比起bw反正也不贵，120）。这下就是去成啦！期待~\n马娘only当天早上我还专门把当时日本买的大和赤骥小玩偶挂到了包上，还把以前同学送的小栗帽玩偶也带着了。挂个胡子打理一下弄了个自以为好看（爸妈觉得不好看）的偏二次元气息的发型，穿件双涡轮的T恤就出发了。\n约好了早上九点十五在地铁站和群友见面，他带了个包+行李箱 - 他之前和我说过他要出高尚骏骥cos。我当即表示兴奋，并且借此机会问他能不能一起去妆娘化妆的地方看看。他说就在场馆附近有个商场B1的麦当劳那里，我寻思这选址还挺有烟火气（），有意思，就一起去看看了。下了地铁后我们有一句没一句地聊着，聊到大学出国马娘一大堆事情，之后走到商场兜兜转转在它理论上开的时间前进到B1了（果然跟着外卖小哥就是对的）。底下简直是天堂！入眼皆为正在打扮的马娘coser。我记得有一位cos小栗帽的真挺好看，还有爱如往昔等一众，平日里从来没见到这么多马娘爱好者。下去放好行李，很自然地就和比咱小两岁的旁边的两位聊了起来，说说游戏玩玩梗。之后约好一起逛展的同学也到了，就一起唠嗑。旁边两位有一位的假发没整好，旁边就有一位热心的姐姐（我想换个好点的用词显得不那么奇怪但想不到w）说自己是临时毛娘免费帮他整了（中间梳坏了两个梳子hhh）。真的很厉害，很佩服这些热心又有一技之长的人。。。感觉能看到那么好玩又暖心的一幕一天也就值了的感觉。\n随着群友和刚交到的新朋友排队化妆，我们也是观摩了一下妆娘的鬼斧神工-真的很厉害！第一次见到化妆的魅力，两位化完妆是真的很好看而且很有女相，当然本来也很白净（）与此同时自己练了练马儿跳（虽然最后没跳上但还是玩爽了）\n之后就是和另外一位大哥一起往场馆走了，到达场馆的第一想法是“哇，是空调，我们有救了！”\n场馆不大不小（不过其实对于only展来说已经挺大了，感觉有大几百或者一千多平米来着），里面熙熙攘攘人和coser都不少。简直就是天堂！一共四十几个摊位，社团卖自制的马娘相关周边，有的真的很有活（）。coser里面kig和不戴kig的大概参半，都很好看用心~\n第一次集邮是和一位cos大和赤骥的老师，当时很紧张，作为半I人的我酝酿了好久来着，也紧张到忘了自己是说的合影还是集邮还是什么了。但那位老师真的特别，特别nice，很亲切地就贴上来摆pose拍了个照，让人感觉真的很受宠若惊也很舒服！因为这位老师是戴kig的，所以有很多手部和体态动作都把握地特别好，不用说话就能完成很优雅的交流。在这一刻也是萌生了希望将来有一天自己能cos并且给别人传输这种温暖的想法。。。嗯，到时候再看~\n之后找了很多老师合影，一路上也是锻炼了下我和陌生人面对面说话的能力。在场馆里陆陆续续大手一挥消费66元（），买到了很多有意思的周边。场馆里面还安排了小小的故事活动流程，以茶座视角探索祭典里面的怪相，也算是点题了:&gt;，文案写得很有趣，我一路选项+3 -3横跳（），最后也是领了个tama的小卡~此外，漫展中也有好多好心人发自己的无料给我们，都是很可爱的自制小周边，让我这个喜欢收藏东西的人更加享受这个氛围了。\n中间玩小游戏的时候还看到有一边是用小琴敲出马娘小调子就能拿奖品的活动，我必然是过去要装逼了（虽然也没啥技术）。和那边很nice的老哥聊聊也很开心，他还夸了我（嘿嘿嘿），虽然有点僭越但我还是问他要了个qq加了下~\n很快，一点半左右便是舞台表演开始的时候。上台的无论是发挥的如何都很有活力！里面有几位唱歌跳舞真的很厉害，好歌剧的那位更是大佬，很神也很符合角色，嗨得开！场下wota老哥们也是特别热情，一直在喊口号打节奏甩应援棒（这下知道为什么表演开始前要说禁止起飞了）。特别喜欢这种气氛，使得我当时也忘掉了一切喊着口号嗨起来了~看着各位老师的表演，我顿感很希望自己也有一项能拿得出手的技能，能给大家表演，让别人为我欢呼，也给大家带来快乐兴奋的技能。当时想着可能得工科和技术上做点研究了，后来想想感觉自己音乐天赋也还行啊，大学继续练练琴试试~~？中途点的午餐外卖到了很可惜错过一半得马儿跳，不过整体真的让我很难忘。\n看着他们合影结束完就准备走了。很可惜这次关注的UP主本人没去（不然还可以面基一下hh，虽然大概也不知道我是谁会有点尴尬吧）。和同学一起到地铁站后就一个人回去了。路上b站上一直在找马娘only的视频可惜也没找到，和群友描述了下自己有点惆怅，怅然若失的感觉后他说我就是“戒断”了；顿感这个词很妙，的确就是。。。\n到家又听到各种吵闹的声音和负面情绪，然后就有些emo了。床上开个音乐躺着听听外面又在说我，不过或许是真的玩累了，还是睡着了。翻翻网络，看到一个描述很精辟，用我自己口述说一下：“漫展就如乌托邦一样，里面人人都庆祝分享自己的兴趣爱好，没人管你现实里的破烂事，人人都能忘掉一切去释放自我，活成想要的样子”。有点感动也有点想哭，如梦似幻的一天，希望将来还会有，今晚就准备和朋友再去vrchat当人棍将就一下了（）。一定还会有！\n明年见！\n（如果您能看到这里，我真的挺佩服您的流水账赤石能力，请务必加我个好友或者啥的，很高兴认识您）\n","categories":["杂谈"],"tags":["碎碎念"]},{"title":"Resources","url":"/Resources/index.html","content":"\n如果发现有链接失效。。。我也不知道怎么能联系到我嘿嘿，要么B站私信？右边有我的B站主页按钮~\n\n欢迎来到我的资源分享页面！平时大多数资源（比如训练好的模型啊啥的）都会放在这里，和工具页面分开来放~\n右边有目录的，目录分类点击就能跳转！当然也可以直接ctrl+F搜索整页里面的关键词。\n对了，偷偷告诉你，百度网盘很多时候没SVIP下载慢的话可以去淘宝几角钱租一个SVIP共享号的，挺好用\n赛马娘 GPT_SoVITS 模型\n这部分是马娘的GPT_SoVITS模型，我训练的。不会用的小白具体教程可以看_（待更新）_（或者B站搜个视频嘛，不难的）。\n\n\n注意哦，因为我也是这方面的新手，所以很多训练出来可能差强人意。。。一些我在之后听着不好以及实力上升更加懂了以后会再改的！\n\n\n\n\n模型名\n描述\n百度网盘\nGoogle Drive\n\n\n\nDaiwa_Scarlet_V2 \n大和赤骥的GPT_SoVITS的v2模型~这是我第一个炼的模型，所以可能效果有待提升，不过感觉也还可以嘿嘿。大和。。。想和你马儿跳\n点我\n点我\n\n\nKitasan_Black_V2 \n北部玄驹的GPT_SoVITS的v2模型~ 哈利ki得一go!\n点我\n点我\n\n\nSatono_Diamond_V2 \n里见光钻的GPT_SoVITS的v2模型~ 钻哥你什么时候带我走啊啊啊\n点我\n点我\n\n\nWonder_Acute_V2 \n奇锐骏的GPT_SoVITS的v2模型~ 你的奶奶，可可爱爱（bushi\n点我\n点我\n\n\n\n蔚蓝档案 GPT_SoVITS 模型\n这部分是Blue Archive蓝色原神蔚蓝档案的GPT_SoVITS模型，我训练的。不会用的小白具体教程可以看_（待更新）_（或者B站搜个视频嘛，不难的）。\n\n\n还是那句话，因为我也是这方面的新手，所以很多训练出来可能差强人意。。。一些我在之后听着不好以及实力上升更加懂了以后会再改的！\n\n\n\n\n模型名\n描述\n百度网盘\nGoogle Drive\n\n\n\nAtsuko_V2 \n秤亚津子的GPT_SoVITS的v2模型~炼的时候还不太熟练参数，所以可能效果有待提升，不过感觉也还可以嘿嘿。笑\n点我\n点我\n\n\n以后会持续更新！\n"},{"url":"/gaokao-countdown/index.html","content":"\n\n\n  \n  \n  罗德岛高考作战指挥中心 | 博士指令已下达\n  \n  \n    /* 粒子背景修复 */\n    #particles-js {\n      position: fixed;\n      width: 100%;\n      height: 100%;\n      top: 0;\n      left: 0;\n      z-index: -1;\n    }\n\n    /* 其他样式 */\n    :root {\n      --ark-blue: #1a3a6d;\n      --ark-gold: #d4af37;\n      --ark-red: #c93c3c;\n      --ark-bg: #0d1b2a;\n      --ark-card: rgba(26, 58, 109, 0.25);\n    }\n\n    body {\n      background: radial-gradient(ellipse at bottom, #0d1b2a 0%, #000718 100%) fixed;\n      color: #e0e0e0;\n      font-family: 'Microsoft YaHei', sans-serif;\n      margin: 0;\n      padding: 0;\n      min-height: 100vh;\n      overflow-x: hidden;\n    }\n\n    /* 初始加载容器 */\n    #initial-loader {\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      z-index: 1000;\n      background: rgba(13, 27, 42, 0.95);\n      transition: opacity 1s ease, transform 1s ease;\n    }\n\n    .rhodes-logo {\n      width: 150px;\n      height: 150px;\n      margin: 0 auto 2rem;\n      background:\n        radial-gradient(circle, transparent 60%, var(--ark-gold) 65%),\n        linear-gradient(45deg, transparent 45%, var(--ark-gold) 50%, transparent 55%),\n        linear-gradient(-45deg, transparent 45%, var(--ark-gold) 50%, transparent 55%);\n      border: 3px solid var(--ark-gold);\n      border-radius: 50%;\n      position: relative;\n      animation: rotateLogo 15s linear infinite, pulse 3s ease-in-out infinite;\n    }\n\n    @keyframes rotateLogo {\n      0% { transform: rotate(0deg); }\n      100% { transform: rotate(360deg); }\n    }\n\n    @keyframes pulse {\n      0% { box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.5); }\n      70% { box-shadow: 0 0 0 20px rgba(212, 175, 55, 0); }\n      100% { box-shadow: 0 0 0 0 rgba(212, 175, 55, 0); }\n    }\n\n    .loader-content {\n      text-align: center;\n      animation: fadeInUp 1.5s ease-out;\n    }\n\n    @keyframes fadeInUp {\n      from {\n        opacity: 0;\n        transform: translateY(30px);\n      }\n      to {\n        opacity: 1;\n        transform: translateY(0);\n      }\n    }\n\n    h1 {\n      color: var(--ark-gold);\n      font-size: 3rem;\n      text-shadow: 0 0 15px rgba(212, 175, 55, 0.8);\n      letter-spacing: 3px;\n      margin: 0;\n      position: relative;\n    }\n\n    h1::after {\n      content: \"\";\n      display: block;\n      width: 300px;\n      height: 3px;\n      background: linear-gradient(90deg, transparent, var(--ark-gold), transparent);\n      margin: 15px auto;\n      animation: expandLine 2s ease-out;\n    }\n\n    @keyframes expandLine {\n      from { width: 0; opacity: 0; }\n      to { width: 300px; opacity: 1; }\n    }\n\n    .loader-subtitle {\n      font-size: 1.5rem;\n      margin-top: 1rem;\n      color: #aaa;\n      animation: fadeInDelay 2s ease-out;\n    }\n\n    @keyframes fadeInDelay {\n      0% { opacity: 0; }\n      70% { opacity: 0; }\n      100% { opacity: 1; }\n    }\n\n    /* 下滑提示动画 */\n    #scroll-hint {\n      position: absolute;\n      bottom: 40px;\n      font-size: 3rem;\n      color: var(--ark-gold);\n      animation: pulseArrow 2s infinite;\n      opacity: 0.7;\n      cursor: pointer;\n    }\n\n    @keyframes pulseArrow {\n      0%, 100% {\n        transform: translateY(0);\n        opacity: 0.4;\n      }\n      50% {\n        transform: translateY(20px);\n        opacity: 1;\n        text-shadow: 0 0 15px rgba(212, 175, 55, 0.8);\n      }\n    }\n\n    /* 主内容容器 - 初始隐藏 */\n    .main-content {\n      opacity: 0;\n      transform: translateY(30px);\n      transition: opacity 1s ease, transform 1s ease;\n    }\n\n    /* 动态舰桥头部 */\n    .header {\n      background: linear-gradient(to right, var(--ark-blue), #152a4d);\n      padding: 2rem 0;\n      text-align: center;\n      position: relative;\n      border-bottom: 3px solid var(--ark-gold);\n      box-shadow: 0 5px 15px rgba(0,0,0,0.5);\n      clip-path: polygon(0 0, 100% 0, 100% 90%, 50% 100%, 0 90%);\n    }\n\n    /* 作战指挥台 - 卡片宽度调整为100% */\n    .container {\n      max-width: 100%;\n      margin: 3rem auto;\n      padding: 0 1.5rem;\n      display: flex;\n      flex-direction: column;\n      align-items: center; /* 卡片居中 */\n    }\n\n    /* 战术面板 - 宽度调整为100% */\n    .card {\n      background: var(--ark-card);\n      border: 1px solid rgba(212, 175, 55, 0.3);\n      border-radius: 10px;\n      padding: 2rem;\n      position: relative;\n      overflow: hidden;\n      box-shadow: 0 8px 20px rgba(0,0,0,0.4);\n      transition: all 0.4s ease;\n      backdrop-filter: blur(5px);\n      opacity: 0;\n      transform: translateY(30px);\n      width: 90%; /* 宽度调整为90% */\n      max-width: 1200px; /* 最大宽度限制 */\n      margin-bottom: 2rem; /* 卡片间距 */\n    }\n\n    .card-visible {\n      opacity: 1;\n      transform: translateY(0);\n      transition: opacity 0.8s ease, transform 0.8s ease;\n    }\n\n    .card:hover {\n      transform: translateY(-8px);\n      box-shadow: 0 15px 30px rgba(212, 175, 55, 0.3);\n    }\n\n    .card::before {\n      content: \"\";\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 4px;\n      background: linear-gradient(90deg, var(--ark-blue), var(--ark-gold), var(--ark-blue));\n      animation: borderFlow 3s infinite linear;\n    }\n\n    @keyframes borderFlow {\n      0% { background-position: 0% 50%; }\n      100% { background-position: 200% 50%; }\n    }\n\n    /* 科目时间表 */\n    .schedule-table {\n      width: 100%;\n      border-collapse: collapse;\n      margin-top: 1.5rem;\n      font-size: 0.95rem;\n    }\n\n    .schedule-table th {\n      background: rgba(26, 58, 109, 0.6);\n      color: var(--ark-gold);\n      padding: 12px 8px;\n      text-align: center;\n      border: 1px solid rgba(212, 175, 55, 0.3);\n    }\n\n    .schedule-table td {\n      padding: 10px 8px;\n      text-align: center;\n      border: 1px solid rgba(212, 175, 55, 0.2);\n      position: relative;\n      transition: background 0.3s;\n    }\n\n    .schedule-table tr:hover td {\n      background: rgba(26, 58, 109, 0.4);\n    }\n\n    .schedule-table td::after {\n      content: \"\";\n      position: absolute;\n      bottom: 0;\n      left: 5%;\n      width: 90%;\n      height: 1px;\n      background: linear-gradient(90deg, transparent, var(--ark-gold), transparent);\n    }\n\n    /* 作战指令按钮 */\n    .ark-btn {\n      background: linear-gradient(135deg, var(--ark-blue), #2a5298);\n      color: white;\n      border: none;\n      padding: 14px 35px;\n      font-size: 1.2rem;\n      border-radius: 50px;\n      cursor: pointer;\n      transition: all 0.3s ease;\n      position: relative;\n      overflow: hidden;\n      box-shadow: 0 5px 15px rgba(0,0,0,0.3);\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      margin: 2rem auto 0;\n      font-weight: bold;\n      letter-spacing: 1px;\n    }\n\n    .ark-btn:hover {\n      transform: translateY(-3px) scale(1.05);\n      box-shadow: 0 8px 20px rgba(42, 82, 152, 0.5);\n    }\n\n    .ark-btn i {\n      margin-right: 10px;\n      font-size: 1.4rem;\n    }\n\n    /* 作战倒计时 */\n    .countdown-box {\n      display: flex;\n      justify-content: center;\n      gap: 15px;\n      margin-top: 1.5rem;\n    }\n\n    .countdown-unit {\n      background: rgba(26, 58, 109, 0.4);\n      border: 1px solid var(--ark-gold);\n      border-radius: 10px;\n      padding: 15px;\n      min-width: 80px;\n      text-align: center;\n      box-shadow: 0 5px 15px rgba(0,0,0,0.2);\n    }\n\n    .countdown-value {\n      font-size: 2.2rem;\n      font-weight: bold;\n      color: var(--ark-gold);\n      line-height: 1;\n    }\n\n    .countdown-label {\n      font-size: 0.9rem;\n      margin-top: 5px;\n      opacity: 0.8;\n    }\n\n    /* 页脚 */\n    .footer {\n      text-align: center;\n      padding: 2.5rem 2rem;\n      background: rgba(13, 27, 42, 0.7);\n      border-top: 1px solid var(--ark-blue);\n      margin-top: 3rem;\n      font-size: 0.9rem;\n      clip-path: polygon(50% 20%, 100% 0, 100% 100%, 0 100%, 0 0);\n    }\n\n    /* 粒子渐入动画 */\n    @keyframes particleFadeIn {\n      0% { opacity: 0; transform: scale(0.8); }\n      100% { opacity: 1; transform: scale(1); }\n    }\n\n    /* 响应式设计 */\n    @media (max-width: 768px) {\n      .container {\n        grid-template-columns: 1fr;\n      }\n\n      h1 { font-size: 2.2rem; }\n\n      .countdown-box {\n        flex-wrap: wrap;\n      }\n\n      .countdown-unit {\n        min-width: 70px;\n        padding: 10px;\n      }\n\n      .countdown-value {\n        font-size: 1.8rem;\n      }\n\n      .rhodes-logo {\n        width: 120px;\n        height: 120px;\n      }\n\n      #scroll-hint {\n        font-size: 2.5rem;\n        bottom: 30px;\n      }\n\n      .card {\n        width: 95%; /* 移动端宽度更大 */\n        padding: 1.5rem;\n      }\n    }\n  \n\n\n  \n  \n    \n    \n      罗德岛高考作战指挥中心\n      博士指令 • 精英干员待命 • 全舰备战\n    \n    ⌄\n  \n\n  \n  \n\n  \n  \n    \n    \n      \n      罗德岛高考作战指挥中心\n      博士指令 • 精英干员待命 • 全舰备战\n    \n\n    \n      \n      \n         终局作战倒计时\n        距离首场作战仅剩：\n        \n          \n            00\n            天\n          \n          \n            00\n            时\n          \n          \n            00\n            分\n          \n          \n            00\n            秒\n          \n        \n        \n           作战日期：2026年6月7日 - 9日\n           战场坐标：各考点作战区\n        \n      \n\n      \n      \n         作战时间表\n        \n          \n            \n              日期\n              上午\n              下午\n            \n          \n          \n            \n              6月7日\n              语文(9:00-11:30)\n              数学(15:00-17:00)\n            \n            \n              6月8日\n              物理/历史(9:00-10:15)\n              外语(15:00-17:00)\n            \n            \n              6月9日\n              化学 (8:30-9:45)地理 (11:00-12:15)\n              思想政治 (14:30-15:45)生物学 (17:00-18:15)\n            \n          \n        \n        \n           具体时间以当地作战指挥部通知为准\n        \n      \n\n      \n      \n         罗德岛战术支援\n        \n          \n            \n            \n              源石防护指南\n              携带作战证件 • 禁用通讯设备 • 提前部署考场路线\n            \n          \n\n          \n            \n            \n              生命维持建议\n              充足休眠 • 均衡补给 • 保持最佳作战状态\n            \n          \n\n          \n            \n            \n              战术思维训练\n              审题如分析敌人属性 • 答题如部署干员站位\n            \n          \n        \n\n        \n           获取精英干员祝福\n        \n      \n\n      \n      \n         博士通讯频道\n        \n          \n            点击按钮接通罗德岛指挥中心\n          \n        \n        \n          \n            \n              \n              阿米娅\n            \n            \n              \n              陈\n            \n            \n              \n              银灰\n            \n          \n        \n      \n    \n\n    \n    \n      明日方舟 × 高考应援作战计划 | 愿所有考生如击败整合运动般征服考场\n      © 2025 罗德岛制药公司 | 全舰系统待命支援\n      By Abyss-Seeker × DeepSeek\n    \n  \n\n  \n  \n  \n    // 优化粒子参数（更细腻、更密集）\n    particlesJS(\"particles-js\", {\n      particles: {\n        number: { value: 150, density: { enable: true, value_area: 800 } },\n        color: { value: \"#d4af37\" },\n        shape: {\n          type: [\"circle\", \"edge\", \"triangle\"],\n          stroke: { width: 0, color: \"#000000\" },\n          polygon: { nb_sides: 5 }\n        },\n        opacity: {\n          value: 0.3,\n          random: true,\n          anim: {\n            enable: true,\n            speed: 1,\n            opacity_min: 0.1,\n            sync: false\n          }\n        },\n        size: {\n          value: 2.5,\n          random: true,\n          anim: {\n            enable: true,\n            speed: 2,\n            size_min: 0.1,\n            sync: false\n          }\n        },\n        line_linked: {\n          enable: true,\n          distance: 120,\n          color: \"#1a3a6d\",\n          opacity: 0.2,\n          width: 1\n        },\n        move: {\n          enable: true,\n          speed: 1.2,\n          direction: \"none\",\n          random: true,\n          straight: false,\n          out_mode: \"out\",\n          bounce: false\n        }\n      },\n      interactivity: {\n        detect_on: \"canvas\",\n        events: {\n          onhover: {\n            enable: true,\n            mode: \"grab\",\n            parallax: {\n              enable: true,\n              force: 30,\n              smooth: 20\n            }\n          },\n          onclick: {\n            enable: true,\n            mode: \"push\"\n          },\n          resize: true\n        }\n      },\n      retina_detect: true\n    });\n\n    // 增强粒子与鼠标的交互效果\n    const canvasEl = document.querySelector(\"#particles-js canvas\");\n    if(canvasEl) {\n      canvasEl.addEventListener('mousemove', (e) => {\n        // 更新粒子系统\n        particlesJS(\"particles-js\", {\n          interactivity: {\n            events: {\n              onhover: {\n                enable: true,\n                mode: \"repulse\",\n                parallax: {\n                  enable: true,\n                  force: 60,\n                  smooth: 30\n                }\n              }\n            }\n          }\n        });\n      });\n    }\n\n    // 高考祝福语库（明日方舟角色风格）\n    const messages = [\n      \"阿米娅：博士，您的战术头脑连凯尔希医生都赞叹不已，这场作战定能完美攻略！\",\n      \"银灰：战场如商场，沉着冷静方能掌控全局。相信你的判断，博士！\",\n      \"能天使：砰砰！答案就像我的铳弹一样精准射出！保持这个节奏！\",\n      \"陈：每道题目都是一个新的作战任务，展示你精英干员的实力！\",\n      \"星熊：盾已就绪！挡住所有干扰，专注眼前的战场！\",\n      \"艾雅法拉：知识如同源石技艺，积累终将爆发！最后一战，必胜！\",\n      \"推进之王：维多利亚的骑士永不退缩！考场即战场，勇往直前！\",\n      \"塞雷娅：严谨如实验室操作，细致检查每个作战步骤！\",\n      \"闪灵：医疗组待命！保持最佳状态，你的健康是首要任务！\",\n      \"德克萨斯：冷静如我手中的剑，精准解决每个目标！\",\n      \"凯尔希：你的努力终将开花结果，罗德岛以你为荣！\",\n      \"伊芙利特：燃烧吧！用热情点燃知识的火焰！\",\n      \"刻俄柏：专注如我狩猎时的目光，必能捕捉每一分！\",\n      \"安洁莉娜：轻盈面对，你的实力会如重力般压倒一切困难！\"\n    ];\n\n    // 高考日期（2026年6月7日9:00）\n    const examDate = new Date(2026, 5, 7, 9, 0, 0);\n\n    // 更新倒计时\n    function updateCountdown() {\n      const now = new Date();\n      const diff = examDate - now;\n\n      if (diff  50) {\n        const loader = document.getElementById('initial-loader');\n        loader.style.opacity = '0';\n        loader.style.pointerEvents = 'none';\n\n        // 显示主内容\n        document.querySelector('.main-content').style.opacity = '1';\n        document.querySelector('.main-content').style.transform = 'translateY(0)';\n\n        // 添加卡片动画\n        setTimeout(() => {\n          document.querySelectorAll('.card').forEach((card, index) => {\n            setTimeout(() => {\n              card.classList.add('card-visible');\n            }, index * 200);\n          });\n        }, 300);\n\n        // 移除滚动监听器\n        window.removeEventListener('scroll', handleScroll);\n      }\n    }\n\n    // 创建粒子渐入效果\n    function createParticleEffect() {\n      const particlesContainer = document.getElementById('particles-js');\n\n      // 添加粒子渐入动画\n      particlesContainer.style.animation = 'particleFadeIn 0.8s ease-out forwards';\n\n      // 动画结束后移除样式\n      setTimeout(() => {\n        particlesContainer.style.animation = '';\n      }, 800);\n    }\n\n    // 初始化\n    document.addEventListener('DOMContentLoaded', () => {\n      // 倒计时初始化\n      updateCountdown();\n      setInterval(updateCountdown, 1000);\n\n      // 添加滚动监听器\n      window.addEventListener('scroll', handleScroll);\n\n      // 点击下滑提示滚动页面\n      document.getElementById('scroll-hint').addEventListener('click', () => {\n        window.scrollTo({\n          top: window.innerHeight,\n          behavior: 'smooth'\n        });\n      });\n\n      // 按钮事件\n      const sloganElement = document.getElementById('slogan');\n      const generateBtn = document.getElementById('generateBtn');\n\n      // 防重复点击机制\n      let clickAllowed = true;\n\n      generateBtn.addEventListener('click', () => {\n        if (!clickAllowed) return;\n        clickAllowed = false;\n\n        sloganElement.style.animation = 'none';\n\n        // 随机选择一条祝福语\n        const randomIndex = Math.floor(Math.random() * messages.length);\n        const randomMessage = messages[randomIndex];\n\n        // 重置动画并更新内容\n        setTimeout(() => {\n          sloganElement.style.animation = 'fadeIn 1s ease';\n          sloganElement.textContent = randomMessage;\n        }, 10);\n\n        // 创建粒子渐入效果\n        createParticleEffect();\n\n        // 1.5秒后解锁按钮\n        setTimeout(() => {\n          clickAllowed = true;\n        }, 1500);\n      });\n\n      // 5秒后如果用户没有滚动，自动显示主内容\n      setTimeout(() => {\n        if (window.scrollY === 0) {\n          handleScroll();\n        }\n      }, 5000);\n    });\n  \n\n"},{"url":"/novel-reader/index.html","content":"\n\n\n    \n    \n    Novel Reader\n    \n\n\n    \n        返回主站\n    \n    \n        Novel Reader\n        导入TXT\n        \n        设置\n        目录\n    \n    \n        \n            \n                \n            \n            \n            \n            \n                正在加载，请稍候...\n                \n                \n                \n                    上一章\n                    下一章\n                    书签\n                    切换颜色\n                    A-\n                    A+\n                \n            \n        \n    \n    \n        章节分割（默认: 空行）\n            \n            正则\n        \n        章节名提取（默认: 第一行）\n            \n            正则\n        \n        保存\n        关闭\n    \n    \n\n "},{"url":"/about/index.html","content":"\n\n\n    \n    \n    About Me - 罗德岛干员档案\n    \n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        body {\n            font-family: 'JetBrains Mono', 'Microsoft YaHei', sans-serif;\n            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);\n            color: #e8e8e8;\n            overflow-x: hidden;\n            min-height: 100vh;\n        }\n\n        /* 粒子背景 */\n        #particles-js {\n            position: fixed;\n            width: 100%;\n            height: 100%;\n            top: 0;\n            left: 0;\n            z-index: 1;\n        }\n\n        .container {\n            position: relative;\n            z-index: 2;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n        }\n\n        /* 头部区域 */\n        .header {\n            text-align: center;\n            margin-bottom: 50px;\n            animation: fadeInDown 1s ease-out;\n        }\n\n        .header h1 {\n            font-size: 3rem;\n            color: #ffd700;\n            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);\n            margin-bottom: 10px;\n            font-weight: bold;\n        }\n\n        .header .subtitle {\n            font-size: 1.2rem;\n            color: #87ceeb;\n            opacity: 0.8;\n        }\n\n        /* 主要内容区域 */\n        .main-content {\n            display: grid;\n            grid-template-columns: 1fr 1fr;\n            gap: 30px;\n            margin-bottom: 50px;\n        }\n\n        /* 个人卡片 */\n        .profile-card, .skills-card {\n            background: rgba(255, 255, 255, 0.1);\n            backdrop-filter: blur(10px);\n            border-radius: 20px;\n            padding: 30px;\n            border: 1px solid rgba(255, 255, 255, 0.2);\n            transition: transform 0.3s ease, box-shadow 0.3s ease;\n        }\n\n        .profile-card {\n            animation: slideInLeft 1s ease-out;\n        }\n\n        .skills-card {\n            animation: slideInRight 1s ease-out;\n        }\n\n        .profile-card:hover, .skills-card:hover {\n            transform: translateY(-5px);\n            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);\n        }\n\n        .profile-avatar {\n            width: 120px;\n            height: 120px;\n            border-radius: 50%;\n            margin: 0 auto 20px;\n            display: block;\n            border: 3px solid #ffd700;\n            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);\n            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);\n            position: relative;\n            overflow: hidden;\n        }\n\n        .profile-avatar::before {\n            content: '';\n            position: absolute;\n            top: -50%;\n            left: -50%;\n            width: 200%;\n            height: 200%;\n            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);\n            animation: shine 3s infinite;\n        }\n\n        .profile-info h2, .skills-card h2 {\n            color: #ffd700;\n            margin-bottom: 15px;\n            text-align: center;\n        }\n\n        .profile-info p {\n            line-height: 1.6;\n            margin-bottom: 10px;\n            color: #e8e8e8;\n        }\n\n        /* 技能条 */\n        .skill-item {\n            margin-bottom: 20px;\n        }\n\n        .skill-name {\n            display: flex;\n            justify-content: space-between;\n            margin-bottom: 8px;\n            color: #87ceeb;\n        }\n\n        .skill-bar {\n            height: 8px;\n            background: rgba(255, 255, 255, 0.1);\n            border-radius: 4px;\n            overflow: hidden;\n            position: relative;\n        }\n\n        .skill-progress {\n            height: 100%;\n            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);\n            border-radius: 4px;\n            transition: width 2s ease;\n            position: relative;\n            width: 0;\n        }\n\n        .skill-progress::after {\n            content: '';\n            position: absolute;\n            top: 0;\n            left: 0;\n            right: 0;\n            bottom: 0;\n            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);\n            animation: shimmer 2s infinite;\n        }\n\n        /* 项目展示 */\n        .projects-section, .contact-section {\n            grid-column: 1 / -1;\n            background: rgba(255, 255, 255, 0.1);\n            backdrop-filter: blur(10px);\n            border-radius: 20px;\n            padding: 30px;\n            border: 1px solid rgba(255, 255, 255, 0.2);\n            animation: fadeInUp 1s ease-out;\n        }\n\n        .projects-section h2, .contact-section h2 {\n            color: #ffd700;\n            margin-bottom: 25px;\n            text-align: center;\n        }\n\n        .projects-grid {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n            gap: 20px;\n        }\n\n        .project-card {\n            background: rgba(255, 255, 255, 0.05);\n            border-radius: 15px;\n            padding: 20px;\n            border: 1px solid rgba(255, 255, 255, 0.1);\n            transition: all 0.3s ease;\n            cursor: pointer;\n        }\n\n        .project-card:hover {\n            transform: translateY(-5px);\n            background: rgba(255, 255, 255, 0.1);\n            border-color: #ffd700;\n        }\n\n        .project-card h3 {\n            color: #87ceeb;\n            margin-bottom: 10px;\n        }\n\n        .project-card p {\n            color: #e8e8e8;\n            font-size: 0.9rem;\n            line-height: 1.5;\n        }\n\n        /* 联系方式 */\n        .social-links {\n            display: flex;\n            justify-content: center;\n            gap: 20px;\n            flex-wrap: wrap;\n        }\n\n        .social-link {\n            display: inline-block;\n            padding: 10px 20px;\n            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);\n            color: white;\n            text-decoration: none;\n            border-radius: 25px;\n            transition: all 0.3s ease;\n            font-weight: bold;\n        }\n\n        .social-link:hover {\n            transform: translateY(-3px);\n            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);\n        }\n\n        /* 动画效果 */\n        @keyframes fadeInDown {\n            from {\n                opacity: 0;\n                transform: translateY(-30px);\n            }\n            to {\n                opacity: 1;\n                transform: translateY(0);\n            }\n        }\n\n        @keyframes slideInLeft {\n            from {\n                opacity: 0;\n                transform: translateX(-50px);\n            }\n            to {\n                opacity: 1;\n                transform: translateX(0);\n            }\n        }\n\n        @keyframes slideInRight {\n            from {\n                opacity: 0;\n                transform: translateX(50px);\n            }\n            to {\n                opacity: 1;\n                transform: translateX(0);\n            }\n        }\n\n        @keyframes fadeInUp {\n            from {\n                opacity: 0;\n                transform: translateY(30px);\n            }\n            to {\n                opacity: 1;\n                transform: translateY(0);\n            }\n        }\n\n        @keyframes shine {\n            0% {\n                transform: translateX(-100%) translateY(-100%) rotate(45deg);\n            }\n            100% {\n                transform: translateX(100%) translateY(100%) rotate(45deg);\n            }\n        }\n\n        @keyframes shimmer {\n            0% {\n                transform: translateX(-100%);\n            }\n            100% {\n                transform: translateX(100%);\n            }\n        }\n\n        /* 响应式设计 */\n        @media (max-width: 768px) {\n            .main-content {\n                grid-template-columns: 1fr;\n            }\n            \n            .header h1 {\n                font-size: 2rem;\n            }\n            \n            .projects-grid {\n                grid-template-columns: 1fr;\n            }\n        }\n\n        /* 特殊效果 */\n        .floating {\n            animation: floating 3s ease-in-out infinite;\n        }\n\n        @keyframes floating {\n            0%, 100% {\n                transform: translateY(0px);\n            }\n            50% {\n                transform: translateY(-10px);\n            }\n        }\n\n        /* 鼠标跟随效果 */\n        .cursor-follower {\n            position: fixed;\n            width: 20px;\n            height: 20px;\n            background: radial-gradient(circle, #ffd700, transparent);\n            border-radius: 50%;\n            pointer-events: none;\n            z-index: 9999;\n            transition: transform 0.1s ease;\n        }\n    \n\n\n    \n    \n    \n    \n    \n\n    \n        \n        \n            🎮 干员档案\n            Cursor生成的 - 我还没填东西 - 牛逼\n        \n\n        \n        \n            \n            \n                \n                \n                    🎯 个人信息\n                    代号：Machan\n                    职业：技术专家 / 博客作者\n                    阵营：罗德岛\n                    专精：前端开发 / 游戏开发\n                    爱好：明日方舟 / 二次元 / 编程\n                    状态：在线中 ⚡\n                \n            \n\n            \n            \n                ⚔️ 技能面板\n                \n                    \n                        前端开发\n                        95%\n                    \n                    \n                        \n                    \n                \n                \n                    \n                        游戏开发\n                        85%\n                    \n                    \n                        \n                    \n                \n                \n                    \n                        UI/UX设计\n                        80%\n                    \n                    \n                        \n                    \n                \n                \n                    \n                        项目管理\n                        75%\n                    \n                    \n                        \n                    \n                \n                \n                    \n                        团队协作\n                        90%\n                    \n                    \n                        \n                    \n                \n            \n\n            \n            \n                🚀 项目展示\n                \n                    \n                        🎮 Anime Browser\n                        一个功能强大的动漫浏览工具，支持多种搜索方式和便捷的观看体验。\n                    \n                    \n                        🏇 Uma Card Maker\n                        赛马娘卡片制作工具，支持自定义卡片样式和内容。\n                    \n                    \n                        🏓 CyberPongK\n                        赛博朋克风格的乒乓球游戏，具有独特的视觉效果和游戏体验。\n                    \n                    \n                        📚 个人博客\n                        基于Hexo框架搭建的个人博客，使用明日方舟主题。\n                    \n                \n            \n\n            \n            \n                📞 联系方式\n                \n                    \n                        🐙 GitHub\n                    \n                    \n                        📧 Email\n                    \n                    \n                        🐦 Twitter\n                    \n                    \n                        📺 Bilibili\n                    \n                \n            \n        \n    \n\n    \n    \n    \n    \n        // 粒子效果配置\n        particlesJS('particles-js', {\n            particles: {\n                number: {\n                    value: 80,\n                    density: {\n                        enable: true,\n                        value_area: 800\n                    }\n                },\n                color: {\n                    value: '#ffd700'\n                },\n                shape: {\n                    type: 'circle'\n                },\n                opacity: {\n                    value: 0.5,\n                    random: false\n                },\n                size: {\n                    value: 3,\n                    random: true\n                },\n                line_linked: {\n                    enable: true,\n                    distance: 150,\n                    color: '#ffd700',\n                    opacity: 0.4,\n                    width: 1\n                },\n                move: {\n                    enable: true,\n                    speed: 2,\n                    direction: 'none',\n                    random: false,\n                    straight: false,\n                    out_mode: 'out',\n                    bounce: false\n                }\n            },\n            interactivity: {\n                detect_on: 'canvas',\n                events: {\n                    onhover: {\n                        enable: true,\n                        mode: 'repulse'\n                    },\n                    onclick: {\n                        enable: true,\n                        mode: 'push'\n                    },\n                    resize: true\n                }\n            },\n            retina_detect: true\n        });\n\n        // 技能条动画\n        function animateSkillBars() {\n            const skillBars = document.querySelectorAll('.skill-progress');\n            skillBars.forEach(bar => {\n                const width = bar.getAttribute('data-width');\n                setTimeout(() => {\n                    bar.style.width = width + '%';\n                }, 500);\n            });\n        }\n\n        // 鼠标跟随效果\n        const cursor = document.querySelector('.cursor-follower');\n        document.addEventListener('mousemove', (e) => {\n            cursor.style.left = e.clientX - 10 + 'px';\n            cursor.style.top = e.clientY - 10 + 'px';\n        });\n\n        // 页面加载完成后执行动画\n        document.addEventListener('DOMContentLoaded', () => {\n            animateSkillBars();\n            \n            // 添加滚动动画\n            const observerOptions = {\n                threshold: 0.1,\n                rootMargin: '0px 0px -50px 0px'\n            };\n\n            const observer = new IntersectionObserver((entries) => {\n                entries.forEach(entry => {\n                    if (entry.isIntersecting) {\n                        entry.target.style.opacity = '1';\n                        entry.target.style.transform = 'translateY(0)';\n                    }\n                });\n            }, observerOptions);\n\n            document.querySelectorAll('.profile-card, .skills-card, .projects-section, .contact-section').forEach(el => {\n                observer.observe(el);\n            });\n        });\n\n        // 项目卡片点击效果\n        document.querySelectorAll('.project-card').forEach(card => {\n            card.addEventListener('click', () => {\n                card.style.transform = 'scale(0.95)';\n                setTimeout(() => {\n                    card.style.transform = 'translateY(-5px)';\n                }, 150);\n            });\n        });\n\n        // 添加键盘音效\n        document.addEventListener('keydown', (e) => {\n            const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT');\n            audio.volume = 0.1;\n            audio.play().catch(() => {});\n        });\n    \n\n \n "},{"url":"/novel-reader/style.css","content":"body {\n    margin: 0;\n    font-family: 'Segoe UI', 'Microsoft YaHei', Arial, sans-serif;\n    background: #f7f7f7;\n    color: #222;\n}\nheader {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 1rem 2vw;\n    background: #fff;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.04);\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\nheader h1 {\n    font-size: 1.5rem;\n    margin: 0;\n}\nheader button {\n    margin-left: 1rem;\n    padding: 0.5em 1.2em;\n    border: none;\n    background: #4e8cff;\n    color: #fff;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 1rem;\n    transition: background 0.2s;\n}\nheader button:hover {\n    background: #2563c9;\n}\nmain {\n    display: flex;\n    min-height: 80vh;\n    max-width: 1200px;\n    margin: 2rem auto 0 auto;\n    gap: 2vw;\n}\n.home-link {\n    position: fixed;\n    left: 16px;\n    bottom: 16px;\n    top: auto;\n    right: auto;\n    display: flex;\n    align-items: center;\n    text-decoration: none;\n    color: white;\n    font-size: 15px;\n    z-index: 1000;\n    transition: all 0.3s ease;\n    background: rgba(138, 43, 226, 0.8);\n    padding: 7px 13px;\n    border-radius: 30px;\n    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);\n    font-weight: 500;\n    max-width: 90vw;\n    min-width: 0;\n    pointer-events: auto;\n    white-space: nowrap;\n}\n\n.home-link img {\n    width: 22px;\n    height: 22px;\n    margin-right: 7px;\n}\n\n.home-link:hover {\n    background: rgba(106, 28, 185, 0.9);\n    transform: translateY(-2px) scale(0.98);\n    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);\n}\n\n/* 调整容器位置，避免按钮遮挡 */\n.container {\n    padding-top: 70px; /* 新增顶部间距 */\n}\n\n#chapter-menu {\n    min-width: 200px;\n    max-width: 260px;\n    background: #fff;\n    border-radius: 8px;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.08);\n    padding: 1.2rem 0.7rem;\n    display: flex;\n    flex-direction: column;\n    flex-wrap: nowrap;\n    gap: 0.2rem;\n    align-content: flex-start;\n    height: 100vh;\n    max-height: 100vh;\n    overflow-y: auto;\n    border: 1px solid #e3eaf2;\n    position: sticky;\n    top: 0;\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));\n    gap: 0.2rem;\n}\n#chapter-menu button {\n    display: block;\n    width: 100%;\n    min-height: 2.2em;\n    margin: 0.1em 0;\n    box-sizing: border-box;\n    text-align: left;\n    font-size: 1em;\n    transition: font-size 0.2s, background 0.2s, color 0.2s, border 0.2s;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    background: linear-gradient(90deg, #eaf1ff 60%, #f7faff 100%);\n    color: #2563c9;\n    border: 1px solid #c3d6f7;\n    border-radius: 6px;\n    font-weight: 500;\n    box-shadow: 0 1px 2px rgba(0,0,0,0.03);\n    cursor: pointer;\n    padding: 0.6em 0.8em;\n}\n#chapter-menu button[data-len='short'] { font-size: 1.08em; }\n#chapter-menu button[data-len='medium'] { font-size: 0.98em; }\n#chapter-menu button[data-len='long'] { font-size: 0.88em; }\n#chapter-menu button[data-len='xlong'] { font-size: 0.78em; }\n#chapter-menu button.active, #chapter-menu button:hover {\n    background: linear-gradient(90deg, #4e8cff 60%, #2563c9 100%);\n    color: #fff;\n    border: 1px solid #4e8cff;\n}\n#chapter-menu button.bookmarked {\n    background: linear-gradient(90deg, #ffe9b3 60%, #fff7e0 100%);\n    color: #b97a00;\n    border: 1px solid #ffd36b;\n    font-weight: bold;\n}\n#chapter-menu button.bookmarked.active, #chapter-menu button.bookmarked:hover {\n    background: linear-gradient(90deg, #ffb300 60%, #ff9800 100%);\n    color: #fff;\n    border: 1px solid #ffb300;\n}\n#reader-section {\n    flex: 1 1 0;\n    background: #fff;\n    border-radius: 8px;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.04);\n    padding: 2rem 1.5rem 1.5rem 1.5rem;\n    min-width: 0;\n    display: flex;\n    flex-direction: column;\n    min-height: 60vh;\n    transition: background 0.2s;\n}\n.dark-mode #reader-section,\n.dark-mode #chapter-content {\n    background: #23272e !important;\n    color: #e0e0e0;\n}\n#loading {\n    font-size: 1.2rem;\n    color: #4e8cff;\n    text-align: center;\n    margin: 2rem 0;\n}\n#chapter-title {\n    font-size: 1.6rem;\n    font-weight: bold;\n    margin-bottom: 1.5rem;\n    text-align: center;\n    color: #2563c9;\n    letter-spacing: 0.05em;\n    text-shadow: 0 2px 8px rgba(78,140,255,0.08);\n}\n#chapter-content {\n    font-size: 1.15rem;\n    line-height: 2.2;\n    margin-bottom: 2rem;\n    word-break: break-all;\n    min-height: 40vh;\n    max-height: 60vh;\n    overflow-y: auto;\n    padding: 1.2em 0.5em 1.2em 0.5em;\n    background: #f7faff;\n    border-radius: 8px;\n    box-shadow: 0 1px 4px rgba(78,140,255,0.04);\n    border: 1px solid #e3eaf2;\n    transition: background 0.2s;\n}\n#reader-controls {\n    display: flex;\n    justify-content: center;\n    gap: 1.2rem;\n    margin-bottom: 0.5rem;\n}\n#reader-controls button {\n    padding: 0.6em 1.3em;\n    border: none;\n    background: linear-gradient(90deg, #eaf1ff 60%, #f7faff 100%);\n    color: #2563c9;\n    border-radius: 6px;\n    cursor: pointer;\n    font-size: 1.05rem;\n    font-weight: 500;\n    border: 1px solid #c3d6f7;\n    box-shadow: 0 1px 2px rgba(0,0,0,0.03);\n    transition: background 0.2s, color 0.2s, border 0.2s;\n}\n#reader-controls button:hover, #reader-controls button.active {\n    background: linear-gradient(90deg, #4e8cff 60%, #2563c9 100%);\n    color: #fff;\n    border: 1px solid #4e8cff;\n}\n#settings-modal {\n    position: fixed;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n    background: #fff;\n    border-radius: 8px;\n    box-shadow: 0 4px 24px rgba(0,0,0,0.12);\n    padding: 2rem 2.5rem;\n    z-index: 100;\n    min-width: 260px;\n}\n#settings-modal label {\n    display: flex;\n    align-items: center;\n    margin-bottom: 1rem;\n    font-size: 1rem;\n    gap: 0.5em;\n}\n#settings-modal input[type=\"text\"] {\n    flex: 1 1 auto;\n    min-width: 0;\n    margin-right: 0.5em;\n}\n#settings-modal input[type=\"checkbox\"] {\n    margin-left: 0.2em;\n    margin-right: 0.2em;\n    width: 1.1em;\n    height: 1.1em;\n}\n#settings-modal input {\n    width: 100%;\n    padding: 0.5em;\n    font-size: 1rem;\n    margin-top: 0.5em;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n}\n#settings-modal button {\n    margin-right: 1rem;\n    padding: 0.5em 1.2em;\n    border: none;\n    background: #4e8cff;\n    color: #fff;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 1rem;\n    transition: background 0.2s;\n}\n#settings-modal button:last-child {\n    margin-right: 0;\n    background: #aaa;\n}\n@media (max-width: 1200px) {\n    #chapter-menu {\n        grid-template-columns: repeat(3, 1fr);\n    }\n}\n@media (max-width: 900px) {\n    main {\n        flex-direction: column;\n        gap: 1rem;\n    }\n    .home-link {\n        font-size: 13px;\n        padding: 5px 10px;\n        left: 8px;\n        bottom: 8px;\n        max-width: 95vw;\n    }\n\n    .home-link img {\n        width: 18px;\n        height: 18px;\n    }\n\n    .container {\n        padding-top: 60px; /* 移动端减少间距 */\n    }\n    #chapter-menu {\n        min-width: 0;\n        max-width: 100vw;\n        width: 100%;\n        height: 30vh;\n        max-height: 30vh;\n        position: static;\n        padding: 0.7rem 0.2rem;\n    }\n    #reader-section {\n        padding: 1.2rem 0.5rem 1rem 0.5rem;\n    }\n    #chapter-title {\n        font-size: 1.15rem;\n    }\n    #chapter-content {\n        font-size: 1.02rem;\n        max-height: 50vh;\n        padding: 0.7em 0.2em 0.7em 0.2em;\n    }\n    #reader-controls button {\n        font-size: 0.98rem;\n        padding: 0.5em 0.8em;\n    }\n}\n@media (max-width: 600px) {\n    header {\n        flex-direction: column;\n        align-items: flex-start;\n        gap: 0.5rem;\n        padding: 0.7rem 2vw;\n    }\n    main {\n        margin: 0.5rem;\n    }\n    #chapter-title {\n        font-size: 1rem;\n    }\n    #chapter-content {\n        font-size: 0.95rem;\n        max-height: 38vh;\n        padding: 0.5em 0.1em 0.5em 0.1em;\n    }\n    #chapter-menu button {\n        font-size: 0.92em;\n        min-width: 54px;\n        max-width: 80px;\n        padding: 0.4em 0.3em;\n    }\n    #settings-modal {\n        padding: 0.7rem 0.2rem;\n        min-width: 120px;\n        font-size: 0.95rem;\n    }\n    #reader-controls {\n        gap: 0.5rem;\n    }\n    #reader-controls button {\n        font-size: 0.92rem;\n        padding: 0.4em 0.7em;\n    }\n    #chapter-menu {\n        grid-template-columns: repeat(1, 1fr);\n        height: 22vh;\n        max-height: 22vh;\n        position: static;\n        padding: 0.5rem 0.1rem;\n    }\n    .home-link {\n        font-size: 11px;\n        padding: 3px 7px;\n        left: 4px;\n        bottom: 4px;\n        max-width: 98vw;\n    }\n    .home-link img {\n        width: 15px;\n        height: 15px;\n    }\n}\n@media (max-width: 400px) {\n    .home-link {\n        padding: 2px 2px;\n        font-size: 0;\n        left: 2px;\n        bottom: 2px;\n    }\n    .home-link img {\n        width: 18px;\n        height: 18px;\n        margin-right: 0;\n    }\n    .home-link span {\n        display: none;\n    }\n}\n.dark-mode {\n    background: #23272e;\n    color: #e0e0e0;\n}\n.dark-mode #reader-section,\n.dark-mode #chapter-menu,\n.dark-mode #settings-modal {\n    background: #2d323b;\n    color: #e0e0e0;\n}\n.dark-mode header {\n    background: #23272e;\n    color: #e0e0e0;\n}\n.dark-mode #chapter-menu button {\n    background: #3a4252;\n    color: #b3c7ff;\n}\n.dark-mode #chapter-menu button.active, .dark-mode #chapter-menu button:hover {\n    background: #4e8cff;\n    color: #fff;\n}\n.dark-mode #reader-controls button {\n    background: #3a4252;\n    color: #b3c7ff;\n}\n.dark-mode #reader-controls button.active, .dark-mode #reader-controls button:hover {\n    background: #4e8cff;\n    color: #fff;\n}\n/* 拖拽分栏样式 */\n#container {\n    display: flex;\n    width: 100%;\n    height: 100%;\n}\n#chapter-menu {\n    resize: horizontal;\n    overflow: auto;\n    min-width: 120px;\n    max-width: 50vw;\n}\n#dragbar {\n    width: 6px;\n    cursor: ew-resize;\n    background: #e3eaf2;\n    transition: background 0.2s;\n    z-index: 20;\n}\n#dragbar:hover {\n    background: #4e8cff;\n}\n\n/* 目录弹出遮罩层 */\n#menu-mask {\n    position: fixed;\n    left: 0; top: 0; right: 0; bottom: 0;\n    background: rgba(0,0,0,0.18);\n    z-index: 99;\n    display: none;\n}\n\n/* 目录弹窗样式 */\n.mobile-menu-active #chapter-menu {\n    display: block !important;\n    position: fixed;\n    left: 0; top: 0; bottom: 0;\n    width: 70vw; max-width: 340px; min-width: 120px;\n    z-index: 100;\n    box-shadow: 2px 0 16px rgba(0,0,0,0.12);\n    background: #fff;\n    border-radius: 0 8px 8px 0;\n    height: 100vh !important;\n    max-height: 100vh !important;\n    overflow-y: auto;\n    padding: 1.2rem 0.7rem;\n}\n.mobile-menu-active #menu-mask {\n    display: block !important;\n}\n\n/* 隐藏目录栏的class */\n.hidden-on-mobile {\n    display: block;\n}\n@media (max-width: 900px), (max-aspect-ratio: 1/1) {\n    #chapter-menu.hidden-on-mobile {\n        display: none !important;\n    }\n    #show-menu-btn {\n        display: inline-block !important;\n    }\n}\n@media (max-width: 900px), (max-aspect-ratio: 1/1) {\n    .mobile-menu-active #chapter-menu {\n        display: block !important;\n    }\n}\n\n/* 优化按钮区，极小屏幕下横向滚动且不换行 */\n#reader-controls {\n    display: flex;\n    justify-content: center;\n    gap: 1.2rem;\n    margin-bottom: 0.5rem;\n    flex-wrap: nowrap;\n    overflow-x: auto;\n    overflow-y: hidden;\n    -webkit-overflow-scrolling: touch;\n}\n#reader-controls button {\n    white-space: nowrap;\n    min-width: 70px;\n}\n@media (max-width: 600px) {\n    #reader-controls {\n        gap: 0.5rem;\n        font-size: 0.92rem;\n        padding-bottom: 2px;\n    }\n    #reader-controls button {\n        font-size: 0.92rem;\n        min-width: 54px;\n        padding: 0.4em 0.7em;\n    }\n}\n\n/* 目录栏与阅读区高度对齐（flex布局） */\n#container {\n    align-items: stretch;\n}\n#chapter-menu {\n    height: auto;\n    max-height: none;\n}\n@media (min-width: 901px) {\n    #container {\n        min-height: 60vh;\n        height: 100%;\n        max-width: 100vw;\n        overflow-x: hidden;\n    }\n    #chapter-menu {\n        height: auto;\n        max-height: none;\n        align-self: stretch;\n        max-width: 50vw;\n        min-width: 120px;\n        width: auto;\n    }\n    #reader-section {\n        display: flex;\n        flex-direction: column;\n        justify-content: flex-start;\n        min-width: 0;\n        flex: 1 1 0;\n        width: 0;\n    }\n} \n\n/* dragbar 层级调低，且只在目录可见时显示 */\n#dragbar {\n    width: 6px;\n    cursor: ew-resize;\n    background: #e3eaf2;\n    transition: background 0.2s;\n    z-index: 2; /* 明显低于header */\n    display: block;\n    height: 100%;\n}\n@media (max-width: 900px), (max-aspect-ratio: 1/1) {\n    #dragbar {\n        display: none !important;\n    }\n}\n.mobile-menu-active #dragbar {\n    display: none !important;\n}\n\n/* container高度自适应，始终fit屏幕 */\n#container {\n    display: flex;\n    width: 100vw;\n    height: calc(100vh - 64px); /* header约64px */\n    min-height: 0;\n    align-items: stretch;\n    box-sizing: border-box;\n}\n@media (max-width: 600px) {\n    #container {\n        height: calc(100vh - 48px);\n    }\n}\n\n/* 目录栏高度自适应且可滚动 */\n#chapter-menu {\n    min-width: 120px;\n    max-width: 50vw;\n    height: 100%;\n    max-height: 100%;\n    overflow-y: auto;\n    align-self: stretch;\n}\n.mobile-menu-active #chapter-menu {\n    height: 100vh !important;\n    max-height: 100vh !important;\n}\n\n/* 阅读区和按钮区自适应高度 */\n#reader-section {\n    flex: 1 1 0;\n    display: flex;\n    flex-direction: column;\n    min-width: 0;\n    min-height: 0;\n    height: 100%;\n    box-sizing: border-box;\n}\n#chapter-content {\n    flex: 1 1 auto;\n    min-height: 0;\n    max-height: none;\n    overflow-y: auto;\n}\n#reader-controls {\n    flex-shrink: 0;\n    flex-wrap: nowrap;\n    overflow-x: auto;\n    overflow-y: hidden;\n    -webkit-overflow-scrolling: touch;\n    justify-content: center;\n    gap: 1.2rem;\n    margin-bottom: 0.5rem;\n    padding-bottom: 2px;\n    min-width: 0;\n}\n#reader-controls button {\n    white-space: nowrap;\n    min-width: 70px;\n    font-size: 1.05rem;\n    transition: font-size 0.2s, transform 0.2s;\n}\n@media (max-width: 900px) {\n    #reader-controls button {\n        font-size: 0.92rem;\n        min-width: 54px;\n        padding: 0.4em 0.7em;\n    }\n    #reader-controls {\n        gap: 0.5rem;\n    }\n}\n@media (max-width: 600px) {\n    #reader-controls button {\n        font-size: 0.85rem;\n        min-width: 44px;\n        padding: 0.3em 0.5em;\n        transform: scale(0.95);\n    }\n    #reader-controls {\n        gap: 0.3rem;\n    }\n}\n@media (max-width: 400px) {\n    #reader-controls button {\n        font-size: 0.7rem;\n        min-width: 36px;\n        padding: 0.2em 0.3em;\n        transform: scale(0.85);\n    }\n} \n\n@media (max-width: 600px), (max-aspect-ratio: 1/1) {\n    header {\n        flex-direction: row;\n        align-items: center;\n        justify-content: space-between;\n        gap: 0.2rem;\n        padding: 0.4rem 1vw;\n        height: 38px;\n        min-height: 0;\n    }\n    header h1 {\n        font-size: 1.02rem;\n        margin: 0 0.2em 0 0;\n        flex: 1 1 auto;\n        min-width: 0;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n    }\n    header button, #show-menu-btn {\n        font-size: 0.82rem !important;\n        padding: 0.25em 0.7em !important;\n        min-width: 0 !important;\n        margin-left: 0.1em;\n        margin-right: 0.1em;\n        height: 28px;\n        line-height: 1.1;\n        flex: 0 1 auto;\n        border-radius: 4px;\n        box-sizing: border-box;\n    }\n    #show-menu-btn {\n        display: inline-block !important;\n    }\n    main {\n        margin: 0;\n        padding: 0;\n    }\n    #container {\n        height: calc(100vh - 38px);\n        min-height: 0;\n        width: 100vw;\n        box-sizing: border-box;\n    }\n    .mobile-menu-active #chapter-menu {\n        width: 50vw !important;\n        min-width: 120px;\n        max-width: 100vw;\n        height: 100vh !important;\n        max-height: 100vh !important;\n        left: 0;\n        top: 0;\n        border-radius: 0 8px 8px 0;\n        padding: 0.7rem 0.2rem;\n    }\n    #chapter-menu {\n        padding: 0.7rem 0.2rem;\n        min-width: 0;\n        max-width: 100vw;\n        width: 100%;\n        height: 100%;\n        max-height: 100%;\n        position: static;\n        display: grid;\n        grid-template-columns: repeat(1, 1fr);\n        gap: 0.2rem;\n        align-content: flex-start;\n        overflow-y: auto;\n    }\n    #chapter-menu button {\n        font-size: 0.92em;\n        min-width: 0;\n        max-width: 100%;\n        width: 100%;\n        box-sizing: border-box;\n        padding: 0.4em 0.3em;\n        margin: 0.1em 0;\n        border-radius: 4px;\n        text-align: left;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n    }\n    #reader-section {\n        padding: 0.7rem 0.2rem 0.5rem 0.2rem;\n        min-width: 0;\n        min-height: 0;\n        height: 100%;\n        box-sizing: border-box;\n    }\n    #chapter-title {\n        font-size: 1rem;\n    }\n    #chapter-content {\n        font-size: 0.95rem;\n        max-height: none;\n        min-height: 0;\n        padding: 0.5em 0.1em 0.5em 0.1em;\n    }\n    #reader-controls {\n        gap: 0.2rem;\n        font-size: 0.82rem;\n        padding-bottom: 2px;\n        flex-wrap: nowrap;\n        overflow-x: auto;\n        min-width: 0;\n    }\n    #reader-controls button {\n        font-size: 0.82rem;\n        min-width: 36px;\n        padding: 0.2em 0.3em;\n        transform: scale(0.85);\n    }\n} \n\n@media (min-width: 901px) {\n    #reader-controls {\n        display: flex;\n        flex-wrap: nowrap;\n        justify-content: center;\n        align-items: center;\n        gap: 0;\n        width: 100%;\n        font-size: 1.05rem;\n        padding: 0;\n        margin: 0;\n        /* 超窄时整体缩放 */\n        transition: transform 0.2s;\n    }\n    #reader-controls button {\n        flex: 1 1 0;\n        width: 16.66%;\n        min-width: 0;\n        max-width: 100%;\n        font-size: 1.05vw;\n        padding: 0.4em 0.2em;\n        margin: 0;\n        box-sizing: border-box;\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        transition: font-size 0.2s, padding 0.2s;\n    }\n    /* 超窄时整体scale缩小，防止溢出 */\n    #reader-section[style*=\"width: 300px\"] ~ #reader-controls,\n    #reader-section[style*=\"width: 250px\"] ~ #reader-controls {\n        transform: scale(0.85);\n    }\n    #reader-section[style*=\"width: 200px\"] ~ #reader-controls {\n        transform: scale(0.7);\n    }\n} "},{"url":"/ib/index.html","content":"\n\n\n    \n    \n    一点小祝福\n    \n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        \n        body {\n            margin: 0;\n            height: 100vh;\n            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);\n            overflow: hidden;\n            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;\n            color: white;\n            text-align: center;\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            position: relative;\n        }\n\n        h1 {\n            margin: 20px 0;\n            font-size: 2.5rem;\n            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);\n        }\n\n        p {\n            font-size: 1.2rem;\n            margin: 10px 0;\n            line-height: 1.6;\n        }\n\n        .shooting-star {\n            position: absolute;\n            width: 2px;\n            height: 80px;\n            background: linear-gradient(-45deg, white, rgba(255,255,255,0));\n            animation: tail 1.5s ease-out infinite;\n            filter: drop-shadow(0 0 5px white);\n        }\n\n        @keyframes tail {\n            0% {\n                transform: translateX(-300px) translateY(-300px) rotate(-45deg);\n                opacity: 1;\n            }\n            100% {\n                transform: translateX(300px) translateY(300px) rotate(-45deg);\n                opacity: 0;\n            }\n        }\n\n        .starfield {\n            position: absolute;\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n            z-index: 0;\n        }\n\n        .content {\n            position: relative;\n            z-index: 1;\n            padding: 20px;\n            max-width: 800px;\n            margin: 0 auto;\n        }\n\n        .twinkle-star {\n            position: absolute;\n            width: 3px;\n            height: 3px;\n            background: rgba(255,255,255,0.9);\n            border-radius: 50%;\n            animation: twinkle 2s infinite;\n            box-shadow: 0 0 10px rgba(255,255,255,0.5);\n        }\n\n        @keyframes twinkle {\n            0%, 100% { \n                opacity: 0.3; \n                transform: scale(1);\n            }\n            50% { \n                opacity: 1;\n                transform: scale(1.5);\n                background: hsl(var(--hue), 100%, 70%);\n            }\n        }\n\n        .countdown-container {\n            background: rgba(0,0,0,0.3);\n            padding: 25px;\n            border-radius: 12px;\n            margin: 30px auto;\n            width: 90%;\n            max-width: 500px;\n            backdrop-filter: blur(5px);\n            border: 1px solid rgba(255,255,255,0.1);\n        }\n\n        .countdown-title {\n            font-size: 1.2rem;\n            margin-bottom: 15px;\n        }\n\n        #countdown {\n            color: #FFD700;\n            font-size: 2.5rem;\n            font-weight: bold;\n            filter: drop-shadow(0 0 5px #FFD700);\n            margin: 10px 0;\n        }\n\n        .time-info {\n            margin-top: 20px;\n            font-size: 0.9rem;\n            color: rgba(255,255,255,0.8);\n        }\n\n        .time-info div {\n            margin: 5px 0;\n        }\n\n        .audio-toggle {\n            position: fixed;\n            bottom: 20px;\n            left: 50%;\n            transform: translateX(-50%);\n            z-index: 10;\n            background: rgba(0,0,0,0.7);\n            border-radius: 50%;\n            width: 40px;\n            height: 40px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            cursor: pointer;\n            transition: all 0.3s ease;\n        }\n\n        .audio-toggle:hover {\n            background: rgba(0,0,0,0.9);\n            width: 200px;\n            border-radius: 20px;\n        }\n\n        .audio-toggle:hover .audio-player {\n            opacity: 1;\n            width: 180px;\n        }\n\n        .audio-player {\n            opacity: 0;\n            width: 0;\n            transition: all 0.3s ease;\n            overflow: hidden;\n        }\n\n        audio {\n            width: 100%;\n            max-width: 180px;\n        }\n\n        .audio-icon {\n            font-size: 20px;\n            position: absolute;\n        }\n\n        .audio-toggle:hover .audio-icon {\n            opacity: 0;\n        }\n\n        .emoji {\n            font-size: 1.5em;\n            vertical-align: middle;\n        }\n    \n\n\n    \n        \n    \n\n    \n        🌟 祝大家大考顺利！\n        愿每一颗流星，带来一份好运 🍀\n        愿努力与坚持，在考场上绽放光芒 ✨\n        \n        \n            距离2025IB大考已经过去：\n            正在计算...\n            \n            \n                当前时间：加载中...\n                第一场考试（Chinese Paper 1）时间：2025年4月28日 13:30\n                剩余天数：计算中...\n            \n        \n    \n\n    \n        🎵\n        \n            \n                \n            \n        \n    \n\n    \n        // 生成星星和流星\n        function generateStars() {\n            const starfield = document.getElementById('starfield');\n\n            // 生成闪烁星星\n            for (let i = 0; i < 60; i++) {\n                const star = document.createElement('div');\n                star.className = 'twinkle-star';\n                star.style.left = Math.random() * 100 + '%';\n                star.style.top = Math.random() * 100 + '%';\n                star.style.animationDelay = Math.random() * 3 + 's';\n                const hue = Math.random() * 360;\n                star.style.setProperty('--hue', hue);\n                star.style.boxShadow = `0 0 8px hsl(${hue}, 80%, 60%)`;\n                starfield.appendChild(star);\n            }\n\n            // 生成流星\n            for (let i = 0; i < 13; i++) {\n                const meteor = document.createElement('div');\n                meteor.className = 'shooting-star';\n                meteor.style.left = Math.random() * 100 + '%';\n                meteor.style.animationDelay = Math.random() * 8 + 's';\n                meteor.style.top = Math.random() * 100 + '%';\n                starfield.appendChild(meteor);\n            }\n        }\n\n        // 更新时间和倒计时\n        function updateTime() {\n            const target = new Date('2025-04-28T13:30:00+08:00');\n            const now = new Date();\n\n            // 当前时间\n            document.getElementById('current-time').textContent =\n                `当前时间：${now.toLocaleString('zh-CN', {\n                    year: 'numeric',\n                    month: '2-digit',\n                    day: '2-digit',\n                    hour: '2-digit',\n                    minute: '2-digit',\n                    second: '2-digit',\n                    hour12: false\n                })}`;\n\n            // 倒计时秒数\n            const diffSeconds = Math.floor((target - now) / 1000);\n            document.getElementById('countdown').textContent =\n                `${Math.abs(diffSeconds)} 秒 (约 ${Math.abs(Math.round(diffSeconds/3600))} 小时)`;\n\n            // 剩余天数\n            const diffDays = Math.floor(diffSeconds / (3600 * 24));\n            document.getElementById('days-left').textContent =\n                `已过天数：${Math.abs(diffDays)} 天`;\n        }\n\n        // 初始化\n        document.addEventListener('DOMContentLoaded', function() {\n            generateStars();\n            updateTime();\n            setInterval(updateTime, 1000);\n\n            // 音频处理函数\n            function handleAudioPlay() {\n                const audio = document.querySelector('audio');\n                if(audio) {\n                    audio.volume = 0.5;\n                    audio.play().catch(e => {\n                        console.log(\"播放失败:\", e);\n                        // 显示提示让用户点击\n                        showPlayHint();\n                    });\n                }\n            }\n\n            // 显示播放提示\n            function showPlayHint() {\n                const hint = document.createElement('div');\n                hint.innerHTML = '点击任意处播放音乐';\n                hint.style.position = 'fixed';\n                hint.style.bottom = '70px';\n                hint.style.left = '50%';\n                hint.style.transform = 'translateX(-50%)';\n                hint.style.backgroundColor = 'rgba(0,0,0,0.7)';\n                hint.style.padding = '10px 20px';\n                hint.style.borderRadius = '20px';\n                hint.style.zIndex = '100';\n                hint.style.cursor = 'pointer';\n                hint.onclick = function() {\n                    document.body.removeChild(hint);\n                    handleAudioPlay();\n                };\n                document.body.appendChild(hint);\n            }\n\n            // 首次尝试播放\n            handleAudioPlay();\n\n            // 点击任意位置尝试播放\n            document.addEventListener('click', function() {\n                handleAudioPlay();\n            }, { once: true });\n        });\n    \n\n"},{"url":"/anime-browser/index.html","content":"\n\n\n    \n    \n    动漫信息查询-2.0\n    \n    \n            /* 新增返回按钮样式 */\n        .home-link {\n            position: fixed;\n            left: 20px;\n            top: 20px;\n            display: flex;\n            align-items: center;\n            text-decoration: none;\n            color: white; /* 白色文字在深色背景上更显眼 */\n            font-size: 16px;\n            z-index: 1000;\n            transition: all 0.3s ease;\n            background: rgba(138, 43, 226, 0.8); /* 使用主题紫色 */\n            padding: 8px 15px;\n            border-radius: 30px;\n            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);\n            font-weight: 500;\n        }\n\n        .home-link img {\n            width: 24px;\n            height: 24px;\n            margin-right: 8px;\n        }\n\n        .home-link:hover {\n            background: rgba(106, 28, 185, 0.9); /* 深紫色悬停效果 */\n            transform: translateY(-2px);\n            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);\n        }\n\n        /* 调整容器位置，避免按钮遮挡 */\n        .container {\n            padding-top: 70px; /* 新增顶部间距 */\n        }\n\n        /* 移动端适配 */\n        @media (max-width: 768px) {\n            .home-link {\n                left: 10px;\n                top: 10px;\n                font-size: 14px;\n                padding: 6px 12px;\n            }\n\n            .home-link img {\n                width: 20px;\n                height: 20px;\n            }\n\n            .container {\n                padding-top: 60px; /* 移动端减少间距 */\n            }\n        }\n\n        /* 确保模态框不会覆盖按钮 */\n        .modal {\n            z-index: 999; /* 低于按钮的z-index */\n        }\n\n        /* 样式保持不变 */\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        :root {\n            --primary: #8a2be2;\n            --primary-dark: #6a1cb9;\n            --secondary: #ff6b6b;\n            --dark: #1a1a2e;\n            --light: #f8f9fa;\n            --gray: #6c757d;\n            --success: #28a745;\n            --card-bg: #ffffff;\n            --card-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);\n        }\n\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #1a1a2e, #16213e);\n            color: #333;\n            line-height: 1.6;\n            min-height: 100vh;\n            padding: 20px;\n        }\n\n        .container {\n            max-width: 1200px;\n            margin: 0 auto;\n        }\n\n        header {\n            text-align: center;\n            padding: 30px 0;\n            margin-bottom: 30px;\n            color: white;\n            animation: fadeInDown 0.8s ease;\n        }\n\n        header h1 {\n            font-size: 2.8rem;\n            margin-bottom: 10px;\n            background: linear-gradient(45deg, #ff6b6b, #8a2be2);\n            -webkit-background-clip: text;\n            -webkit-text-fill-color: transparent;\n            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }\n\n        header p {\n            font-size: 1.2rem;\n            max-width: 700px;\n            margin: 0 auto;\n            color: #e0e0ff;\n        }\n\n        .search-section {\n            background: rgba(255, 255, 255, 0.95);\n            border-radius: 15px;\n            padding: 25px;\n            box-shadow: var(--card-shadow);\n            margin-bottom: 30px;\n            animation: fadeInUp 0.8s ease;\n        }\n\n        .input-area {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 15px;\n            align-items: center;\n        }\n\n        .input-group {\n            flex: 1;\n            min-width: 250px;\n        }\n\n        .input-group label {\n            display: block;\n            margin-bottom: 8px;\n            font-weight: 600;\n            color: var(--dark);\n        }\n\n        input, select, button {\n            padding: 14px 18px;\n            font-size: 16px;\n            border: 2px solid #e0e0e0;\n            border-radius: 10px;\n            width: 100%;\n            transition: all 0.3s ease;\n        }\n\n        input:focus, select:focus {\n            border-color: var(--primary);\n            outline: none;\n            box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.2);\n        }\n\n        button {\n            background: linear-gradient(135deg, var(--primary), var(--primary-dark));\n            color: white;\n            border: none;\n            cursor: pointer;\n            font-weight: 600;\n            letter-spacing: 0.5px;\n            transition: all 0.3s ease;\n            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.3);\n        }\n\n        button:hover {\n            transform: translateY(-3px);\n            box-shadow: 0 6px 20px rgba(138, 43, 226, 0.4);\n        }\n\n        button:active {\n            transform: translateY(-1px);\n        }\n\n        .results-section {\n            display: grid;\n            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));\n            gap: 25px;\n            margin-bottom: 40px;\n        }\n\n        .anime-card {\n            background: var(--card-bg);\n            border-radius: 15px;\n            overflow: hidden;\n            box-shadow: var(--card-shadow);\n            transition: transform 0.3s ease, box-shadow 0.3s ease;\n            cursor: pointer;\n            animation: fadeIn 0.5s ease;\n        }\n\n        .anime-card:hover {\n            transform: translateY(-10px);\n            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.15);\n        }\n\n        .anime-image {\n            width: 100%;\n            height: 320px;\n            object-fit: cover;\n            border-bottom: 3px solid var(--primary);\n            display: none;\n        }\n\n        .anime-placeholder {\n            width: 100%;\n            height: 320px;\n            background: linear-gradient(135deg, #f0f0f0, #e0e0e0);\n            display: none;\n            align-items: center;\n            justify-content: center;\n            color: #999;\n            font-size: 14px;\n            border-bottom: 3px solid var(--primary);\n        }\n\n        .detail-placeholder {\n            width: 100%;\n            height: 400px;\n            background: linear-gradient(135deg, #f0f0f0, #e0e0e0);\n            display: none;\n            align-items: center;\n            justify-content: center;\n            color: #999;\n            font-size: 16px;\n            border-radius: 10px;\n        }\n\n        .anime-info {\n            padding: 20px;\n        }\n\n        .anime-info h3 {\n            font-size: 1.4rem;\n            margin-bottom: 10px;\n            color: var(--dark);\n            white-space: nowrap;\n            overflow: hidden;\n            text-overflow: ellipsis;\n        }\n\n        .anime-meta {\n            display: flex;\n            justify-content: space-between;\n            margin-bottom: 15px;\n            font-size: 0.9rem;\n            color: var(--gray);\n        }\n\n        .anime-meta span {\n            background: #f0f0f0;\n            padding: 4px 10px;\n            border-radius: 20px;\n            font-weight: 500;\n        }\n\n        .anime-stats {\n            display: grid;\n            grid-template-columns: repeat(2, 1fr);\n            gap: 10px;\n            font-size: 0.95rem;\n        }\n\n        .anime-stats div {\n            display: flex;\n            align-items: center;\n            gap: 8px;\n        }\n\n        .anime-stats i {\n            color: var(--primary);\n            font-size: 1.1rem;\n        }\n\n        .loading-overlay {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 0, 0.85);\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            z-index: 1200;\n            flex-direction: column;\n            color: white;\n            display: none;\n        }\n\n        .spinner {\n            width: 70px;\n            height: 70px;\n            border: 5px solid rgba(255, 255, 255, 0.3);\n            border-radius: 50%;\n            border-top-color: var(--primary);\n            animation: spin 1s ease-in-out infinite;\n            margin-bottom: 20px;\n        }\n\n        .modal {\n            position: fixed;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            background: white;\n            width: 90%;\n            max-width: 800px;\n            max-height: 90vh;\n            border-radius: 20px;\n            overflow: hidden;\n            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);\n            z-index: 1001;\n            display: none;\n            animation: modalIn 0.4s ease;\n        }\n\n        .modal-header {\n            background: linear-gradient(135deg, var(--primary), var(--primary-dark));\n            color: white;\n            padding: 20px;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n        }\n\n        .modal-header h2 {\n            font-size: 1.8rem;\n            margin: 0;\n        }\n\n        .close-btn {\n            background: none;\n            border: none;\n            color: white;\n            font-size: 1.8rem;\n            cursor: pointer;\n            width: 40px;\n            height: 40px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            border-radius: 50%;\n            transition: background 0.3s;\n        }\n\n        .close-btn:hover {\n            background: rgba(255, 255, 255, 0.2);\n        }\n\n        .modal-content {\n            padding: 25px;\n            overflow-y: auto;\n            max-height: 65vh;\n        }\n\n        .anime-detail {\n            display: grid;\n            grid-template-columns: 1fr 2fr;\n            gap: 25px;\n            margin-bottom: 25px;\n        }\n\n        .detail-image {\n            width: 100%;\n            border-radius: 10px;\n            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);\n            display: none;\n        }\n\n        .detail-info h3 {\n            font-size: 1.5rem;\n            margin-bottom: 15px;\n            color: var(--dark);\n        }\n\n        .detail-meta {\n            display: grid;\n            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n            gap: 15px;\n            margin-bottom: 20px;\n        }\n\n        .meta-item {\n            background: #f8f9fa;\n            padding: 12px;\n            border-radius: 8px;\n            border-left: 4px solid var(--primary);\n        }\n\n        .meta-item strong {\n            display: block;\n            color: var(--gray);\n            font-size: 0.9rem;\n            margin-bottom: 5px;\n        }\n\n        .episode-list {\n            margin-top: 20px;\n        }\n\n        .episode-list h4 {\n            font-size: 1.3rem;\n            margin-bottom: 15px;\n            padding-bottom: 10px;\n            border-bottom: 2px solid #f0f0f0;\n            color: var(--dark);\n        }\n\n        .episodes {\n            display: grid;\n            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));\n            gap: 12px;\n        }\n\n        .episode {\n            background: #f0f0f0;\n            padding: 12px;\n            text-align: center;\n            border-radius: 8px;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            font-weight: 500;\n        }\n\n        .episode:hover {\n            background: var(--primary);\n            color: white;\n            transform: translateY(-3px);\n            box-shadow: 0 5px 15px rgba(138, 43, 226, 0.3);\n        }\n\n        .empty-state {\n            text-align: center;\n            padding: 50px 25px; /* 增加左右内边距 */\n            background: white;\n            border-radius: 15px;\n            box-shadow: var(--card-shadow);\n            grid-column: 1 / -1; /* 关键修改：使空状态跨越所有列 */\n        }\n\n        .empty-state i {\n            font-size: 4rem;\n            color: #e0e0e0;\n            margin-bottom: 20px;\n        }\n\n        .empty-state h3 {\n            font-size: 1.8rem;\n            margin-bottom: 15px;\n            color: var(--dark);\n        }\n\n        .empty-state p {\n            font-size: 1.1rem;\n            color: var(--gray);\n            max-width: 600px;\n            margin: 0 auto;\n            line-height: 1.8;\n        }\n\n        .notification {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            padding: 15px 25px;\n            border-radius: 10px;\n            background: var(--primary);\n            color: white;\n            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);\n            transform: translateX(150%);\n            transition: transform 0.3s ease;\n            z-index: 1002;\n            display: flex;\n            align-items: center;\n            gap: 10px;\n        }\n\n        .notification.show {\n            transform: translateX(0);\n        }\n\n        @keyframes spin {\n            to { transform: rotate(360deg); }\n        }\n\n        @keyframes fadeIn {\n            from { opacity: 0; transform: translateY(20px); }\n            to { opacity: 1; transform: translateY(0); }\n        }\n\n        @keyframes fadeInDown {\n            from { opacity: 0; transform: translateY(-30px); }\n            to { opacity: 1; transform: translateY(0); }\n        }\n\n        @keyframes fadeInUp {\n            from { opacity: 0; transform: translateY(30px); }\n            to { opacity: 1; transform: translateY(0); }\n        }\n\n        @keyframes modalIn {\n            from { opacity: 0; transform: translate(-50%, -60%); }\n            to { opacity: 1; transform: translate(-50%, -50%); }\n        }\n\n        @media (max-width: 768px) {\n            .anime-detail {\n                grid-template-columns: 1fr;\n            }\n\n            .input-area {\n                flex-direction: column;\n            }\n\n            .input-group {\n                width: 100%;\n            }\n\n            header h1 {\n                font-size: 2.2rem;\n            }\n\n            .modal {\n                width: 95%;\n            }\n        }\n    \n\n\n    \n        返回主站\n    \n    \n        \n             动漫信息查询\n            搜索您喜爱的动漫，获取详细信息、剧集列表和播放链接\n        \n\n        \n            \n                \n                     动漫名称\n                    \n                \n\n                \n                     选择线路\n                    \n                        线路 1\n                        线路 2\n                        线路 3\n                    \n                \n\n                \n                    &nbsp;\n                    \n                         查询动漫\n                    \n                \n            \n        \n\n        \n            \n                \n                动漫查询工具\n                在搜索框中输入您想查询的动漫名称，选择线路后点击查询按钮\n                搜索结果将显示在这里，点击动漫卡片可查看详情和剧集列表\n                如果报错了的话，先多试几次（推荐5次，很看API心情）~！有的时候多点几次就又可以了\n                \n                     提示：每次点击按钮和其他操作，点一次就够了！不要狂点！\n                \n            \n        \n    \n\n    \n        \n        正在加载，请稍候...\n    \n\n    \n        \n            动漫详情\n            &times;\n        \n        \n            \n        \n    \n\n    \n        \n        操作成功！\n    \n\n    \n        // 当前状态变量\n        let currentLoading = null;\n        let currentAnimeName = '';\n        let currentLineType = 1;\n        let currentNIndex = 0;\n\n        // 显示通知\n        function showNotification(message, isError = false) {\n            const notification = document.getElementById('notification');\n            const text = document.getElementById('notification-text');\n\n            text.textContent = message;\n            notification.style.background = isError ? '#ff6b6b' : '#8a2be2';\n\n            notification.classList.add('show');\n\n            setTimeout(() => {\n                notification.classList.remove('show');\n            }, 3000);\n        }\n\n        // 显示加载状态\n        function showLoading(text = '正在加载，请稍候...') {\n            const loading = document.getElementById('loading');\n            const loadingText = document.getElementById('loading-text');\n\n            loadingText.textContent = text;\n            loading.style.display = 'flex';\n            currentLoading = loading;\n        }\n\n        // 隐藏加载状态\n        function hideLoading() {\n            if (currentLoading) {\n                currentLoading.style.display = 'none';\n                currentLoading = null;\n            }\n        }\n\n        // 关闭模态框\n        function closeModal() {\n            document.getElementById('detailModal').style.display = 'none';\n        }\n\n        // 获取动漫数据 - 修复版\n        async function fetchAnimeData() {\n            const animeName = document.getElementById('animeName').value.trim();\n            if (!animeName) {\n                showNotification('请输入动漫名称', true);\n                return;\n            }\n\n            currentAnimeName = animeName;\n            currentLineType = parseInt(document.getElementById('lineType').value);\n            \n            // 调试信息：显示当前选择的线路\n            console.log('当前选择的线路类型:', currentLineType);\n            console.log('线路选择框的值:', document.getElementById('lineType').value);\n\n            showLoading('正在搜索动漫...');\n\n            try {\n                const url = 'https://oiapi.net/API/Anime';\n                const params = new URLSearchParams({\n                    msg: animeName,\n                    n: 0,\n                    j: 0,\n                    type: currentLineType.toString(),\n                    line: currentLineType.toString(),\n                    lineType: currentLineType.toString()\n                });\n\n                // 添加时间戳防止缓存\n                const fullUrl = `${url}?${params}&t=${Date.now()}`;\n                \n                // 调试信息：显示实际发送的请求参数\n                console.log('发送的请求参数:', {\n                    msg: animeName,\n                    n: 0,\n                    j: 0,\n                    type: currentLineType,\n                    line: currentLineType,\n                    lineType: currentLineType\n                });\n                console.log('完整的请求URL:', fullUrl);\n\n                // 使用CORS代理解决跨域问题\n                const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(fullUrl)}`;\n\n                const response = await fetch(proxyUrl);\n\n                // 解析代理响应\n                const proxyData = await response.json();\n\n                // 检查代理响应是否包含原始内容\n                if (!proxyData.contents) {\n                    throw new Error('代理服务返回无效数据');\n                }\n\n                // 解析原始API响应\n                const data = JSON.parse(proxyData.contents);\n\n                // 新增：打印搜索结果的完整JSON数据\n                console.log(\"[搜索动漫列表] 返回的完整JSON数据:\", data);\n\n                if (data.code === 200) {\n                    displayAnimeList(data.data);\n                    showNotification(`找到 ${data.data.length} 部相关动漫`);\n                } else {\n                    showNotification(data.msg || '查询失败，请重试', true);\n                }\n            } catch (error) {\n                console.error('请求异常:', error);\n                showNotification(`请求异常: ${error.message}`, true);\n            } finally {\n                hideLoading();\n            }\n        }\n\n        // 显示动漫列表\n        function displayAnimeList(animeList) {\n            const resultsArea = document.getElementById('resultsArea');\n            resultsArea.innerHTML = '';\n\n            if (!animeList || animeList.length === 0) {\n                resultsArea.innerHTML = `\n                    \n                        \n                        未找到相关动漫\n                        没有找到与\"${currentAnimeName}\"相关的动漫，请尝试其他关键词\n                    \n                `;\n                return;\n            }\n\n            animeList.forEach((anime, index) => {\n                const animeCard = document.createElement('div');\n                animeCard.className = 'anime-card';\n                animeCard.innerHTML = `\n                    \n                    \n                         图片加载失败\n                    \n                    \n                        ${anime.name}\n                        \n                            ${anime.year || '未知年份'}\n                            ${anime.ji || '状态未知'}\n                        \n                    \n\n\n\n\n\n\n                    \n                `;\n                animeCard.onclick = () => showAnimeDetails(index + 1);\n                resultsArea.appendChild(animeCard);\n            });\n        }\n\n        // 显示动漫详情\n        async function showAnimeDetails(nIndex) {\n            currentNIndex = nIndex;\n            // 确保线路类型是最新的\n            currentLineType = parseInt(document.getElementById('lineType').value);\n            console.log('详情页面使用的线路类型:', currentLineType);\n            showLoading('正在加载动漫详情...');\n\n            try {\n                const url = 'https://oiapi.net/API/Anime';\n                const params = new URLSearchParams({\n                    msg: currentAnimeName,\n                    n: nIndex,\n                    j: 0,\n                    type: currentLineType\n                });\n\n                // 添加时间戳防止缓存\n                const fullUrl = `${url}?${params}&t=${Date.now()}`;\n\n                // 使用CORS代理解决跨域问题\n                const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(fullUrl)}`;\n\n                const response = await fetch(proxyUrl);\n\n                // 解析代理响应\n                const proxyData = await response.json();\n\n                // 检查代理响应是否包含原始内容\n                if (!proxyData.contents) {\n                    throw new Error('代理服务返回无效数据');\n                }\n\n                // 解析原始API响应\n                const data = JSON.parse(proxyData.contents);\n\n                // 新增：打印动漫详情的完整JSON数据\n                console.log(`[动漫详情] ${currentAnimeName} 的完整JSON数据:`, data);\n\n                if (data.code === 200) {\n                    openAnimeDetailWindow(data.data, nIndex);\n                } else {\n                    showNotification(data.msg || '获取详情失败', true);\n                }\n            } catch (error) {\n                console.error('请求异常:', error);\n                showNotification(`请求异常: ${error.message}`, true);\n            } finally {\n                hideLoading();\n            }\n        }\n\n        // 打开动漫详情窗口\n        function openAnimeDetailWindow(animeData, nIndex) {\n            const modal = document.getElementById('detailModal');\n            const modalTitle = document.getElementById('modal-title');\n            const modalContent = document.getElementById('modal-content');\n\n            modalTitle.textContent = animeData.name;\n\n            modalContent.innerHTML = `\n                \n                    \n                        \n                            \n                                \n                                图片加载失败\n                            \n                        \n                    \n                    \n                        ${animeData.name}\n                        \n                            \n                                类别\n                                ${animeData.class || '未分类'}\n                            \n                            \n                                标签\n                                ${animeData.tags || '无'}\n                            \n                            \n                                状态\n                                ${animeData.ji || '未知'}\n                            \n                            \n                                年份\n                                ${animeData.year || '未知'}\n                            \n                            \n                                国家\n                                ${animeData.country || '未知'}\n                            \n                            \n                                评分\n                                ${animeData.score || '暂无'}\n                            \n                        \n                        \n                            简介\n                            ${animeData.desc || '暂无简介'}\n                        \n                    \n                \n                \n                     剧集列表\n                    \n                \n            `;\n\n            const episodeList = document.getElementById('episodeList');\n            animeData.playlist.forEach((ep, idx) => {\n                const episode = document.createElement('div');\n                episode.className = 'episode';\n                episode.textContent = ep;\n                episode.onclick = () => handleEpisodeClick(nIndex, idx + 1);\n                episodeList.appendChild(episode);\n            });\n\n            modal.style.display = 'block';\n        }\n\n        // 处理剧集点击\n        async function handleEpisodeClick(nIndex, episodeIndex) {\n            // 确保线路类型是最新的\n            currentLineType = parseInt(document.getElementById('lineType').value);\n            console.log('剧集播放使用的线路类型:', currentLineType);\n            showLoading('正在获取播放链接...');\n\n            try {\n                const url = 'https://oiapi.net/API/Anime';\n                const params = new URLSearchParams({\n                    msg: currentAnimeName,\n                    n: nIndex,\n                    j: episodeIndex,\n                    type: currentLineType\n                });\n\n                // 添加时间戳防止缓存\n                const fullUrl = `${url}?${params}&t=${Date.now()}`;\n\n                // 使用CORS代理解决跨域问题\n                const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(fullUrl)}`;\n\n                const response = await fetch(proxyUrl);\n\n                // 解析代理响应\n                const proxyData = await response.json();\n\n                // 检查代理响应是否包含原始内容\n                if (!proxyData.contents) {\n                    throw new Error('代理服务返回无效数据');\n                }\n\n                // 解析原始API响应\n                const data = JSON.parse(proxyData.contents);\n\n                // 新增：打印剧集播放链接的完整JSON数据\n                console.log(`[剧集播放链接] ${currentAnimeName} 第${episodeIndex}集的完整JSON数据:`, data);\n\n                if (data.code === 200) {\n                    showEpisodeDetails(data.data);\n                } else {\n                    showNotification(data.msg || '获取播放链接失败', true);\n                }\n            } catch (error) {\n                console.error('请求异常:', error);\n                showNotification(`请求异常: ${error.message}`, true);\n            } finally {\n                hideLoading();\n            }\n        }\n\n        // 显示剧集详情\n        function showEpisodeDetails(episodeData) {\n            const modal = document.getElementById('detailModal');\n            const modalTitle = document.getElementById('modal-title');\n            const modalContent = document.getElementById('modal-content');\n\n            modalTitle.textContent = `${episodeData.name} - ${episodeData.play_num}`;\n\n            modalContent.innerHTML = `\n                \n                    ${episodeData.name} - ${episodeData.play_num}\n                    \n                         视频类型: ${episodeData.video_type || '未知'}\n                    \n\n                    ${episodeData.play_url ? `\n                        \n                             点击播放\n                        \n                        \n                            如果播放页面没有自动打开，请检查浏览器是否阻止了弹出窗口\n                        \n                    ` : `\n                        \n                            \n                            暂无播放链接\n                            当前剧集暂时没有可用的播放链接，请尝试其他剧集或线路\n                        \n                    `}\n                \n            `;\n\n            modal.style.display = 'block';\n\n            // 如果有播放链接，自动在新标签页打开\n            if (episodeData.play_url) {\n                setTimeout(() => {\n                    window.open(episodeData.play_url, '_blank');\n                }, 500);\n            }\n        }\n\n        // 初始化：为输入框添加回车键支持\n        document.getElementById('animeName').addEventListener('keypress', (e) => {\n            if (e.key === 'Enter') {\n                fetchAnimeData();\n            }\n        });\n\n        // 初始化：为线路选择框添加变化监听\n        document.getElementById('lineType').addEventListener('change', (e) => {\n            currentLineType = parseInt(e.target.value);\n            console.log('线路选择已更改，新值:', currentLineType);\n        });\n    \n\n"},{"url":"/novel-reader/main.js","content":"// 变量定义\nlet chapters = [];\nlet currentChapter = 0;\nlet splitPattern = /\\n\\n/;\nlet bookmarksMap = {}; // 新增：以文件名为key的书签映射\nlet currentFileName = '';\nlet settings = {\n    splitPattern: '\\n\\n',\n    fontSize: 1.1,\n    darkMode: false\n};\nlet originalText = '';\n\n// DOM 元素\nconst importBtn = document.getElementById('import-btn');\nconst fileInput = document.getElementById('file-input');\nconst loadingDiv = document.getElementById('loading');\nconst chapterMenu = document.getElementById('chapter-menu');\nconst chapterTitle = document.getElementById('chapter-title');\nconst chapterContent = document.getElementById('chapter-content');\nconst prevBtn = document.getElementById('prev-chapter');\nconst nextBtn = document.getElementById('next-chapter');\nconst bookmarkBtn = document.getElementById('bookmark-btn');\nconst colorToggle = document.getElementById('color-toggle');\nconst fontSizeDec = document.getElementById('font-size-dec');\nconst fontSizeInc = document.getElementById('font-size-inc');\nconst settingsBtn = document.getElementById('settings-btn');\nconst settingsModal = document.getElementById('settings-modal');\nconst splitPatternInput = document.getElementById('split-pattern');\nconst saveSettingsBtn = document.getElementById('save-settings');\nconst closeSettingsBtn = document.getElementById('close-settings');\nconst titlePatternInput = document.getElementById('title-pattern');\nconst titleRegexInput = document.getElementById('title-regex');\nconst splitRegexInput = document.getElementById('split-regex');\nconst showMenuBtn = document.getElementById('show-menu-btn');\nconst menuMask = document.getElementById('menu-mask');\n\n// 事件绑定\nimportBtn.onclick = () => fileInput.click();\nfileInput.onchange = handleFileImport;\nsettingsBtn.onclick = () => { settingsModal.style.display = 'block'; };\ncloseSettingsBtn.onclick = () => { settingsModal.style.display = 'none'; };\nsaveSettingsBtn.onclick = saveSettings;\nprevBtn.onclick = () => jumpToChapter(currentChapter - 1);\nnextBtn.onclick = () => jumpToChapter(currentChapter + 1);\nfunction updateColorToggleText() {\n    colorToggle.textContent = document.body.classList.contains('dark-mode') ? '亮灯' : '关灯';\n}\ncolorToggle.onclick = function() {\n    toggleDarkMode();\n    updateColorToggleText();\n};\nfontSizeDec.onclick = () => changeFontSize(-0.1);\nfontSizeInc.onclick = () => changeFontSize(0.1);\nbookmarkBtn.onclick = toggleBookmark;\n\n// 预留：加载缓存、初始化设置\nwindow.onload = function() {\n    loadCache();\n    applySettings();\n    // 设置弹窗初始值\n    splitPatternInput.value = settings.splitPattern || '\\n\\n';\n    splitRegexInput.checked = !!settings.splitRegex;\n    titlePatternInput.value = settings.titlePattern || '^.*$';\n    titleRegexInput.checked = !!settings.titleRegex;\n    updateColorToggleText();\n};\n\nfunction handleFileImport(e) {\n    const file = e.target.files[0];\n    if (!file) return;\n    loadingDiv.style.display = 'block';\n    currentFileName = file.name; // 记录当前文件名\n    localStorage.setItem('novel_reader_last_file', currentFileName); // 记住上次打开的文件名\n    localStorage.removeItem('novel_reader_cache');\n    const reader = new FileReader();\n    reader.onload = function(evt) {\n        const text = evt.target.result;\n        originalText = text; // 保存原始全文\n        splitChapters(text);\n        loadingDiv.style.display = 'none';\n        renderChapterMenu();\n        jumpToChapter(0);\n        saveCache();\n    };\n    reader.readAsText(file, 'utf-8');\n}\n\nfunction splitChapters(text) {\n    let pattern = settings.splitPattern || '\\n\\n';\n    let useRegex = settings.splitRegex;\n    try {\n        if (useRegex) {\n            splitPattern = new RegExp(pattern, 'g');\n        } else {\n            splitPattern = pattern.replace(/\\\\n/g, '\\n');\n        }\n    } catch {\n        splitPattern = /\\n\\n/g;\n    }\n    if (useRegex) {\n        chapters = text.split(splitPattern).map(s => s.trim()).filter(Boolean);\n    } else {\n        chapters = text.split(splitPattern).map(s => s.trim()).filter(Boolean);\n    }\n}\n\nfunction renderChapterMenu() {\n    chapterMenu.innerHTML = '';\n    // 获取当前文件的书签\n    let bookmarks = bookmarksMap[currentFileName] || [];\n    chapters.forEach((chapter, idx) => {\n        // 章节名提取\n        let title = '';\n        if (settings.titleRegex) {\n            try {\n                const match = chapter.match(new RegExp(settings.titlePattern || '^.*$', 'm'));\n                title = match ? match[0] : `第${idx+1}章`;\n            } catch {\n                title = chapter.split('\\n')[0] || `第${idx+1}章`;\n            }\n        } else {\n            // 普通模式：取第一行\n            title = chapter.split(settings.titlePattern || '\\n')[0] || `第${idx+1}章`;\n        }\n        const btn = document.createElement('button');\n        btn.textContent = title;\n        btn.onclick = () => jumpToChapter(idx);\n        if (idx === currentChapter) btn.classList.add('active');\n        if (bookmarks.includes(idx)) btn.classList.add('bookmarked');\n        if (title.length  {\n        btn.classList.toggle('active', i === idx);\n        btn.classList.toggle('bookmarked', bookmarks.includes(i));\n    });\n    const chapter = chapters[idx] || '';\n    const lines = chapter.split('\\n');\n    chapterTitle.textContent = lines[0] || `第${idx+1}章`;\n    chapterContent.innerHTML = lines.slice(1).map(p => `${p.replace(/\\s/g, '&nbsp;')}`).join('');\n    bookmarkBtn.classList.toggle('active', bookmarks.includes(currentChapter));\n    chapterContent.scrollTop = 0;\n    // 自动将当前目录按钮滚动到中间\n    if (btns[idx]) {\n        const menu = chapterMenu;\n        const btn = btns[idx];\n        const menuRect = menu.getBoundingClientRect();\n        const btnRect = btn.getBoundingClientRect();\n        menu.scrollTop = btn.offsetTop - menu.offsetHeight / 2 + btn.offsetHeight / 2;\n    }\n    saveCache();\n}\n\nfunction toggleBookmark() {\n    if (!currentFileName) return;\n    let bookmarks = bookmarksMap[currentFileName] || [];\n    if (!bookmarks.includes(currentChapter)) {\n        bookmarks.push(currentChapter);\n    } else {\n        bookmarks = bookmarks.filter(b => b !== currentChapter);\n    }\n    bookmarksMap[currentFileName] = bookmarks;\n    renderChapterMenu(); // 立即刷新目录高亮\n    saveCache();\n}\n\nfunction toggleDarkMode() {\n    settings.darkMode = !settings.darkMode;\n    applySettings();\n    saveCache();\n}\n\nfunction changeFontSize(delta) {\n    settings.fontSize = Math.max(0.8, Math.min(2.5, (settings.fontSize || 1.1) + delta));\n    applySettings();\n    saveCache();\n}\n\nfunction applySettings() {\n    if (settings.darkMode) {\n        document.body.classList.add('dark-mode');\n        chapterContent.style.background = '#23272e';\n        chapterContent.style.color = '#e0e0e0';\n        document.getElementById('reader-section').style.background = '#23272e';\n    } else {\n        document.body.classList.remove('dark-mode');\n        chapterContent.style.background = '';\n        chapterContent.style.color = '';\n        document.getElementById('reader-section').style.background = '';\n    }\n    chapterContent.style.fontSize = settings.fontSize + 'rem';\n    updateColorToggleText();\n}\n\nfunction saveSettings() {\n    settings.splitPattern = splitPatternInput.value || '\\n\\n';\n    settings.splitRegex = splitRegexInput.checked;\n    settings.titlePattern = titlePatternInput.value || '^.*$';\n    settings.titleRegex = titleRegexInput.checked;\n    settingsModal.style.display = 'none';\n    // 重新分割章节并刷新目录，基于原始全文\n    if (originalText) {\n        splitChapters(originalText);\n        renderChapterMenu();\n        jumpToChapter(0);\n    }\n    saveCache();\n}\n\nfunction saveCache() {\n    // 保存所有文件的书签\n    localStorage.setItem('novel_reader_cache', JSON.stringify({\n        currentChapter,\n        bookmarksMap,\n        settings,\n        currentFileName\n    }));\n}\n\nfunction loadCache() {\n    const cache = localStorage.getItem('novel_reader_cache');\n    if (!cache) return;\n    try {\n        const data = JSON.parse(cache);\n        currentChapter = data.currentChapter || 0;\n        bookmarksMap = data.bookmarksMap || {};\n        settings = Object.assign(settings, data.settings || {});\n        currentFileName = data.currentFileName || '';\n        splitPatternInput.value = settings.splitPattern || '\\n\\n';\n    } catch {}\n} "},{"title":"Tools","url":"/tools/index.html","content":"欢迎来到我的工具页面！以下都是我做的一些小工具&#x2F;程序和收藏的网站，包括一些变成上的常见的问题的解答之类的，如果对你有帮助的话荣幸至极！\nItsuyoの工坊\n\n\n工具\n描述\n\n\n\nUma Card Maker \n简便的赛马娘支援卡DIY制作器，支持基础的编辑与下载\n\n\nPic_Hide_Barcode \n在一张普通图片里隐藏二维码，可以被微信识别。我改的，功能更多一点。注意，在ios上成功率高，其他的上面有不小概率失败。\n\n\nAnime_Browser \n寻找免费动漫源！\n\n\n如果感兴趣的话可以点击超链接去看看喵~以后会持续更新！\n\n值得书签一些我觉得很有意思的网站与工具~\n持续更新~\n\n编程FAQ一些我在编程途中经常遇到要查的问题~\n持续更新~\n"},{"url":"/uma/README.html","content":"\n    \n        Uma Card Maker\n        \n    \n\n\n赛马娘支援卡制作器: https://abyss-seeker.github.io/Uma-Card-Maker \n使用指南\n            \n                欢迎使用 赛马娘支援卡制作器 (Uma Card Maker) 喵~基本的功能如下：\n                \n                    可以上传图片并在支持卡上进行缩放、拖动、翻转等操作。\n                    可以选择支持卡的属性和品级，以及预览最终效果。\n                    右上角的是github repo链接哦~\n                \n            \n            使用指南：\n            \n                上传图片：点击 \"图片选择\" 按钮，选择你想要制作的支持卡的图片。支持的图片格式包括 JPG、PNG 等。\n                编辑支持卡：图片上传后，你可以在支持卡上进行缩放、拖动、翻转等操作。\n                选择支持卡属性和品级：使用下拉菜单选择支持卡的属性（速度、耐力、力量、毅力、智力、友人、团队）和品级（SSR、SR、R）。\n                预览和下载：在编辑完成后，你可以预览支持卡的最终效果，并点击 \"下载支援卡\" 按钮将支持卡保存到你的设备上。\n                GitHub 仓库链接：点击页面右上角的 GitHub 图标，访问应用程序的 GitHub 仓库，查看源代码并提出建议或报告问题。\n                需要帮助？：如果有什么bug的话，欢迎在github issues部分里面告诉我！\n            "},{"url":"/pong-mobile/index.html","content":"\n\n\n    \n    \n    \n    \n    \n    Cyberpongk\n    \n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n            font-family: 'Segoe UI', Tahoma, 'Microsoft YaHei', sans-serif;\n        }\n\n        body {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            min-height: 100vh;\n            background: linear-gradient(135deg, #0c1027, #1a1f4b, #0c1027);\n            background-size: 400% 400%;\n            animation: gradientBG 15s ease infinite;\n            overflow: hidden;\n            color: #e1e6ff;\n            padding: 20px;\n        }\n\n        /* 新增开始页面样式 */\n        .start-screen {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(8, 15, 32, 0.95);\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            z-index: 2000;\n            backdrop-filter: blur(5px);\n            transition: opacity 0.8s ease, transform 0.8s ease;\n        }\n\n        .start-screen.hidden {\n            opacity: 0;\n            pointer-events: none;\n            transform: translateY(20px);\n        }\n\n        .start-container {\n            width: 100%;\n            max-width: 700px;\n            padding: 30px;\n            background: rgba(12, 22, 45, 0.85);\n            border: 1px solid rgba(101, 80, 255, 0.3);\n            border-radius: 15px;\n            box-shadow: 0 0 50px rgba(101, 80, 255, 0.4);\n            position: relative;\n            overflow: hidden;\n        }\n\n        .start-container::before {\n            content: '';\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(45deg,\n                transparent 0%,\n                rgba(101, 80, 255, 0.1) 50%,\n                transparent 100%);\n            animation: scanLine 8s linear infinite;\n            z-index: -1;\n        }\n\n        .start-title {\n            text-align: center;\n            font-size: 3.5rem;\n            color: #e1e6ff;\n            text-shadow: 0 0 20px rgba(101, 80, 255, 0.8);\n            margin-bottom: 20px;\n            letter-spacing: 3px;\n            font-weight: 800;\n            position: relative;\n        }\n\n        .start-title::after {\n            content: '';\n            position: absolute;\n            bottom: -10px;\n            left: 50%;\n            transform: translateX(-50%);\n            width: 150px;\n            height: 3px;\n            background: linear-gradient(90deg, transparent, #6550ff, transparent);\n        }\n\n        .start-subtitle {\n            text-align: center;\n            color: #a0a8ff;\n            font-size: 1.2rem;\n            margin-bottom: 40px;\n            max-width: 600px;\n            line-height: 1.6;\n        }\n\n        .start-options {\n            margin-bottom: 40px;\n        }\n\n        .option-group {\n            margin-bottom: 25px;\n        }\n\n        .option-title {\n            font-size: 1.4rem;\n            color: #e1e6ff;\n            margin-bottom: 15px;\n            display: flex;\n            align-items: center;\n        }\n\n        .option-title::before {\n            content: '▶';\n            color: #ffcc00;\n            margin-right: 10px;\n            font-size: 0.8rem;\n        }\n\n        .difficulty-options {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));\n            gap: 12px;\n        }\n\n        .start-difficulty-option {\n            background: rgba(16, 24, 48, 0.7);\n            border: 1px solid rgba(101, 80, 255, 0.3);\n            color: #e1e6ff;\n            padding: 12px 5px;\n            border-radius: 8px;\n            cursor: pointer;\n            text-align: center;\n            transition: all 0.3s ease;\n            position: relative;\n            overflow: hidden;\n        }\n\n        .start-difficulty-option:hover {\n            background: rgba(101, 80, 255, 0.4);\n            transform: translateY(-3px);\n            box-shadow: 0 5px 15px rgba(101, 80, 255, 0.3);\n        }\n\n        .start-difficulty-option.active {\n            background: rgba(101, 80, 255, 0.6);\n            border-color: #6550ff;\n            box-shadow: 0 0 15px rgba(101, 80, 255, 0.5);\n        }\n\n        .ai-toggle-container {\n            display: flex;\n            align-items: center;\n            background: rgba(16, 24, 48, 0.7);\n            border: 1px solid rgba(255, 165, 0, 0.3);\n            border-radius: 8px;\n            padding: 15px;\n            transition: all 0.3s ease;\n        }\n\n        .ai-toggle-container:hover {\n            background: rgba(255, 165, 0, 0.2);\n            transform: translateY(-3px);\n            box-shadow: 0 5px 15px rgba(255, 165, 0, 0.2);\n        }\n\n        .ai-toggle-label {\n            flex-grow: 1;\n            font-size: 1.1rem;\n            color: #e1e6ff;\n        }\n\n        .ai-toggle {\n            position: relative;\n            width: 60px;\n            height: 30px;\n        }\n\n        .ai-toggle input {\n            opacity: 0;\n            width: 0;\n            height: 0;\n        }\n\n        .ai-toggle-slider {\n            position: absolute;\n            cursor: pointer;\n            top: 0;\n            left: 0;\n            right: 0;\n            bottom: 0;\n            background-color: rgba(255, 68, 68, 0.5);\n            transition: .4s;\n            border-radius: 30px;\n        }\n\n        .ai-toggle-slider:before {\n            position: absolute;\n            content: \"\";\n            height: 22px;\n            width: 22px;\n            left: 4px;\n            bottom: 4px;\n            background-color: #e1e6ff;\n            transition: .4s;\n            border-radius: 50%;\n        }\n\n        input:checked + .ai-toggle-slider {\n            background-color: rgba(0, 200, 83, 0.7);\n        }\n\n        input:checked + .ai-toggle-slider:before {\n            transform: translateX(30px);\n        }\n\n        .start-button {\n            display: block;\n            width: 100%;\n            max-width: 300px;\n            margin: 0 auto;\n            background: linear-gradient(135deg, #6550ff, #8a7cff);\n            border: none;\n            color: #e1e6ff;\n            padding: 15px;\n            font-size: 1.4rem;\n            border-radius: 8px;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            font-weight: bold;\n            letter-spacing: 1px;\n            text-transform: uppercase;\n            position: relative;\n            overflow: hidden;\n            z-index: 1;\n        }\n\n        .start-button::before {\n            content: '';\n            position: absolute;\n            top: -2px;\n            left: -2px;\n            right: -2px;\n            bottom: -2px;\n            background: linear-gradient(135deg,\n                #6550ff, #8a7cff,\n                #ffcc00, #ff3366,\n                #6550ff, #8a7cff);\n            background-size: 300% 300%;\n            z-index: -1;\n            border-radius: 10px;\n            animation: gradientBG 3s ease infinite;\n        }\n\n        .start-button:hover {\n            transform: scale(1.05);\n            box-shadow: 0 0 30px rgba(101, 80, 255, 0.6);\n        }\n\n        .start-button:active {\n            transform: scale(0.98);\n        }\n\n        @keyframes scanLine {\n            0% { transform: translateY(-100%); }\n            100% { transform: translateY(100%); }\n        }\n\n        @keyframes gradientBG {\n            0% { background-position: 0% 50%; }\n            50% { background-position: 100% 50%; }\n            100% { background-position: 0% 50%; }\n        }\n\n        .game-container {\n            position: relative;\n            width: 100%;\n            max-width: 900px;\n            background: rgba(12, 16, 39, 0.8);\n            border-radius: 16px;\n            box-shadow: 0 0 40px rgba(101, 80, 255, 0.3);\n            overflow: hidden;\n            border: 1px solid rgba(101, 80, 255, 0.3);\n            backdrop-filter: blur(10px);\n        }\n\n        .game-header {\n            text-align: center;\n            padding: 5px;\n            background: rgba(0, 0, 0, 0.4);\n            border-bottom: 1px solid rgba(101, 80, 255, 0.3);\n        }\n\n        .game-title {\n            color: #e1e6ff;\n            font-size: 2.5rem;\n            margin-bottom: 10px;\n            text-shadow: 0 0 15px #6550ff;\n            letter-spacing: 2px;\n            font-weight: 700;\n        }\n\n        .game-subtitle {\n            color: #a0a8ff;\n            font-size: 1.1rem;\n            opacity: 0.8;\n        }\n\n        .game-stats {\n            display: flex;\n            justify-content: space-between;\n            padding: 5px 30px;\n            background: rgba(16, 20, 45, 0.7);\n            position: relative;\n        }\n\n        .player-stats {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            position: relative;\n        }\n\n        .player-name {\n            font-size: 1.2rem;\n            margin-bottom: 5px;\n            color: #a0a8ff;\n        }\n\n        .player-score {\n            font-size: 2.5rem;\n            font-weight: bold;\n            color: #ffcc00;\n            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);\n            position: relative;\n        }\n\n        .score-animation {\n            position: absolute;\n            font-size: 3rem;\n            color: #ff3366;\n            opacity: 0;\n            animation: scorePopup 1s forwards;\n            pointer-events: none;\n            z-index: 10;\n            text-shadow: 0 0 15px rgba(255, 51, 102, 0.7);\n        }\n\n        @keyframes scorePopup {\n            0% {\n                transform: translateY(0);\n                opacity: 1;\n            }\n            100% {\n                transform: translateY(-100px);\n                opacity: 0;\n            }\n        }\n\n        .game-content {\n            position: relative;\n            display: flex;\n            justify-content: center;\n            padding: 20px;\n        }\n\n        #game-canvas {\n            background: rgba(8, 12, 33, 0.7);\n            border-radius: 8px;\n            box-shadow: 0 0 30px rgba(101, 80, 255, 0.2);\n            border: 1px solid rgba(101, 80, 255, 0.2);\n        }\n\n        .controls-info {\n            text-align: center;\n            padding: 15px;\n            font-size: 1rem;\n            color: #a0a8ff;\n            background: rgba(16, 20, 45, 0.6);\n            border-top: 1px solid rgba(101, 80, 255, 0.2);\n        }\n\n        .particle {\n            position: absolute;\n            pointer-events: none;\n            border-radius: 50%;\n            background: #ffcc00;\n            opacity: 0.8;\n        }\n\n        .center-line {\n            position: absolute;\n            top: 0;\n            bottom: 0;\n            left: 50%;\n            width: 2px;\n            background: linear-gradient(to bottom,\n                transparent 0%,\n                rgba(101, 80, 255, 0.5) 10%,\n                rgba(101, 80, 255, 0.8) 50%,\n                rgba(101, 80, 255, 0.5) 90%,\n                transparent 100%);\n            transform: translateX(-50%);\n        }\n\n        .glow-effect {\n            position: absolute;\n            top: 0;\n            left: 0;\n            right: 0;\n            bottom: 0;\n            border-radius: 16px;\n            box-shadow: inset 0 0 30px rgba(101, 80, 255, 0.5);\n            pointer-events: none;\n            z-index: -1;\n        }\n\n        .victory-overlay {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(12, 16, 39, 0.85);\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            z-index: 100;\n            opacity: 0;\n            pointer-events: none;\n            transition: opacity 0.5s ease;\n        }\n\n        .victory-message {\n            font-size: 4rem;\n            font-weight: bold;\n            color: #ffcc00;\n            text-shadow: 0 0 20px rgba(255, 204, 0, 0.8);\n            margin-bottom: 30px;\n            text-align: center;\n            animation: pulse 1.5s infinite;\n        }\n\n        .restart-btn {\n            background: rgba(101, 80, 255, 0.5);\n            border: 2px solid #a0a8ff;\n            color: #e1e6ff;\n            padding: 12px 35px;\n            font-size: 1.2rem;\n            border-radius: 8px;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            font-weight: bold;\n            letter-spacing: 1px;\n        }\n\n        .restart-btn:hover {\n            background: rgba(101, 80, 255, 0.8);\n            transform: scale(1.05);\n            box-shadow: 0 0 20px rgba(101, 80, 255, 0.5);\n        }\n\n        @keyframes pulse {\n            0% { transform: scale(1); text-shadow: 0 0 20px rgba(255, 204, 0, 0.8); }\n            50% { transform: scale(1.1); text-shadow: 0 0 30px rgba(255, 204, 0, 1); }\n            100% { transform: scale(1); text-shadow: 0 0 20px rgba(255, 204, 0, 0.8); }\n        }\n\n        .obstacle-warning {\n            position: absolute;\n            border-radius: 50%;\n            pointer-events: none;\n            z-index: 5;\n            animation: warningPulse 0.5s infinite alternate;\n        }\n\n        @keyframes warningPulse {\n            0% { opacity: 0.3; transform: scale(0.8); }\n            100% { opacity: 0.7; transform: scale(1.1); }\n        }\n\n        /* 事件弹窗样式 */\n        .event-notification {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            background: rgba(12, 16, 39, 0.95);\n            border: 2px solid;\n            border-radius: 12px;\n            padding: 15px 20px;\n            min-width: 250px;\n            max-width: 350px;\n            z-index: 1000;\n            transform: translateX(100%);\n            transition: transform 0.5s ease, opacity 0.5s ease;\n            backdrop-filter: blur(10px);\n            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n        }\n\n        .event-notification.show {\n            transform: translateX(0);\n            opacity: 1;\n        }\n\n        .event-notification.positive {\n            border-color: #00ff88;\n            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);\n        }\n\n        .event-notification.neutral {\n            border-color: #888888;\n            box-shadow: 0 0 20px rgba(136, 136, 136, 0.3);\n        }\n\n        .event-notification.negative {\n            border-color: #ff4444;\n            box-shadow: 0 0 20px rgba(255, 68, 68, 0.3);\n        }\n\n        .event-title {\n            font-size: 1.2rem;\n            font-weight: bold;\n            margin-bottom: 5px;\n            color: #e1e6ff;\n        }\n\n        .event-description {\n            font-size: 0.9rem;\n            color: #a0a8ff;\n            line-height: 1.4;\n        }\n\n        .event-trigger {\n            font-size: 0.8rem;\n            color: #ffcc00;\n            margin-bottom: 8px;\n            font-weight: bold;\n        }\n\n        @keyframes slideInRight {\n            from {\n                transform: translateX(100%);\n                opacity: 0;\n            }\n            to {\n                transform: translateX(0);\n                opacity: 1;\n            }\n        }\n\n        @keyframes slideOutRight {\n            from {\n                transform: translateX(0);\n                opacity: 1;\n            }\n            to {\n                transform: translateX(100%);\n                opacity: 0;\n            }\n        }\n\n        /* 暂停/重新开始按钮样式 */\n        .pause-button {\n            position: fixed;\n            top: 20px;\n            right: 5%;\n            transform: translateX(50%);\n            background: rgba(101, 80, 255, 0.8);\n            border: 2px solid rgba(101, 80, 255, 0.9);\n            color: #e1e6ff;\n            padding: 12px 24px;\n            font-size: 1rem;\n            border-radius: 8px;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            font-weight: bold;\n            letter-spacing: 1px;\n            z-index: 1000;\n            backdrop-filter: blur(10px);\n            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);\n        }\n\n        .pause-button:hover {\n            background: rgba(101, 80, 255, 1);\n            transform: translateX(50%) scale(1.05);\n            box-shadow: 0 0 20px rgba(101, 80, 255, 0.6);\n        }\n\n        .pause-button.paused {\n            background: rgba(255, 68, 68, 0.8);\n            border-color: rgba(255, 68, 68, 0.9);\n        }\n\n        .pause-button.paused:hover {\n            background: rgba(255, 68, 68, 1);\n            box-shadow: 0 0 20px rgba(255, 68, 68, 0.6);\n        }\n\n        /* 调试窗口样式 */\n        .debug-panel {\n            position: fixed;\n            top: 20px;\n            left: 20px;\n            background: rgba(12, 16, 39, 0.95);\n            border: 2px solid rgba(255, 68, 68, 0.5);\n            border-radius: 12px;\n            padding: 15px;\n            width: 60px;\n            height: 60px;\n            z-index: 1000;\n            transition: all 0.3s ease;\n            backdrop-filter: blur(10px);\n            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n            cursor: pointer;\n            overflow: hidden;\n        }\n\n        .debug-panel:hover {\n            width: 280px;\n            height: 420px;\n            cursor: default;\n        }\n\n        .debug-icon {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            font-size: 24px;\n            color: #ff4444;\n            transition: opacity 0.3s ease;\n        }\n\n        .debug-panel:hover .debug-icon {\n            opacity: 0;\n        }\n\n        .debug-content {\n            opacity: 0;\n            transition: opacity 0.3s ease 0.1s;\n            height: 100%;\n            display: flex;\n            flex-direction: column;\n            font-size: 0.85rem;\n        }\n\n        .debug-panel:hover .debug-content {\n            opacity: 1;\n        }\n\n        .debug-title {\n            color: #e1e6ff;\n            font-size: 1.1rem;\n            font-weight: bold;\n            margin-bottom: 15px;\n            text-align: center;\n            border-bottom: 1px solid rgba(255, 68, 68, 0.3);\n            padding-bottom: 8px;\n        }\n\n        .debug-section {\n            margin-bottom: 12px;\n        }\n\n        .debug-section-title {\n            color: #ff4444;\n            font-weight: bold;\n            margin-bottom: 5px;\n            font-size: 0.9rem;\n        }\n\n        .debug-item {\n            color: #a0a8ff;\n            margin: 2px 0;\n            display: flex;\n            justify-content: space-between;\n        }\n\n        .debug-label {\n            color: #e1e6ff;\n        }\n\n        .debug-value {\n            color: #ffcc00;\n            font-weight: bold;\n        }\n\n        /* 难度调整窗口样式 */\n        .difficulty-panel {\n            position: fixed;\n            top: 50%;\n            right: 20px;\n            transform: translateY(-50%);\n            background: rgba(12, 16, 39, 0.95);\n            border: 2px solid rgba(101, 80, 255, 0.5);\n            border-radius: 12px;\n            padding: 15px;\n            width: 60px;\n            height: 60px;\n            z-index: 1000;\n            transition: all 0.3s ease;\n            backdrop-filter: blur(10px);\n            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n            cursor: pointer;\n            overflow: hidden;\n        }\n\n        .difficulty-panel:hover {\n            width: 200px;\n            height: 320px;\n            cursor: default;\n        }\n\n        .difficulty-icon {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            font-size: 24px;\n            color: #6550ff;\n            transition: opacity 0.3s ease;\n        }\n\n        .difficulty-panel:hover .difficulty-icon {\n            opacity: 0;\n        }\n\n        .difficulty-content {\n            opacity: 0;\n            transition: opacity 0.3s ease 0.1s;\n            height: 100%;\n            display: flex;\n            flex-direction: column;\n        }\n\n        .difficulty-panel:hover .difficulty-content {\n            opacity: 1;\n        }\n\n        .difficulty-title {\n            color: #e1e6ff;\n            font-size: 1.1rem;\n            font-weight: bold;\n            margin-bottom: 15px;\n            text-align: center;\n        }\n\n        .difficulty-option {\n            background: rgba(101, 80, 255, 0.3);\n            border: 1px solid rgba(101, 80, 255, 0.5);\n            color: #e1e6ff;\n            padding: 8px 12px;\n            margin: 3px 0;\n            border-radius: 6px;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            font-size: 0.9rem;\n            text-align: center;\n        }\n\n        .difficulty-option:hover {\n            background: rgba(101, 80, 255, 0.6);\n            transform: scale(1.02);\n        }\n\n        .difficulty-option.active {\n            background: rgba(101, 80, 255, 0.8);\n            border-color: #6550ff;\n            box-shadow: 0 0 10px rgba(101, 80, 255, 0.5);\n        }\n\n        /* 电脑回球增强选项样式 */\n        .ai-enhancement-option {\n            background: rgba(255, 165, 0, 0.3);\n            border: 1px solid rgba(255, 165, 0, 0.5);\n            color: #e1e6ff;\n            padding: 8px 12px;\n            margin: 8px 0;\n            border-radius: 6px;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            font-size: 0.9rem;\n            text-align: center;\n        }\n\n        .ai-enhancement-option:hover {\n            background: rgba(255, 165, 0, 0.6);\n            transform: scale(1.02);\n        }\n\n        .ai-enhancement-option.active {\n            background: rgba(255, 165, 0, 0.8);\n            border-color: #ffa500;\n            box-shadow: 0 0 10px rgba(255, 165, 0, 0.5);\n        }\n\n        @media (max-width: 768px) {\n            .game-title {\n                font-size: 2rem;\n            }\n\n            .game-subtitle {\n                font-size: 0.9rem;\n            }\n\n            .player-name {\n                font-size: 1rem;\n            }\n\n            .player-score {\n                font-size: 2rem;\n            }\n\n            .victory-message {\n                font-size: 2.5rem;\n            }\n\n            .event-notification {\n                top: 10px;\n                right: 10px;\n                min-width: 200px;\n                max-width: 280px;\n                padding: 12px 15px;\n            }\n\n            .event-title {\n                font-size: 1rem;\n            }\n\n            .event-description {\n                font-size: 0.8rem;\n            }\n\n            .difficulty-panel {\n                right: 10px;\n                width: 50px;\n                height: 50px;\n            }\n\n            .difficulty-panel:hover {\n                width: 180px;\n                height: 280px;\n            }\n\n            .difficulty-icon {\n                font-size: 20px;\n            }\n\n            .debug-panel {\n                left: 10px;\n                width: 50px;\n                height: 50px;\n            }\n\n            .debug-panel:hover {\n                width: 260px;\n                height: 300px;\n            }\n\n            .debug-icon {\n                font-size: 20px;\n            }\n\n            .pause-button {\n                top: 10px;\n                padding: 10px 20px;\n                font-size: 0.9rem;\n            }\n\n            /* 移动端虚拟按钮样式 */\n            .mobile-controls {\n                position: fixed;\n                bottom: 20px;\n                left: 20px;\n                z-index: 3000;\n                display: flex;\n                flex-direction: column;\n                gap: 10px;\n            }\n\n            .mobile-btn {\n                width: 60px;\n                height: 60px;\n                border-radius: 50%;\n                border: none;\n                background: rgba(101, 80, 255, 0.8);\n                color: white;\n                font-size: 24px;\n                font-weight: bold;\n                cursor: pointer;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);\n                transition: all 0.2s ease;\n                user-select: none;\n                -webkit-user-select: none;\n                -webkit-touch-callout: none;\n            }\n\n            .mobile-btn:active {\n                transform: scale(0.95);\n                background: rgba(101, 80, 255, 1);\n            }\n\n            .mobile-btn.up {\n                background: rgba(0, 200, 83, 0.8);\n            }\n\n            .mobile-btn.down {\n                background: rgba(255, 68, 68, 0.8);\n            }\n\n            /* 移动端开始页面优化 */\n            .start-container {\n                margin: 10px;\n                padding: 20px;\n            }\n\n            .start-title {\n                font-size: 2.5rem;\n            }\n\n            .start-subtitle {\n                font-size: 1rem;\n            }\n\n            .difficulty-options {\n                grid-template-columns: repeat(2, 1fr);\n                gap: 8px;\n            }\n\n            .start-difficulty-option {\n                padding: 8px 4px;\n                font-size: 0.9rem;\n            }\n\n            .ai-toggle-label {\n                font-size: 1rem;\n            }\n\n            .start-button {\n                padding: 12px;\n                font-size: 1.2rem;\n            }\n\n            /* 移动端游戏容器优化 */\n            .game-container {\n                margin: 5px;\n                border-radius: 12px;\n            }\n\n            .game-content {\n                padding: 10px;\n            }\n\n            .controls-info {\n                font-size: 0.8rem;\n                padding: 10px;\n            }\n        }\n\n        /* 超小屏幕优化 */\n        @media (max-width: 480px) {\n            .game-title {\n                font-size: 1.5rem;\n            }\n\n            .game-subtitle {\n                font-size: 0.8rem;\n            }\n\n            .player-score {\n                font-size: 1.5rem;\n            }\n\n            .victory-message {\n                font-size: 2rem;\n            }\n\n            .mobile-btn {\n                width: 50px;\n                height: 50px;\n                font-size: 20px;\n            }\n\n            .start-title {\n                font-size: 2rem;\n            }\n\n            .difficulty-options {\n                grid-template-columns: 1fr;\n            }\n\n            .start-difficulty-option {\n                font-size: 0.8rem;\n            }\n        }\n\n        /* 移动端触摸优化 */\n        @media (max-width: 768px) {\n            body {\n                overflow: hidden;\n                position: fixed;\n                width: 100%;\n                height: 100%;\n                touch-action: none;\n                -webkit-overflow-scrolling: touch;\n            }\n\n            canvas {\n                touch-action: none;\n                -webkit-user-select: none;\n                -moz-user-select: none;\n                -ms-user-select: none;\n                user-select: none;\n            }\n\n            /* 防止双击缩放 */\n            * {\n                -webkit-touch-callout: none;\n                -webkit-user-select: none;\n                -khtml-user-select: none;\n                -moz-user-select: none;\n                -ms-user-select: none;\n                user-select: none;\n            }\n\n            /* 虚拟按钮触摸反馈 */\n            .mobile-btn {\n                -webkit-tap-highlight-color: transparent;\n            }\n\n            .mobile-btn:active {\n                transform: scale(0.9);\n                transition: transform 0.1s ease;\n            }\n        }\n    \n\n\n    \n    \n        \n            CYBERPONGK\n            直面强敌，守住底线，转战回击为了最佳的游戏体验，请打开敌方回球增强\n\n            \n                \n                    作战难度\n                    \n                        万泉部诗人\n                        野比大雄\n                        少女B\n                        小埋\n                        空&白\n                    \n                \n\n                \n                    敌方强化模块\n                    \n                        激活敌方回球增强协议\n                        \n                            \n                            \n                        \n                    \n                \n            \n\n            启动战斗系统\n        \n    \n\n    \n        \n        \n            CYBERPONGK\n            Itsuyo的摸鱼大（存疑）作 · Crafted with Deepsuck\n        \n\n        \n            \n                玩家\n                0\n            \n\n            \n                电脑\n                0\n            \n        \n\n        \n            \n            \n        \n\n        \n            \n            重新开始\n        \n\n        \n            使用鼠标移动控制你的挡板 | 首先获得3分者获胜 | 收集事件获得特殊效果！\n        \n    \n\n    \n    \n        ⚙️\n        \n            难度设置\n            万泉部诗人\n            野比大雄\n            少女B\n            小埋\n            空&白\n\n            \n            \n                敌方回球增强\n            \n        \n    \n\n    \n    \n        🐛\n        \n            调试信息\n            \n            \n                球状态\n                \n                    速度:\n                    0\n                \n                \n                    位置:\n                    0,0\n                \n                \n                    透明度:\n                    1.0\n                \n            \n\n            \n                电脑数据\n                \n                    速度:\n                    3\n                \n                \n                    位置:\n                    0\n                \n                \n                    速度倍数:\n                    1.0\n                \n            \n\n            \n                事件状态\n                \n                    活跃事件:\n                    0\n                \n                \n                    障碍物:\n                    0\n                \n            \n\n            \n                系统\n                \n                    FPS:\n                    0\n                \n                \n                    游戏时间:\n                    0s\n                \n            \n        \n    \n\n    \n    暂停\n\n    \n    \n        ↑\n        ↓\n    \n\n    \n        // 新增开始页面功能\n        document.addEventListener('DOMContentLoaded', function() {\n            const startScreen = document.getElementById('start-screen');\n            const startButton = document.getElementById('start-button');\n            const startDifficultyOptions = document.querySelectorAll('.start-difficulty-option');\n            const startAiToggle = document.getElementById('start-ai-enhancement');\n\n            // 设置默认选项（简单难度）\n            let selectedDifficulty = 1.75;\n\n            // 开始页面难度选择\n            startDifficultyOptions.forEach(option => {\n                option.addEventListener('click', function() {\n                    // 移除所有active类\n                    startDifficultyOptions.forEach(opt => opt.classList.remove('active'));\n                    // 添加active类到当前选项\n                    this.classList.add('active');\n                    // 更新选择的难度\n                    selectedDifficulty = parseFloat(this.dataset.speed);\n                });\n            });\n\n            // AI回球增强选项\n            startAiToggle.addEventListener('change', function() {\n                aiEnhancementEnabled = this.checked;\n            });\n\n            // 开始按钮事件\n            startButton.addEventListener('click', function() {\n                // 应用选择的难度到游戏内\n                computer.speed = selectedDifficulty;\n\n                // 同步游戏内难度选择\n                document.querySelectorAll('.difficulty-option').forEach(option => {\n                    if (parseFloat(option.dataset.speed) === selectedDifficulty) {\n                        option.classList.add('active');\n                    } else {\n                        option.classList.remove('active');\n                    }\n                });\n\n                // 同步AI增强选项\n                const gameAiToggle = document.getElementById('ai-enhancement-toggle');\n                if (aiEnhancementEnabled) {\n                    gameAiToggle.classList.add('active');\n                } else {\n                    gameAiToggle.classList.remove('active');\n                }\n\n                aiEnhancementEnabled = aiEnhancementEnabled;\n\n                // 隐藏开始页面\n                startScreen.classList.add('hidden');\n\n                // 设置电脑名称\n                const computerNameElement = document.getElementById('computer-player-name');\n                const selectedDifficultyOption = document.querySelector('.difficulty-option.active');\n                computerNameElement.textContent = selectedDifficultyOption.textContent;\n\n                // 重置游戏（如果已经玩过）\n                resetGame();\n            });\n        });\n\n        // 获取Canvas和Context\n        const canvas = document.getElementById('game-canvas');\n        const ctx = canvas.getContext('2d');\n\n        // 玩家和电脑的分数\n        const playerScoreElement = document.getElementById('player-score');\n        const computerScoreElement = document.getElementById('computer-score');\n        let playerScore = 0;\n        let computerScore = 0;\n\n        // 胜利界面元素\n        const victoryOverlay = document.getElementById('victory-overlay');\n        const victoryMessage = document.getElementById('victory-message');\n        const restartBtn = document.getElementById('restart-btn');\n\n        // 添加帧率锁定相关变量\n        const FPS = 120; // 目标帧率\n        const FRAME_INTERVAL = 1000 / FPS; // 每帧时间(ms)\n        let lastTime = 0;\n        let deltaTime = 0;\n        let accumulatedTime = 0;\n        let frameCount = 0;\n        let lastFpsUpdate = 0;\n\n        // 游戏状态\n        let isGameOver = false;\n        let isResetting = false;\n        let isPaused = false; // 添加暂停状态\n        let gameTime = 0; // 游戏运行时间（毫秒）\n        let nextObstacleTime = 15000; // 第一次障碍物出现时间（15秒后）\n        let nextEventTime = 10000; // 第一次事件出现时间（10秒后）\n\n        // 电脑回球增强功能状态\n        let aiEnhancementEnabled = false;\n\n        // 死球检测相关变量\n        let ballStuckDetection = {\n            lastY: 0,\n            stuckTime: 0,\n            checkInterval: 100, // 每100ms检查一次\n            lastCheckTime: 0,\n            stuckThreshold: 2000, // 2秒内卡在边缘判定为死球\n            edgeThreshold: 30 // 距离边缘30像素内算作边缘\n        };\n\n        // 记录上一个触球的玩家 ('player' 或 'computer')\n        let lastTouchedBy = null;\n\n        // 游戏对象\n        const ball = {\n            x: canvas.width / 2,\n            y: canvas.height / 2,\n            radius: 12,\n            speed: 4,\n            velocityX: 5,\n            velocityY: 5,\n            color: '#ffcc00',\n            trail: [],\n            lastCollision: 0, // 记录上次碰撞时间\n            alpha: 1.0, // 球的透明度\n            speedMultiplier: 1.0 // 速度倍数\n        };\n\n        // 玩家挡板\n        const player = {\n            x: 20,\n            y: canvas.height / 2 - 70,\n            width: 15,\n            height: 120,\n            speed: 8,\n            color: '#6550ff',\n            score: 0,\n            originalHeight: 120,\n            glowEffect: false,\n            glowEndTime: 0,\n            rgbEffect: false, // 添加rgb效果属性\n            rgbEndTime: 0 // 添加rgb效果结束时间\n        };\n\n        // 电脑挡板\n        const computer = {\n            x: canvas.width - 35,\n            y: canvas.height / 2 - 70,\n            width: 15,\n            height: 120,\n            speed: 3,\n            color: '#ff3366',\n            score: 0,\n            originalHeight: 120,\n            glowEffect: false,\n            glowEndTime: 0,\n            rgbEffect: false, // 添加rgb效果属性\n            rgbEndTime: 0, // 添加rgb效果结束时间\n            speedMultiplier: 1.0\n        };\n\n        // 粒子数组\n        const particles = [];\n\n        // 障碍物数组\n        const obstacles = [];\n\n        // 事件数组\n        const events = [];\n\n        // 全局效果\n        const globalEffects = {\n            speedVariation: { active: false, endTime: 0 },\n            obstacleSpeedUp: { active: false, endTime: 0, originalInterval: 0 },\n            thunderCloud: { active: false, endTime: 0, flashTime: 0 },\n            // 新增效果\n            immortalTotem: { active: false, endTime: 0, triggeredBy: null },\n            eventFrenzy: { active: false, endTime: 0, originalEventInterval: 0 },\n            heavenMaker: { active: false, endTime: 0, stackCount: 0 },\n            heavyBall: { active: false, endTime: 0, stackCount: 0 }\n        };\n\n        // 事件类型定义\n        const eventTypes = {\n            // 正面事件\n            PADDLE_GROW: {\n                type: 'positive',\n                color: '#00ff88',\n                name: 'Bo♂ki',\n                description: '板子增长20%，持续20秒'\n            },\n            LIGHTNING_PADDLE: {\n                type: 'positive',\n                color: '#ffff00',\n                name: '咖喱棒',\n                description: '获得金闪闪效果，触球增速80%，持续20秒'\n            },\n            SLOW_COMPUTER: {\n                type: 'positive',\n                color: '#00ccff',\n                name: '寒冰菇',\n                description: '电脑板子移动速度-20%，直到下次进球'\n            },\n            \n            // 中性事件\n            SPEED_VARIATION: {\n                type: 'neutral',\n                color: '#888888',\n                name: '致命节奏',\n                description: '球速在70%-130%间变动，持续15秒'\n            },\n            OBSTACLE_RUSH: {\n                type: 'neutral',\n                color: '#aa6600',\n                name: '移动迷宫',\n                description: '障碍物生成速度提升500%，持续30秒'\n            },\n            SPEED_RESET: {\n                type: 'neutral',\n                color: '#666666',\n                name: '食光鸡',\n                description: '球速重置为初始速度'\n            },\n            \n            // 负面事件\n            THUNDER_CLOUD: {\n                type: 'negative',\n                color: '#444444',\n                name: '骤雨的狭间',\n                description: '中央雷云遮挡视野，球经过时改变角度'\n            },\n            PADDLE_SHRINK: {\n                type: 'negative',\n                color: '#660000',\n                name: '阳痿',\n                description: '板子缩短20%，持续20秒'\n            },\n            BALL_FADE: {\n                type: 'negative',\n                color: '#333333',\n                name: '我名为暗影',\n                description: '球透明度降为10%，持续15秒'\n            },\n            \n            // 新增事件\n            // 正面\n            IMMORTAL_TOTEM: {\n                type: 'positive',\n                color: '#ff00ff',\n                name: '不死图腾',\n                description: '触发方在45秒内第一个失球均不计入分数'\n            },\n            // 中性\n            EVENT_FRENZY: {\n                type: 'neutral',\n                color: '#888888',\n                name: 'EVENT☆START',\n                description: '事件刷新率增加为400%，持续30秒'\n            },\n            HEAVEN_MAKER: {\n                type: 'neutral',\n                color: '#cccccc',\n                name: 'MADE IN HEAVEN',\n                description: '球的大小变为原来的50%，速度变为原来的125%，持续25秒'\n            },\n            HEAVY_BALL: {\n                type: 'neutral',\n                color: '#666666',\n                name: '遇水变大变高',\n                description: '球的大小变为原来的200%，速度变为原来的80%，持续25秒'\n            }\n        };\n\n        // 鼠标移动事件监听\n        canvas.addEventListener('mousemove', (e) => {\n            if (isGameOver || isPaused) return; // 添加暂停检查\n            const rect = canvas.getBoundingClientRect();\n            player.y = e.clientY - rect.top - player.height / 2;\n        });\n\n        \n\n        // 重新开始按钮事件\n        restartBtn.addEventListener('click', () => {\n            resetGame();\n        });\n\n        // 难度调整事件监听器\n        document.querySelectorAll('.difficulty-option').forEach(option => {\n            option.addEventListener('click', (e) => {\n                // 移除所有active类\n                document.querySelectorAll('.difficulty-option').forEach(opt => opt.classList.remove('active'));\n                // 添加active类到当前选项\n                e.target.classList.add('active');\n                // 更新电脑速度\n                const newSpeed = parseFloat(e.target.dataset.speed);\n                computer.speed = newSpeed;\n                // 更新电脑名称\n                const computerNameElement = document.getElementById('computer-player-name');\n                computerNameElement.textContent = e.target.textContent;\n            });\n        });\n\n        // 电脑回球增强选项事件监听器\n        document.getElementById('ai-enhancement-toggle').addEventListener('click', (e) => {\n            aiEnhancementEnabled = !aiEnhancementEnabled;\n            if (aiEnhancementEnabled) {\n                e.target.classList.add('active');\n            } else {\n                e.target.classList.remove('active');\n            }\n        });\n\n        // 暂停按钮事件监听器\n        const pauseButton = document.getElementById('pause-button');\n        pauseButton.addEventListener('click', () => {\n            isPaused = !isPaused;\n            if (isPaused) {\n                pauseButton.textContent = '继续';\n                pauseButton.classList.add('paused');\n            } else {\n                pauseButton.textContent = '暂停';\n                pauseButton.classList.remove('paused');\n            }\n        });\n\n        // 显示事件通知弹窗\n        function showEventNotification(eventObj, triggeredBy) {\n            // 移除现有的通知\n            const existingNotification = document.querySelector('.event-notification');\n            if (existingNotification) {\n                existingNotification.remove();\n            }\n\n            // 创建新的通知元素\n            const notification = document.createElement('div');\n            notification.className = `event-notification ${eventObj.typeData.type}`;\n            \n            const triggerText = triggeredBy === 'player' ? '玩家触发' : '电脑触发';\n            \n            notification.innerHTML = `\n                ${triggerText}\n                ${eventObj.typeData.name}\n                ${eventObj.typeData.description}\n            `;\n\n            // 添加到页面\n            document.body.appendChild(notification);\n\n            // 触发显示动画\n            setTimeout(() => {\n                notification.classList.add('show');\n            }, 100);\n\n            // 3秒后自动隐藏\n            setTimeout(() => {\n                notification.classList.remove('show');\n                setTimeout(() => {\n                    if (notification.parentNode) {\n                        notification.remove();\n                    }\n                }, 500);\n            }, 3000);\n        }\n\n        // 显示死球检测通知\n        function showDeadBallNotification() {\n            // 移除现有的通知\n            const existingNotification = document.querySelector('.event-notification');\n            if (existingNotification) {\n                existingNotification.remove();\n            }\n\n            // 创建新的通知元素\n            const notification = document.createElement('div');\n            notification.className = 'event-notification negative';\n\n            notification.innerHTML = `\n                系统检测\n                卡球检测被触发\n                检测到边线死球bug，重新发球\n            `;\n\n            // 添加到页面\n            document.body.appendChild(notification);\n\n            // 触发显示动画\n            setTimeout(() => {\n                notification.classList.add('show');\n            }, 100);\n\n            // 3秒后自动隐藏\n            setTimeout(() => {\n                notification.classList.remove('show');\n                setTimeout(() => {\n                    if (notification.parentNode) {\n                        notification.remove();\n                    }\n                }, 500);\n            }, 3000);\n        }\n\n        // 死球检测函数\n        function checkDeadBall() {\n            const currentTime = Date.now();\n\n            // 每100ms检查一次\n            if (currentTime - ballStuckDetection.lastCheckTime < ballStuckDetection.checkInterval) {\n                return false;\n            }\n\n            ballStuckDetection.lastCheckTime = currentTime;\n\n            // 检查球是否在上下边缘附近\n            const isNearTopEdge = ball.y = (canvas.height - ballStuckDetection.edgeThreshold);\n\n            if (isNearTopEdge || isNearBottomEdge) {\n                // 检查球的Y坐标是否在很小范围内变化（表示卡住了）\n                const yDifference = Math.abs(ball.y - ballStuckDetection.lastY);\n\n                if (yDifference < 5) { // Y坐标变化小于5像素\n                    ballStuckDetection.stuckTime += ballStuckDetection.checkInterval;\n\n                    // 如果卡住时间超过阈值，触发死球检测\n                    if (ballStuckDetection.stuckTime >= ballStuckDetection.stuckThreshold) {\n                        return true;\n                    }\n                } else {\n                    // 球在移动，重置卡住时间\n                    ballStuckDetection.stuckTime = 0;\n                }\n            } else {\n                // 球不在边缘，重置卡住时间\n                ballStuckDetection.stuckTime = 0;\n            }\n\n            ballStuckDetection.lastY = ball.y;\n            return false;\n        }\n\n        // 重置游戏\n        function resetGame() {\n            playerScore = 0;\n            computerScore = 0;\n            playerScoreElement.textContent = '0';\n            computerScoreElement.textContent = '0';\n            victoryOverlay.style.opacity = '0';\n            victoryOverlay.style.pointerEvents = 'none';\n            isGameOver = false;\n            gameTime = 0;\n            nextObstacleTime = 20000;\n            nextEventTime = 10000;\n            obstacles.length = 0;\n            events.length = 0;\n            lastTouchedBy = null;\n\n            // 重置电脑名称\n            document.getElementById('computer-player-name').textContent = '电脑';\n\n            // 重置死球检测\n            ballStuckDetection.lastY = 0;\n            ballStuckDetection.stuckTime = 0;\n            ballStuckDetection.lastCheckTime = 0;\n            \n            // 移除所有事件通知\n            const notifications = document.querySelectorAll('.event-notification');\n            notifications.forEach(notification => notification.remove());\n            \n            // 重置挡板状态\n            player.height = player.originalHeight;\n            player.glowEffect = false;\n            player.glowEndTime = 0;\n            player.rgbEffect = false; // 重置rgb效果\n            player.rgbEndTime = 0; // 重置rgb效果结束时间\n            computer.height = computer.originalHeight;\n            computer.glowEffect = false;\n            computer.glowEndTime = 0;\n            computer.speedMultiplier = 1.0;\n            computer.rgbEffect = false; // 重置rgb效果\n            computer.rgbEndTime = 0; // 重置rgb效果结束时间\n            \n            // 重置球状态\n            ball.alpha = 1.0;\n            ball.speedMultiplier = 1.0;\n            ball.radius = 12; // 重置球的半径\n            \n            // 重置全局效果\n            globalEffects.speedVariation.active = false;\n            globalEffects.obstacleSpeedUp.active = false;\n            globalEffects.thunderCloud.active = false;\n            // 重置新增效果\n            globalEffects.immortalTotem.active = false;\n            globalEffects.immortalTotem.triggeredBy = null;\n            globalEffects.eventFrenzy.active = false;\n            globalEffects.heavenMaker.active = false;\n            globalEffects.heavenMaker.stackCount = 0;\n            globalEffects.heavyBall.active = false;\n            globalEffects.heavyBall.stackCount = 0;\n\n            const computerNameElement = document.getElementById('computer-player-name');\n            const selectedDifficultyOption = document.querySelector('.difficulty-option.active');\n            computerNameElement.textContent = selectedDifficultyOption.textContent;\n            \n            resetBall();\n        }\n\n        // 碰撞粒子效果\n        function createParticles(x, y, color, count = 15) {\n            for (let i = 0; i < count; i++) {\n                particles.push({\n                    x: x,\n                    y: y,\n                    radius: Math.random() * 3 + 1,\n                    color: color,\n                    speed: Math.random() * 3 + 2,\n                    angle: Math.random() * Math.PI * 2,\n                    life: 30\n                });\n            }\n        }\n\n        // 创建得分特效\n        function createScoreEffect(isPlayer) {\n            const scoreEffect = document.createElement('div');\n            scoreEffect.className = 'score-animation';\n            scoreEffect.textContent = '+1';\n\n            const statsContainer = isPlayer ?\n                playerScoreElement.parentElement :\n                computerScoreElement.parentElement;\n\n            statsContainer.appendChild(scoreEffect);\n\n            // 动画结束后移除元素\n            setTimeout(() => {\n                scoreEffect.remove();\n            }, 1000);\n        }\n\n        // 创建事件\n        function createEvent() {\n            // 在中间90%区域生成事件\n            const minX = canvas.width * 0.05;\n            const maxX = canvas.width * 0.95;\n            const minY = canvas.height * 0.05;\n            const maxY = canvas.height * 0.95;\n\n            const x = minX + Math.random() * (maxX - minX);\n            const y = minY + Math.random() * (maxY - minY);\n\n            // 随机选择事件类型\n            const eventTypeKeys = Object.keys(eventTypes);\n            const randomEventType = eventTypeKeys[Math.floor(Math.random() * eventTypeKeys.length)];\n            const eventType = eventTypes[randomEventType];\n\n            events.push({\n                x: x,\n                y: y,\n                radius: 15,\n                type: randomEventType,\n                typeData: eventType,\n                spawnTime: Date.now(),\n                duration: 20000, // 20秒后消失\n                pulsePhase: 0\n            });\n        }\n\n        // 触发事件效果\n        function triggerEvent(eventObj, triggeredBy) {\n            const currentTime = Date.now();\n            \n            // 显示事件通知\n            showEventNotification(eventObj, triggeredBy);\n            \n            switch (eventObj.type) {\n                case 'PADDLE_GROW':\n                    if (triggeredBy === 'player') {\n                        player.height = Math.min(player.height * 1.2, canvas.height * 0.8);\n                        player.glowEndTime = Math.max(player.glowEndTime, currentTime + 20000);\n                    } else {\n                        computer.height = Math.min(computer.height * 1.2, canvas.height * 0.8);\n                        computer.glowEndTime = Math.max(computer.glowEndTime, currentTime + 20000);\n                    }\n                    break;\n                    \n                case 'LIGHTNING_PADDLE':\n                    if (triggeredBy === 'player') {\n                        player.glowEffect = true;\n                        player.glowEndTime = Math.max(player.glowEndTime, currentTime + 20000);\n                    } else {\n                        computer.glowEffect = true;\n                        computer.glowEndTime = Math.max(computer.glowEndTime, currentTime + 20000);\n                    }\n                    break;\n                    \n                case 'SLOW_COMPUTER':\n                    // 这个事件只对玩家有用，但电脑也可以触发（只是没有效果）\n                    if (triggeredBy === 'player') {\n                        computer.speedMultiplier = Math.max(computer.speedMultiplier * 0.8, 0.1);\n                    }\n                    break;\n                    \n                case 'SPEED_VARIATION':\n                    globalEffects.speedVariation.active = true;\n                    globalEffects.speedVariation.endTime = Math.max(\n                        globalEffects.speedVariation.endTime, \n                        currentTime + 15000\n                    );\n                    break;\n                    \n                case 'OBSTACLE_RUSH':\n                    if (!globalEffects.obstacleSpeedUp.active) {\n                        globalEffects.obstacleSpeedUp.originalInterval = nextObstacleTime - gameTime;\n                    }\n                    globalEffects.obstacleSpeedUp.active = true;\n                    globalEffects.obstacleSpeedUp.endTime = Math.max(\n                        globalEffects.obstacleSpeedUp.endTime,\n                        currentTime + 30000\n                    );\n                    break;\n                    \n                case 'SPEED_RESET':\n                    ball.speed = 4;\n                    ball.speedMultiplier = 1.0;\n                    break;\n                    \n                case 'THUNDER_CLOUD':\n                    globalEffects.thunderCloud.active = true;\n                    globalEffects.thunderCloud.endTime = Math.max(\n                        globalEffects.thunderCloud.endTime,\n                        currentTime + 30000\n                    );\n                    break;\n                    \n                case 'PADDLE_SHRINK':\n                    if (triggeredBy === 'player') {\n                        player.height = Math.max(player.height * 0.8, 40);\n                        player.glowEndTime = Math.max(player.glowEndTime, currentTime + 20000);\n                    } else {\n                        computer.height = Math.max(computer.height * 0.8, 40);\n                        computer.glowEndTime = Math.max(computer.glowEndTime, currentTime + 20000);\n                    }\n                    break;\n                    \n                case 'BALL_FADE':\n                    ball.alpha = Math.min(ball.alpha, 0.1);\n                    // 这里需要一个计时器来恢复透明度\n                    setTimeout(() => {\n                        ball.alpha = Math.min(ball.alpha + 0.9, 1.0);\n                    }, 15000);\n                    break;\n                    \n                // 新增事件处理\n                case 'IMMORTAL_TOTEM':\n                    // 不死图腾效果，不可叠加\n                    if (!globalEffects.immortalTotem.active) {\n                        globalEffects.immortalTotem.active = true;\n                        globalEffects.immortalTotem.endTime = currentTime + 45000; // 45秒\n                        globalEffects.immortalTotem.triggeredBy = triggeredBy;\n\n                        // 为触发方添加RGB变色效果\n                        if (triggeredBy === 'player') {\n                            player.rgbEffect = true; // 使用rgbEffect而不是glowEffect\n                            player.rgbEndTime = currentTime + 45000;\n                        } else {\n                            computer.rgbEffect = true; // 使用rgbEffect而不是glowEffect\n                            computer.rgbEndTime = currentTime + 45000;\n                        }\n                    }\n                    break;\n\n                case 'EVENT_FRENZY':\n                    // 事件狂潮效果，不可叠加\n                    if (!globalEffects.eventFrenzy.active) {\n                        globalEffects.eventFrenzy.active = true;\n                        globalEffects.eventFrenzy.endTime = currentTime + 30000; // 30秒\n                        globalEffects.eventFrenzy.originalEventInterval = nextEventTime - gameTime;\n                    }\n                    break;\n                    \n                case 'HEAVEN_MAKER':\n                    // 天堂制造效果，可叠加\n                    if (!globalEffects.heavenMaker.active) {\n                        globalEffects.heavenMaker.active = true;\n                        globalEffects.heavenMaker.endTime = currentTime + 25000; // 25秒\n                        globalEffects.heavenMaker.stackCount = 1;\n                    } else {\n                        // 叠加效果，延长时间并增加叠加次数\n                        globalEffects.heavenMaker.endTime = Math.max(globalEffects.heavenMaker.endTime, currentTime + 25000);\n                        globalEffects.heavenMaker.stackCount++;\n                    }\n                    // 应用效果：球变小，速度变快\n                    ball.radius = Math.max(ball.radius * 0.5, 3); // 最小半径3像素\n                    ball.speedMultiplier *= 1.25;\n                    break;\n                    \n                case 'HEAVY_BALL':\n                    // 沉重效果，可叠加\n                    if (!globalEffects.heavyBall.active) {\n                        globalEffects.heavyBall.active = true;\n                        globalEffects.heavyBall.endTime = currentTime + 25000; // 25秒\n                        globalEffects.heavyBall.stackCount = 1;\n                    } else {\n                        // 叠加效果，延长时间并增加叠加次数\n                        globalEffects.heavyBall.endTime = Math.max(globalEffects.heavyBall.endTime, currentTime + 25000);\n                        globalEffects.heavyBall.stackCount++;\n                    }\n                    // 应用效果：球变大，速度变慢\n                    ball.radius = Math.min(ball.radius * 2, 50); // 最大半径50像素\n                    ball.speedMultiplier *= 0.8;\n                    break;\n            }\n            \n            // 创建事件触发粒子效果\n            createParticles(eventObj.x, eventObj.y, eventObj.typeData.color, 25);\n        }\n\n        // 创建障碍物\n        function createObstacles() {\n            // 确保障碍物在中间75%区域生成\n            const minX = canvas.width * 0.125; // 12.5% 左边距\n            const maxX = canvas.width * 0.875; // 87.5% 右边距\n            const minY = canvas.height * 0.125; // 12.5% 上边距\n            const maxY = canvas.height * 0.875; // 87.5% 下边距\n\n            // 随机位置\n            const x = minX + Math.random() * (maxX - minX);\n            const y = minY + Math.random() * (maxY - minY);\n\n            // 随机大小 (20-40像素)\n            const size = 20 + Math.random() * 20;\n\n            // 随机形状 (圆形或方形)\n            const type = Math.random() > 0.5 ? 'circle' : 'rect';\n\n            // 随机存在时间 (8-20秒)\n            const duration = 8000 + Math.random() * 12000;\n\n            // 预警时间 (1秒)\n            const warningTime = 1000;\n\n            // 随机选择对称模式 (1, 2, 3, 5, 9, 0, 4, 0个障碍物)\n            const symmetryMode = Math.floor(Math.random() * 8); // 0-7\n\n            // 障碍物位置数组\n            const positions = [];\n\n            // 中心点\n            const centerX = canvas.width / 2;\n            const centerY = canvas.height / 2;\n\n            // 根据对称模式生成障碍物位置（放射性轴对称）\n            switch (symmetryMode) {\n                case 0: // 1个障碍物（中心）\n                    positions.push({x: centerX, y: centerY});\n                    break;\n\n                case 1: // 2个障碍物（放射性轴对称）\n                    positions.push({x: x, y: y});\n                    positions.push({x: 2 * centerX - x, y: 2 * centerY - y});\n                    break;\n\n                case 2: // 3个障碍物（放射性轴对称）\n                    positions.push({x: centerX, y: centerY});\n                    positions.push({x: x, y: y});\n                    positions.push({x: 2 * centerX - x, y: 2 * centerY - y});\n                    break;\n\n                case 3: // 5个障碍物（放射性轴对称）\n                    positions.push({x: centerX, y: centerY});\n                    positions.push({x: x, y: y});\n                    positions.push({x: 2 * centerX - x, y: 2 * centerY - y});\n                    positions.push({x: x, y: 2 * centerY - y});\n                    positions.push({x: 2 * centerX - x, y: y});\n                    break;\n\n                case 4: // 9个障碍物（放射性轴对称）\n                    positions.push({x: centerX, y: centerY});\n                    positions.push({x: x, y: y});\n                    positions.push({x: 2 * centerX - x, y: 2 * centerY - y});\n                    positions.push({x: x, y: 2 * centerY - y});\n                    positions.push({x: 2 * centerX - x, y: y});\n                    positions.push({x: centerX, y: 2 * centerY - y});\n                    positions.push({x: 2 * centerX - x, y: centerY});\n                    positions.push({x: x, y: centerY});\n                    positions.push({x: centerX, y: y});\n                    break;\n\n                case 5: // None\n                    break;\n\n                case 6: // 4个障碍物（补）\n                    positions.push({x: x, y: y});\n                    positions.push({x: 2 * centerX - x, y: 2 * centerY - y});\n                    positions.push({x: x, y: 2 * centerY - y});\n                    positions.push({x: 2 * centerX - x, y: y});\n                    break;\n\n                case 7: //None\n                    break;\n            }\n\n            // 创建障碍物\n            for (const pos of positions) {\n                obstacles.push({\n                    x: pos.x,\n                    y: pos.y,\n                    size: size,\n                    type: type,\n                    warningTime: warningTime,\n                    warningProgress: 0,\n                    duration: duration,\n                    active: false,\n                    spawnTime: Date.now()\n                });\n            }\n        }\n\n        // 更新障碍物状态\n        function updateObstacles() {\n            const now = Date.now();\n\n            for (let i = obstacles.length - 1; i >= 0; i--) {\n                const obs = obstacles[i];\n\n                // 更新预警进度\n                if (!obs.active) {\n                    const elapsed = now - obs.spawnTime;\n                    obs.warningProgress = Math.min(1, elapsed / obs.warningTime);\n\n                    // 如果预警时间结束，激活障碍物\n                    if (elapsed >= obs.warningTime) {\n                        obs.active = true;\n                        obs.activateTime = now;\n                    }\n                }\n\n                // 检查是否应该移除障碍物\n                if (obs.active && now - obs.activateTime >= obs.duration) {\n                    obstacles.splice(i, 1);\n                }\n            }\n        }\n\n        // 更新事件状态\n        function updateEvents() {\n            const now = Date.now();\n\n            for (let i = events.length - 1; i >= 0; i--) {\n                const event = events[i];\n                \n                // 更新脉冲动画\n                event.pulsePhase += 0.1;\n                \n                // 检查是否应该移除事件\n                if (now - event.spawnTime >= event.duration) {\n                    events.splice(i, 1);\n                }\n            }\n        }\n\n        // 更新全局效果\n        function updateGlobalEffects() {\n            const now = Date.now();\n            \n            // 速度变化效果\n            if (globalEffects.speedVariation.active) {\n                if (now > globalEffects.speedVariation.endTime) {\n                    globalEffects.speedVariation.active = false;\n                    ball.speedMultiplier = 1.0;\n                } else {\n                    // 在70%-130%之间变动\n                    ball.speedMultiplier = 0.7 + 0.6 * (0.5 + 0.5 * Math.sin(now * 0.01));\n                }\n            }\n            \n            // 障碍物加速效果\n            if (globalEffects.obstacleSpeedUp.active) {\n                if (now > globalEffects.obstacleSpeedUp.endTime) {\n                    globalEffects.obstacleSpeedUp.active = false;\n                }\n            }\n            \n            // 雷云效果\n            if (globalEffects.thunderCloud.active) {\n                if (now > globalEffects.thunderCloud.endTime) {\n                    globalEffects.thunderCloud.active = false;\n                } else {\n                    // 更新闪电时间\n                    if (now > globalEffects.thunderCloud.flashTime) {\n                        globalEffects.thunderCloud.flashTime = now + 1000 + Math.random() * 2000;\n                    }\n                }\n            }\n            \n            // 新增效果更新\n            // 不死图腾效果\n            if (globalEffects.immortalTotem.active) {\n                if (now > globalEffects.immortalTotem.endTime) {\n                    globalEffects.immortalTotem.active = false;\n                    globalEffects.immortalTotem.triggeredBy = null;\n                    \n                    // 结束RGB变色效果\n                    const triggeredBy = globalEffects.immortalTotem.triggeredBy;\n                    if (triggeredBy === 'player') {\n                        player.glowEffect = false;\n                        player.glowEndTime = 0;\n                    } else if (triggeredBy === 'computer') {\n                        computer.glowEffect = false;\n                        computer.glowEndTime = 0;\n                    }\n                }\n            }\n            \n            // 事件狂潮效果\n            if (globalEffects.eventFrenzy.active) {\n                if (now > globalEffects.eventFrenzy.endTime) {\n                    globalEffects.eventFrenzy.active = false;\n                }\n            }\n            \n            // 天堂制造效果\n            if (globalEffects.heavenMaker.active) {\n                if (now > globalEffects.heavenMaker.endTime) {\n                    // 恢复球的大小和速度\n                    for (let i = 0; i < globalEffects.heavenMaker.stackCount; i++) {\n                        ball.radius = Math.min(ball.radius * 2, 50); // 恢复大小\n                        ball.speedMultiplier /= 1.25; // 恢复速度\n                    }\n                    globalEffects.heavenMaker.active = false;\n                    globalEffects.heavenMaker.stackCount = 0;\n                }\n            }\n            \n            // 沉重效果\n            if (globalEffects.heavyBall.active) {\n                if (now > globalEffects.heavyBall.endTime) {\n                    // 恢复球的大小和速度\n                    for (let i = 0; i < globalEffects.heavyBall.stackCount; i++) {\n                        ball.radius = Math.max(ball.radius * 0.5, 3); // 恢复大小\n                        ball.speedMultiplier /= 0.8; // 恢复速度\n                    }\n                    globalEffects.heavyBall.active = false;\n                    globalEffects.heavyBall.stackCount = 0;\n                }\n            }\n            \n            // 更新挡板效果\n            if (now > player.glowEndTime) {\n                player.glowEffect = false;\n                if (player.height !== player.originalHeight) {\n                    player.height = player.originalHeight;\n                }\n            }\n            \n            if (now > computer.glowEndTime) {\n                computer.glowEffect = false;\n                if (computer.height !== computer.originalHeight) {\n                    computer.height = computer.originalHeight;\n                }\n            }\n\n            // 添加rgb效果更新\n            if (now > player.rgbEndTime) {\n                player.rgbEffect = false;\n            }\n\n            if (now > computer.rgbEndTime) {\n                computer.rgbEffect = false;\n            }\n        }\n\n        // 绘制圆形（用于球和粒子）\n        function drawCircle(x, y, radius, color, alpha = 1.0) {\n            ctx.save();\n            ctx.globalAlpha = alpha;\n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n\n            // 添加发光效果\n            const gradient = ctx.createRadialGradient(\n                x, y, 0,\n                x, y, radius\n            );\n            gradient.addColorStop(0, color);\n            gradient.addColorStop(1, 'rgba(101, 80, 255, 0)');\n\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.closePath();\n            ctx.restore();\n        }\n\n        // 绘制挡板\n        function drawPaddle(x, y, width, height, color, glowEffect = false, rgbEffect = false) {\n            if (rgbEffect) {\n                // 使用RGB效果绘制挡板\n                drawPaddleRGB(x, y, width, height);\n                return;\n            }\n\n            ctx.save();\n            \n            // 如果有发光效果，先绘制发光\n            if (glowEffect) {\n                ctx.shadowColor = '#ffff00';\n                ctx.shadowBlur = 20;\n                ctx.shadowOffsetX = 0;\n                ctx.shadowOffsetY = 0;\n            }\n            \n            ctx.beginPath();\n            ctx.rect(x, y, width, height);\n\n            // 创建渐变效果\n            const gradient = ctx.createLinearGradient(x, y, x + width, y);\n            gradient.addColorStop(0, color);\n            gradient.addColorStop(1, glowEffect ? '#ffff88' : '#a0a8ff');\n\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.closePath();\n\n            // 添加边框发光\n            ctx.beginPath();\n            ctx.rect(x - 2, y - 2, width + 4, height + 4);\n            ctx.strokeStyle = glowEffect ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 255, 255, 0.3)';\n            ctx.lineWidth = glowEffect ? 2 : 1;\n            ctx.stroke();\n            ctx.closePath();\n            \n            ctx.restore();\n        }\n\n        // 绘制RGB挡板效果\n        function drawPaddleRGB(x, y, width, height) {\n            ctx.save();\n\n            // 创建随时间变化的RGB效果\n            const hue = (Date.now() / 5) % 360;\n            const color1 = `hsl(${hue}, 100%, 60%)`;\n            const color2 = `hsl(${(hue + 120) % 360}, 100%, 60%)`;\n            const color3 = `hsl(${(hue + 240) % 360}, 100%, 60%)`;\n\n            // 创建三色渐变\n            const gradient = ctx.createLinearGradient(x, y, x + width, y + height);\n            gradient.addColorStop(0, color1);\n            gradient.addColorStop(0.5, color2);\n            gradient.addColorStop(1, color3);\n\n            // 绘制挡板主体\n            ctx.fillStyle = gradient;\n            ctx.fillRect(x, y, width, height);\n\n            // 添加发光边框\n            ctx.strokeStyle = '#ffffff';\n            ctx.lineWidth = 2;\n            ctx.shadowColor = '#ffffff';\n            ctx.shadowBlur = 15;\n            ctx.strokeRect(x - 2, y - 2, width + 4, height + 4);\n\n            ctx.restore();\n        }\n\n        // 绘制球轨迹\n        function drawBallTrail() {\n            for (let i = 0; i < ball.trail.length; i++) {\n                const alpha = (i / ball.trail.length) * ball.alpha;\n                const radius = ball.radius * alpha;\n\n                ctx.save();\n                ctx.globalAlpha = alpha * 0.6;\n                ctx.beginPath();\n                ctx.arc(ball.trail[i].x, ball.trail[i].y, radius, 0, Math.PI * 2);\n                ctx.fillStyle = ball.color;\n                ctx.fill();\n                ctx.closePath();\n                ctx.restore();\n            }\n        }\n\n        // 绘制网格背景\n        function drawGrid() {\n            const gridSize = 30;\n            ctx.strokeStyle = 'rgba(101, 80, 255, 0.1)';\n            ctx.lineWidth = 1;\n\n            // 垂直线\n            for (let x = 0; x < canvas.width; x += gridSize) {\n                ctx.beginPath();\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, canvas.height);\n                ctx.stroke();\n            }\n\n            // 水平线\n            for (let y = 0; y < canvas.height; y += gridSize) {\n                ctx.beginPath();\n                ctx.moveTo(0, y);\n                ctx.lineTo(canvas.width, y);\n                ctx.stroke();\n            }\n        }\n\n        // 绘制粒子\n        function drawParticles() {\n            for (let i = 0; i < particles.length; i++) {\n                const p = particles[i];\n\n                // 更新粒子位置\n                p.x += Math.cos(p.angle) * p.speed;\n                p.y += Math.sin(p.angle) * p.speed;\n                p.life--;\n\n                // 绘制粒子\n                ctx.save();\n                ctx.globalAlpha = p.life / 30;\n                ctx.beginPath();\n                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);\n                ctx.fillStyle = p.color;\n                ctx.fill();\n                ctx.closePath();\n                ctx.restore();\n\n                // 移除死亡粒子\n                if (p.life  centerY + cloudHeight || stream.life  {\n                    ctx.fillText(char, stream.x, stream.y + i * 12);\n                });\n\n                ctx.restore();\n            });\n        }\n\n        function drawLightningBranches(centerX, centerY, cloudWidth, cloudHeight) {\n            ctx.globalAlpha = 0.6;\n\n            // 生成主闪电路径\n            const path = generateLightningPath(\n                centerX + (Math.random() - 0.5) * cloudWidth * 0.5,\n                centerY - cloudHeight * 0.4,\n                centerX + (Math.random() - 0.5) * cloudWidth * 0.5,\n                centerY + cloudHeight * 0.4\n            );\n\n            // 绘制主闪电\n            drawLightning(path, 3);\n\n            // 生成分支闪电（1-3个）\n            const branchCount = 1 + Math.floor(Math.random() * 3);\n            for (let i = 0; i < branchCount; i++) {\n                const branchPoint = path[Math.floor(path.length * (i + 1) / (branchCount + 1))];\n                const branchPath = generateLightningPath(\n                    branchPoint.x,\n                    branchPoint.y,\n                    branchPoint.x + (Math.random() - 0.5) * cloudWidth * 0.3,\n                    branchPoint.y + cloudHeight * 0.2\n                );\n                drawLightning(branchPath, 2);\n            }\n        }\n\n        function generateLightningPath(startX, startY, endX, endY) {\n            const segments = 8;\n            const path = [{x: startX, y: startY}];\n            const variance = canvas.width * 0.05;\n\n            for (let i = 1; i  0.5 ? '1' : '0').join('');\n        }\n\n        // 重置球位置\n        function resetBall() {\n            // 保存原始速度方向\n            const originalVelocityX = ball.velocityX;\n            const originalVelocityY = ball.velocityY;\n\n            // 重置球位置和速度\n            ball.x = canvas.width / 2;\n            ball.y = canvas.height / 2;\n            ball.speed = 4;\n            ball.velocityX = Math.random() > 0.5 ? 5 : -5;\n            ball.velocityY = Math.random() * 4 - 2;\n            ball.trail = [];\n            isResetting = false;\n\n            // 重置死球检测\n            ballStuckDetection.lastY = ball.y;\n            ballStuckDetection.stuckTime = 0;\n            ballStuckDetection.lastCheckTime = Date.now();\n\n            // 防止球在障碍物上重生\n            let safePositionFound = false;\n            let attempts = 0;\n            const maxAttempts = 30;\n            const safeRadius = ball.radius * 2; // 安全距离半径\n\n            while (!safePositionFound && attempts < maxAttempts) {\n                // 方法1：尝试在中心附近随机位置生成\n                if (attempts < 20) {\n                    ball.x = canvas.width / 2 + (Math.random() - 0.5) * (canvas.width / 4);\n                    ball.y = canvas.height / 2 + (Math.random() - 0.5) * (canvas.height / 4);\n                }\n                // 方法2：向量叠加调整（前20次失败后启用）\n                else {\n                    let totalDx = 0;\n                    let totalDy = 0;\n                    let collisionCount = 0;\n\n                    for (const obs of obstacles) {\n                        if (obs.active && obstacleCollision(ball, obs)) {\n                            const dx = ball.x - obs.x;\n                            const dy = ball.y - obs.y;\n                            const distance = Math.sqrt(dx * dx + dy * dy);\n                            const minDistance = ball.radius + obs.size + safeRadius;\n\n                            if (distance < minDistance) {\n                                const angle = Math.atan2(dy, dx);\n                                const moveDistance = minDistance - distance;\n                                totalDx += moveDistance * Math.cos(angle);\n                                totalDy += moveDistance * Math.sin(angle);\n                                collisionCount++;\n                            }\n                        }\n                    }\n\n                    if (collisionCount > 0) {\n                        // 标准化总位移向量\n                        const totalMove = Math.sqrt(totalDx * totalDx + totalDy * totalDy);\n                        ball.x += (totalDx / collisionCount) * 1.2;\n                        ball.y += (totalDy / collisionCount) * 1.2;\n                    }\n                }\n\n                // 边界检查\n                ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));\n                ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));\n\n                // 最终碰撞检查\n                safePositionFound = true;\n                for (const obs of obstacles) {\n                    if (obs.active && obstacleCollision(ball, obs)) {\n                        safePositionFound = false;\n                        break;\n                    }\n                }\n\n                attempts++;\n            }\n        }\n\n        // 碰撞检测 - 挡板\n        function collision(b, p) {\n            return (\n                b.x + b.radius > p.x &&\n                b.x - b.radius < p.x + p.width &&\n                b.y + b.radius > p.y &&\n                b.y - b.radius < p.y + p.height\n            );\n        }\n\n        // 碰撞检测 - 障碍物\n        function obstacleCollision(ball, obstacle) {\n            if (!obstacle.active) return false;\n\n            if (obstacle.type === 'circle') {\n                // 圆形障碍物碰撞检测\n                const dx = ball.x - obstacle.x;\n                const dy = ball.y - obstacle.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n\n                return distance < ball.radius + obstacle.size;\n            } else {\n                // 矩形障碍物碰撞检测\n                const halfSize = obstacle.size / 2;\n                const closestX = Math.max(obstacle.x - halfSize, Math.min(ball.x, obstacle.x + halfSize));\n                const closestY = Math.max(obstacle.y - halfSize, Math.min(ball.y, obstacle.y + halfSize));\n\n                const dx = ball.x - closestX;\n                const dy = ball.y - closestY;\n\n                return (dx * dx + dy * dy) < (ball.radius * ball.radius);\n            }\n        }\n\n        // 碰撞检测 - 事件\n        function eventCollision(ball, event) {\n            const dx = ball.x - event.x;\n            const dy = ball.y - event.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            return distance < ball.radius + event.radius;\n        }\n\n        // 处理球与障碍物的碰撞\n        function handleObstacleCollision() {\n            for (const obs of obstacles) {\n                if (obstacleCollision(ball, obs)) {\n                    // 创建碰撞粒子\n                    createParticles(ball.x, ball.y, '#ff6666', 30);\n\n                    if (obs.type === 'circle') {\n                        // 圆形障碍物碰撞反弹\n                        const dx = ball.x - obs.x;\n                        const dy = ball.y - obs.y;\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n\n                        // 法线向量\n                        const nx = dx / distance;\n                        const ny = dy / distance;\n\n                        // 计算点积\n                        const dot = ball.velocityX * nx + ball.velocityY * ny;\n\n                        // 反射向量\n                        ball.velocityX = ball.velocityX - 2 * dot * nx;\n                        ball.velocityY = ball.velocityY - 2 * dot * ny;\n                    } else {\n                        // 矩形障碍物碰撞反弹\n                        const halfSize = obs.size / 2;\n\n                        // 计算球相对于障碍物中心的向量\n                        const dx = ball.x - obs.x;\n                        const dy = ball.y - obs.y;\n\n                        // 判断碰撞发生在矩形的哪一侧\n                        if (Math.abs(dx) > Math.abs(dy)) {\n                            // 水平碰撞\n                            ball.velocityX = -ball.velocityX;\n\n                            // 调整位置防止卡住\n                            if (dx > 0) {\n                                ball.x = obs.x + halfSize + ball.radius;\n                            } else {\n                                ball.x = obs.x - halfSize - ball.radius;\n                            }\n                        } else {\n                            // 垂直碰撞\n                            ball.velocityY = -ball.velocityY;\n\n                            // 调整位置防止卡住\n                            if (dy > 0) {\n                                ball.y = obs.y + halfSize + ball.radius;\n                            } else {\n                                ball.y = obs.y - halfSize - ball.radius;\n                            }\n                        }\n                    }\n\n                    // 增加球速\n                    ball.speed += 0.025;\n\n                    // 记录碰撞时间\n                    ball.lastCollision = Date.now();\n\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // 处理球与事件的碰撞\n        function handleEventCollision() {\n            for (let i = events.length - 1; i >= 0; i--) {\n                const event = events[i];\n                if (eventCollision(ball, event)) {\n                    // 触发事件效果\n                    if (lastTouchedBy) {\n                        triggerEvent(event, lastTouchedBy);\n                    }\n                    \n                    // 移除事件\n                    events.splice(i, 1);\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // 处理雷云对球的影响\n        function handleThunderCloudEffect() {\n            if (!globalEffects.thunderCloud.active) return;\n            \n            const centerX = canvas.width / 2;\n            const centerY = canvas.height / 2;\n            const cloudWidth = canvas.width * 0.3;\n            const cloudHeight = canvas.height * 0.3;\n            \n            // 检查球是否在雷云区域内\n            if (ball.x > centerX - cloudWidth / 2 && \n                ball.x < centerX + cloudWidth / 2 &&\n                ball.y > centerY - cloudHeight / 2 && \n                ball.y < centerY + cloudHeight / 2) {\n                \n                // 随机改变球的角度 -10到10度\n                const angleChange = (Math.random() - 0.5) * 20 * Math.PI / 180;\n                const currentAngle = Math.atan2(ball.velocityY, ball.velocityX);\n                const newAngle = currentAngle + angleChange;\n                const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);\n                \n                ball.velocityX = speed * Math.cos(newAngle);\n                ball.velocityY = speed * Math.sin(newAngle);\n                \n                // 触发闪电效果\n                globalEffects.thunderCloud.flashTime = Date.now() + 200;\n            }\n        }\n\n        // 检查球是否卡在障碍物中，如果是则校正位置\n        function correctBallPosition() {\n            for (const obs of obstacles) {\n                if (!obs.active) continue;\n\n                // 计算球与障碍物的距离和方向\n                const dx = ball.x - obs.x;\n                const dy = ball.y - obs.y;\n\n                if (obs.type === 'circle') {\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    const minDistance = ball.radius + obs.size;\n\n                    if (distance < minDistance) {\n                        // 计算需要移动的方向\n                        const angle = Math.atan2(dy, dx);\n                        const moveDistance = minDistance - distance;\n\n                        // 将球移动到障碍物边缘\n                        ball.x += Math.cos(angle) * moveDistance;\n                        ball.y += Math.sin(angle) * moveDistance;\n                    }\n                } else {\n                    // 矩形障碍物处理\n                    const halfSize = obs.size / 2;\n                    const overlapX = Math.abs(dx) - (ball.radius + halfSize);\n                    const overlapY = Math.abs(dy) - (ball.radius + halfSize);\n\n                    if (overlapX < 0 && overlapY < 0) {\n                        // 确定最小重叠方向\n                        if (Math.abs(overlapX) < Math.abs(overlapY)) {\n                            // X轴方向重叠较小，沿X轴移动\n                            ball.x += dx > 0 ? -overlapX : overlapX;\n                        } else {\n                            // Y轴方向重叠较小，沿Y轴移动\n                            ball.y += dy > 0 ? -overlapY : overlapY;\n                        }\n                    }\n                }\n            }\n        }\n\n        // 更新游戏状态\n        function update(dt) {\n            if (isGameOver || isPaused) return; // 添加暂停检查\n\n            // 更新游戏时间（每帧约16ms）\n            gameTime += dt;\n\n            // 死球检测\n            if (checkDeadBall()) {\n                showDeadBallNotification();\n                resetBall();\n                // 重置球但不计分\n                return;\n            }\n\n            // 检查是否需要生成新障碍物\n            let obstacleInterval = 15000; // 默认15秒\n            if (globalEffects.obstacleSpeedUp.active) {\n                obstacleInterval *= 0.2; // 减少到20%\n            }\n\n            if (gameTime >= nextObstacleTime) {\n                createObstacles();\n                nextObstacleTime = gameTime + obstacleInterval + Math.random() * 5000;\n            }\n\n            // 检查是否需要生成新事件\n            if (gameTime >= nextEventTime) {\n                createEvent();\n                // 设置下一次事件出现时间：5-30秒后\n                let eventInterval = 5000 + Math.random() * 25000;\n\n                // 事件狂潮效果：事件刷新率增加为400%\n                if (globalEffects.eventFrenzy.active) {\n                    eventInterval *= 0.25; // 减少到25%，即400%的刷新率\n                }\n\n                nextEventTime = gameTime + eventInterval;\n            }\n\n            // 更新各种状态\n            updateObstacles();\n            updateEvents();\n            updateGlobalEffects();\n\n            // 检查并校正球的位置，防止卡在障碍物中\n            correctBallPosition();\n\n            // 更新球轨迹\n            ball.trail.push({x: ball.x, y: ball.y});\n            if (ball.trail.length > 10) {\n                ball.trail.shift();\n            }\n\n            // 移动球\n            const effectiveSpeed = ball.speed * ball.speedMultiplier;\n            const velocityMagnitude = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);\n            ball.x += (ball.velocityX / velocityMagnitude) * effectiveSpeed * (dt / FRAME_INTERVAL);\n            ball.y += (ball.velocityY / velocityMagnitude) * effectiveSpeed * (dt / FRAME_INTERVAL);\n\n            // 简单的电脑AI - 跟随球移动\n            const effectiveComputerSpeed = computer.speed * computer.speedMultiplier;\n            if (computer.y + (computer.height / 2) < ball.y) {\n                computer.y += effectiveComputerSpeed;\n            } else {\n                computer.y -= effectiveComputerSpeed;\n            }\n\n            // 确保电脑挡板不会超出边界\n            if (computer.y < 0) {\n                computer.y = 0;\n            } else if (computer.y + computer.height > canvas.height) {\n                computer.y = canvas.height - computer.height;\n            }\n\n            // 确保玩家挡板不会超出边界\n            if (player.y < 0) {\n                player.y = 0;\n            } else if (player.y + player.height > canvas.height) {\n                player.y = canvas.height - player.height;\n            }\n\n            // 上下边界反弹\n            if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {\n                ball.velocityY = -ball.velocityY;\n\n                // 边界碰撞粒子效果\n                createParticles(\n                    ball.x,\n                    ball.y < ball.radius ? 0 : canvas.height,\n                    '#ffffff'\n                );\n            }\n\n            // 处理雷云效果\n            handleThunderCloudEffect();\n\n            // 处理球与事件的碰撞\n            const hitEvent = handleEventCollision();\n\n            // 处理球与障碍物的碰撞\n            const hitObstacle = handleObstacleCollision();\n\n            // 如果没有碰到障碍物或事件，检查挡板碰撞\n            if (!hitObstacle && !hitEvent) {\n                // 确定球与哪个挡板碰撞\n                const paddle = ball.x < canvas.width / 2 ? player : computer;\n                const paddleOwner = ball.x < canvas.width / 2 ? 'player' : 'computer';\n                const currentTime = Date.now();\n\n                // 添加防卡顿机制：同一挡板在50ms内只允许碰撞一次\n                if (collision(ball, paddle) && currentTime - ball.lastCollision > 50) {\n                    // 记录触球者\n                    lastTouchedBy = paddleOwner;\n\n                    // 球击中挡板的位置（从-0.5到0.5）\n                    const hitPoint = (ball.y - (paddle.y + paddle.height / 2)) / (paddle.height / 2);\n\n                    // 计算反弹角度（基于击中位置）\n                    let angle = hitPoint * (Math.PI / 4);\n\n                    // 电脑回球增强功能\n                    if (aiEnhancementEnabled && paddleOwner === 'computer') {\n                        // 生成-75到75度的随机角度\n                        const randomAngle = (Math.random() - 0.5) * (120 * Math.PI / 180); // -60到60度转换为弧度\n                        angle = randomAngle;\n                    }\n\n                    // 确定方向\n                    const direction = ball.x < canvas.width / 2 ? 1 : -1;\n\n                    // 更新球的速度\n                    ball.velocityX = direction * ball.speed * Math.cos(angle);\n                    ball.velocityY = ball.speed * Math.sin(angle);\n\n                    // 增加球速\n                    ball.speed += 0.025;\n\n                    // 雷电板子效果\n                    if (paddle.glowEffect) {\n                        ball.speed *= 1.8; // 增加80%速度\n                        setTimeout(() => {\n                            ball.speed /= 1.8; // 0.8秒后恢复\n                        }, 800);\n                    }\n\n                    // 创建碰撞粒子\n                    createParticles(ball.x, ball.y, paddle.color);\n\n                    // 记录碰撞时间\n                    ball.lastCollision = currentTime;\n\n                    // 防止球卡在挡板内\n                    if (direction === 1) {\n                        ball.x = paddle.x + paddle.width + ball.radius + 1;\n                    } else {\n                        ball.x = paddle.x - ball.radius - 1;\n                    }\n                }\n            }\n\n            // 计分\n            if (!isResetting && (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width)) {\n                isResetting = true;\n                let shouldScore = true;\n                let scoringPlayer = null;\n\n                if (ball.x - ball.radius < 0) {\n                    scoringPlayer = 'computer';\n                } else {\n                    scoringPlayer = 'player';\n                }\n\n                // 检查不死图腾效果\n                if (globalEffects.immortalTotem.active) {\n                    const triggeredBy = globalEffects.immortalTotem.triggeredBy;\n\n                    // 如果触发方失球，不计分但结束不死图腾效果\n                    if ((scoringPlayer === 'computer' && triggeredBy === 'player') ||\n                        (scoringPlayer === 'player' && triggeredBy === 'computer')) {\n                        shouldScore = false;\n\n                        // 结束不死图腾效果\n                        globalEffects.immortalTotem.active = false;\n                        globalEffects.immortalTotem.endTime = 0;\n                        globalEffects.immortalTotem.triggeredBy = null;\n\n                        // 结束触发方的RGB变色效果\n                        if (triggeredBy === 'player') {\n                            player.rgbEffect = false; // 使用rgbEffect\n                            player.rgbEndTime = 0;\n                        } else {\n                            computer.rgbEffect = false; // 使用rgbEffect\n                            computer.rgbEndTime = 0;\n                        }\n\n                        // 显示不死图腾触发通知\n                        const notification = document.createElement('div');\n                        notification.className = 'event-notification positive';\n                        notification.innerHTML = `\n                            不死图腾触发\n                            是不死图腾碎裂的声音！\n                            本次失球不计分，效果已结束\n                        `;\n                        document.body.appendChild(notification);\n                        setTimeout(() => {\n                            notification.classList.add('show');\n                        }, 100);\n                        setTimeout(() => {\n                            notification.classList.remove('show');\n                            setTimeout(() => {\n                                if (notification.parentNode) {\n                                    notification.remove();\n                                }\n                            }, 500);\n                        }, 3000);\n                    }\n                }\n\n                // 正常计分\n                if (shouldScore) {\n                    if (scoringPlayer === 'computer') {\n                        computerScore++;\n                        computerScoreElement.textContent = computerScore;\n                        createScoreEffect(false); // 电脑得分特效\n                    } else {\n                        playerScore++;\n                        playerScoreElement.textContent = playerScore;\n                        createScoreEffect(true); // 玩家得分特效\n                    }\n                }\n\n                // 重置电脑速度倍数（进球后重置）\n                computer.speedMultiplier = 1.0;\n\n                // 创建得分粒子效果\n                createParticles(\n                    ball.x,\n                    ball.y,\n                    ball.x - ball.radius < 0 ? computer.color : player.color,\n                    30\n                );\n\n                // 延迟后重置球\n                setTimeout(() => {\n                    resetBall();\n                }, 1000);\n            }\n\n            // 检查胜利条件\n            if (!isGameOver && (playerScore >= 3 || computerScore >= 3)) {\n                isGameOver = true;\n                if (playerScore >= 3) {\n                    victoryMessage.textContent = `玩家获胜！`;\n                } else {\n                    // 获取当前选中的难度名称\n                    const activeOption = document.querySelector('.difficulty-option.active');\n                    const difficultyName = activeOption ? activeOption.textContent : '电脑';\n                    victoryMessage.textContent = `${difficultyName}获胜！`;\n                }\n                victoryOverlay.style.opacity = '1';\n                victoryOverlay.style.pointerEvents = 'auto';\n            }\n\n            // 更新调试信息\n            updateDebugInfo();\n        }\n\n        // 绘制游戏\n        function draw() {\n            // 半透明背景（创造拖尾效果）\n            ctx.fillStyle = 'rgba(8, 12, 33, 0.15)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            // 绘制网格背景\n            drawGrid();\n\n            // 绘制雷云效果\n            drawThunderCloud();\n\n            // 绘制障碍物\n            drawObstacles();\n\n            // 绘制事件\n            drawEvents();\n\n            // 绘制球轨迹\n            drawBallTrail();\n\n            // 绘制粒子\n            drawParticles();\n\n            // 绘制中间虚线\n            ctx.beginPath();\n            ctx.setLineDash([10, 15]);\n            ctx.moveTo(canvas.width / 2, 0);\n            ctx.lineTo(canvas.width / 2, canvas.height);\n            ctx.strokeStyle = 'rgba(101, 80, 255, 0.4)';\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            ctx.setLineDash([]);\n\n            // 绘制挡板\n            drawPaddle(player.x, player.y, player.width, player.height, player.color, player.glowEffect, player.rgbEffect);\n            drawPaddle(computer.x, computer.y, computer.width, computer.height, computer.color, computer.glowEffect, computer.rgbEffect);\n\n\n            // 绘制球\n            drawCircle(ball.x, ball.y, ball.radius, ball.color, ball.alpha);\n\n            // 绘制球内部光点\n            ctx.save();\n            ctx.globalAlpha = ball.alpha;\n            ctx.beginPath();\n            ctx.arc(ball.x - 3, ball.y - 3, 4, 0, Math.PI * 2);\n            ctx.fillStyle = '#ffffff';\n            ctx.fill();\n            ctx.closePath();\n            ctx.restore();\n        }\n\n        // 更新调试信息\n        function updateDebugInfo() {\n            // 球状态\n            document.getElementById('debug-ball-speed').textContent = ball.speed.toFixed(2);\n            document.getElementById('debug-ball-position').textContent = `${Math.round(ball.x)},${Math.round(ball.y)}`;\n            document.getElementById('debug-ball-alpha').textContent = ball.alpha.toFixed(2);\n\n            // 电脑数据\n            document.getElementById('debug-computer-speed').textContent = computer.speed.toFixed(2);\n            document.getElementById('debug-computer-position').textContent = Math.round(computer.y);\n            document.getElementById('debug-computer-multiplier').textContent = computer.speedMultiplier.toFixed(2);\n\n            // 事件状态\n            let activeEvents = 0;\n            if (globalEffects.speedVariation.active) activeEvents++;\n            if (globalEffects.obstacleSpeedUp.active) activeEvents++;\n            if (globalEffects.thunderCloud.active) activeEvents++;\n            if (player.glowEffect) activeEvents++;\n            if (computer.speedMultiplier !== 1.0) activeEvents++;\n            \n            document.getElementById('debug-active-events').textContent = activeEvents;\n            document.getElementById('debug-obstacles').textContent = obstacles.length;\n\n            // 系统信息\n            const currentFps = Math.round(1000 / (deltaTime || 16.67));\n            document.getElementById('debug-fps').textContent = currentFps;\n            document.getElementById('debug-game-time').textContent = `${Math.round(gameTime / 1000)}s`;\n        }\n\n        // 游戏循环\n        function gameLoop(timestamp) {\n            // 计算时间差\n            if (lastTime === 0) lastTime = timestamp;\n            deltaTime = timestamp - lastTime;\n            lastTime = timestamp;\n            accumulatedTime += deltaTime;\n            \n            // 移动端性能优化：降低帧率\n            const targetFPS = isMobileDevice() ? 60 : 120;\n            const targetFrameInterval = 1000 / targetFPS;\n            \n            // 更新FPS计数\n            frameCount++;\n            if (timestamp - lastFpsUpdate >= 1000) {\n                const fps = Math.round(frameCount * 1000 / (timestamp - lastFpsUpdate));\n                console.log(`FPS: ${fps}`);\n                frameCount = 0;\n                lastFpsUpdate = timestamp;\n            }\n            \n            // 执行固定次数的更新（时间补偿）\n            while (accumulatedTime >= targetFrameInterval) {\n                update(targetFrameInterval);\n                accumulatedTime -= targetFrameInterval;\n            }\n            draw();\n            requestAnimationFrame(gameLoop);\n        }\n\n        // 启动游戏\n        lastTime = 0;\n        accumulatedTime = 0;\n        requestAnimationFrame(gameLoop);\n\n        // ====== 移动端触摸事件支持 ======\n        canvas.addEventListener('touchstart', handleTouch, {passive: false});\n        canvas.addEventListener('touchmove', handleTouch, {passive: false});\n        function handleTouch(e) {\n            if (isGameOver || isPaused) return;\n            e.preventDefault();\n            const rect = canvas.getBoundingClientRect();\n            let clientY;\n            if (e.touches && e.touches.length > 0) {\n                clientY = e.touches[0].clientY;\n            } else {\n                clientY = e.clientY;\n            }\n            player.y = clientY - rect.top - player.height / 2;\n            // 限制挡板不出界\n            if (player.y < 0) player.y = 0;\n            if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;\n        }\n\n        // ====== canvas自适应屏幕 ======\n        function resizeCanvas() {\n            let w, h;\n            \n            if (isMobileDevice()) {\n                // 移动端：使用屏幕宽度的95%，高度为屏幕高度的50%\n                w = window.innerWidth * 0.95;\n                h = window.innerHeight * 0.5;\n                // 限制最大尺寸\n                if (w > 600) w = 600;\n                if (h > 400) h = 400;\n            } else {\n                // 桌面端：使用原来的逻辑\n                w = window.innerWidth * 0.98;\n                h = window.innerHeight * 0.6;\n                if (w > 900) w = 900;\n                if (h > 600) h = 500;\n            }\n            \n            canvas.width = w;\n            canvas.height = h;\n            \n            // 重新设置挡板位置\n            player.x = 20;\n            player.y = canvas.height / 2 - player.height / 2;\n            computer.x = canvas.width - 35;\n            computer.y = canvas.height / 2 - computer.height / 2;\n            \n            // 重新设置球的位置\n            ball.x = canvas.width / 2;\n            ball.y = canvas.height / 2;\n            \n            // 限制挡板不出界\n            if (player.y < 0) player.y = 0;\n            if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;\n            if (computer.y < 0) computer.y = 0;\n            if (computer.y + computer.height > canvas.height) computer.y = canvas.height - computer.height;\n        }\n        window.addEventListener('resize', resizeCanvas);\n        resizeCanvas();\n\n        // ====== 移动端虚拟按钮支持 ======\n        const mobileControls = document.getElementById('mobile-controls');\n        const btnUp = document.getElementById('btn-up');\n        const btnDown = document.getElementById('btn-down');\n\n        // 检测是否为移动设备\n        function isMobileDevice() {\n            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || \n                   window.innerWidth  {\n                if (isGameOver || isPaused) return;\n                if (direction === 'up') {\n                    player.y -= moveSpeed;\n                    if (player.y < 0) player.y = 0;\n                } else {\n                    player.y += moveSpeed;\n                    if (player.y + player.height > canvas.height) {\n                        player.y = canvas.height - player.height;\n                    }\n                }\n            }, 16); // 约60fps\n        }\n\n        function stopMove() {\n            if (moveInterval) {\n                clearInterval(moveInterval);\n                moveInterval = null;\n            }\n        }\n\n        // 触摸事件\n        btnUp.addEventListener('touchstart', (e) => {\n            e.preventDefault();\n            startMove('up');\n        });\n\n        btnUp.addEventListener('touchend', (e) => {\n            e.preventDefault();\n            stopMove();\n        });\n\n        btnDown.addEventListener('touchstart', (e) => {\n            e.preventDefault();\n            startMove('down');\n        });\n\n        btnDown.addEventListener('touchend', (e) => {\n            e.preventDefault();\n            stopMove();\n        });\n\n        // 鼠标事件（用于桌面测试）\n        btnUp.addEventListener('mousedown', () => {\n            startMove('up');\n        });\n\n        btnUp.addEventListener('mouseup', () => {\n            stopMove();\n        });\n\n        btnDown.addEventListener('mousedown', () => {\n            startMove('down');\n        });\n\n        btnDown.addEventListener('mouseup', () => {\n            stopMove();\n        });\n\n        // 初始化移动端控制\n        toggleMobileControls();\n        window.addEventListener('resize', toggleMobileControls);\n\n        // 更新控制说明文字\n        function updateControlsInfo() {\n            const controlsInfo = document.querySelector('.controls-info');\n            if (isMobileDevice()) {\n                controlsInfo.textContent = '使用屏幕左侧按钮或触摸屏幕控制挡板 | 首先获得3分者获胜 | 收集事件获得特殊效果！';\n            } else {\n                controlsInfo.textContent = '使用鼠标移动控制你的挡板 | 首先获得3分者获胜 | 收集事件获得特殊效果！';\n            }\n        }\n        updateControlsInfo();\n    \n\n\n"},{"url":"/uma/index.html","content":"\n\n\n    \n        (function(c,l,a,r,i,t,y){\n            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};\n            t=l.createElement(r);t.async=1;t.src=\"https://www.clarity.ms/tag/\"+i;\n            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);\n        })(window, document, \"clarity\", \"script\", \"m7r9awlm9v\");\n    \n    \n    \n    Uma Card Maker\n    \n    \n    \n\n\n\n\n\n    \n        ..\n    \n    Uma Card Maker\n    \n        ..\n    \n\n\n\n赛马娘支援卡制作器\n\n\n\n\n\n\n    \n        \n            \n                \n            \n            \n                \n                \n                \n                \n            \n        \n    \n\n    \n        图片选择\n        图片缩放\n        \n            -\n            \n            +\n        \n        图片翻转\n        支援卡属性\n        \n            速度\n            耐力\n            力量\n            毅力\n            智力\n            友人\n            团队\n        \n        支援卡品级\n        \n            SSR\n            SR\n            R\n        \n        下载支援卡\n    \n\n\n\n    ?\n    \n    \n        \n            &times;\n            使用指南\n            \n                欢迎使用 赛马娘支援卡制作器 (Uma Card Maker) 喵~基本的功能如下：\n                \n                    可以上传图片并在支持卡上进行缩放、拖动、翻转等操作。\n                    可以选择支持卡的属性和品级，以及预览最终效果。\n                    右上角的是github repo链接哦~\n                \n            \n            使用指南：\n            \n                上传图片：点击 \"图片选择\" 按钮，选择你想要制作的支持卡的图片。支持的图片格式包括 JPG、PNG 等。\n                编辑支持卡：图片上传后，你可以在支持卡上进行缩放、拖动、翻转等操作。\n                选择支持卡属性和品级：使用下拉菜单选择支持卡的属性（速度、耐力、力量、毅力、智力、友人、团队）和品级（SSR、SR、R）。\n                预览和下载：在编辑完成后，你可以预览支持卡的最终效果，并点击 \"下载支援卡\" 按钮将支持卡保存到你的设备上。\n                GitHub 仓库链接：点击页面右上角的 GitHub 图标，访问应用程序的 GitHub 仓库，查看源代码并提出建议或报告问题。\n                需要帮助？：如果有什么bug的话，欢迎在github issues部分里面告诉我！\n            \n            \n                - Abyss Seeker\n            \n        \n    \n\n\n\n\n\n\n\n\n"},{"url":"/uma/package-lock.json","content":"{\"name\":\"UmaCardMaker\",\"lockfileVersion\":3,\"requires\":true,\"packages\":{\"\":{\"dependencies\":{\"html2canvas\":\"^1.4.1\"}},\"node_modules/base64-arraybuffer\":{\"version\":\"1.0.2\",\"resolved\":\"https://registry.npmjs.org/base64-arraybuffer/-/base64-arraybuffer-1.0.2.tgz\",\"integrity\":\"sha512-I3yl4r9QB5ZRY3XuJVEPfc2XhZO6YweFPI+UovAzn+8/hb3oJ6lnysaFcjVpkCPfVWFUDvoZ8kmVDP7WyRtYtQ==\",\"engines\":{\"node\":\">= 0.6.0\"}},\"node_modules/css-line-break\":{\"version\":\"2.1.0\",\"resolved\":\"https://registry.npmjs.org/css-line-break/-/css-line-break-2.1.0.tgz\",\"integrity\":\"sha512-FHcKFCZcAha3LwfVBhCQbW2nCNbkZXn7KVUJcsT5/P8YmfsVja0FMPJr0B903j/E69HUphKiV9iQArX8SDYA4w==\",\"dependencies\":{\"utrie\":\"^1.0.2\"}},\"node_modules/html2canvas\":{\"version\":\"1.4.1\",\"resolved\":\"https://registry.npmjs.org/html2canvas/-/html2canvas-1.4.1.tgz\",\"integrity\":\"sha512-fPU6BHNpsyIhr8yyMpTLLxAbkaK8ArIBcmZIRiBLiDhjeqvXolaEmDGmELFuX9I4xDcaKKcJl+TKZLqruBbmWA==\",\"dependencies\":{\"css-line-break\":\"^2.1.0\",\"text-segmentation\":\"^1.0.3\"},\"engines\":{\"node\":\">=8.0.0\"}},\"node_modules/text-segmentation\":{\"version\":\"1.0.3\",\"resolved\":\"https://registry.npmjs.org/text-segmentation/-/text-segmentation-1.0.3.tgz\",\"integrity\":\"sha512-iOiPUo/BGnZ6+54OsWxZidGCsdU8YbE4PSpdPinp7DeMtUJNJBoJ/ouUSTJjHkh1KntHaltHl/gDs2FC4i5+Nw==\",\"dependencies\":{\"utrie\":\"^1.0.2\"}},\"node_modules/utrie\":{\"version\":\"1.0.2\",\"resolved\":\"https://registry.npmjs.org/utrie/-/utrie-1.0.2.tgz\",\"integrity\":\"sha512-1MLa5ouZiOmQzUbjbu9VmjLzn1QLXBhwpUa7kdLUQK+KQ5KA9I1vk5U4YHe/X2Ch7PYnJfWuWT+VbuxbGwljhw==\",\"dependencies\":{\"base64-arraybuffer\":\"^1.0.2\"}}}}"},{"url":"/uma/script.js","content":"// script.js\ndocument.getElementById('uploadButton').addEventListener('click', function() {\n    const input = document.createElement('input');\n    input.type = 'file';\n    input.accept = 'image/*';\n    input.addEventListener('change', handleFileSelect);\n    input.click();\n});\n\nlet imgProps = {\n    offsetX: 0,\n    offsetY: 0,\n    scale: 1,\n    originalScale: 1 // 添加一个属性以存储原始缩放比例\n};\n\nlet img = null; // 用于存储当前图像的变量\nlet scaleInput = document.querySelector('.scale-input');\n\nwindow.onload = function() {\n    // 创建提示框元素\n    const alertBox = document.createElement('div');\n    alertBox.textContent = '！！！注意：如果你在使用微信/QQ等的内置浏览器，你可能无法下载图片！建议直接在浏览器中打开该网站。';\n    alertBox.classList.add('alert-box');\n    document.body.appendChild(alertBox);\n\n    // 在下一个动画帧中添加淡出效果\n    requestAnimationFrame(() => {\n        alertBox.style.opacity = '1'; // 淡入效果\n    });\n\n    // 设置定时器，在10秒后隐藏提示框\n    setTimeout(function() {\n        // 在下一个动画帧中添加淡出效果\n        requestAnimationFrame(() => {\n            alertBox.style.opacity = '0'; // 淡出效果\n        });\n        // 10秒后删除提示框\n        setTimeout(() => {\n            document.body.removeChild(alertBox);\n        }, 300);\n    }, 10000);\n};\n\n\nfunction handleFileSelect(event) {\n    const file = event.target.files[0];\n    if (file) {\n        const reader = new FileReader();\n        reader.onload = function(e) {\n            // 移除之前的图像\n            if (img) {\n                URL.revokeObjectURL(img.src);\n            }\n\n            img = new Image();\n            img.src = e.target.result;\n            img.onload = function() {\n                const canvas = document.getElementById('cardCanvas');\n                const ctx = canvas.getContext('2d');\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n                // 计算图像的宽高比\n                const aspectRatio = img.width / img.height;\n\n                // 确定是将图像的宽度还是高度适应到画布\n                if (img.width / canvas.width < img.height / canvas.height) {\n                    imgProps.scale = canvas.width / img.width;\n                } else {\n                    imgProps.scale = canvas.height / img.height;\n                }\n\n                // 设置原始缩放比例为当前缩放比例\n                imgProps.originalScale = imgProps.scale;\n\n                // 重置偏移量\n                imgProps.offsetX = 0;\n                imgProps.offsetY = 0;\n\n                // 更新输入框的值为初始缩放比例\n                scaleInput.value = (imgProps.scale * 100).toFixed(2);\n\n                // 在画布上绘制图像\n                redraw();\n            };\n        };\n        reader.readAsDataURL(file);\n    }\n}\n\n// 绘制圆角矩形的函数\nCanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {\n    this.beginPath();\n    this.moveTo(x + radius, y);\n    this.lineTo(x + width - radius, y);\n    this.quadraticCurveTo(x + width, y, x + width, y + radius);\n    this.lineTo(x + width, y + height - radius);\n    this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    this.lineTo(x + radius, y + height);\n    this.quadraticCurveTo(x, y + height, x, y + height - radius);\n    this.lineTo(x, y + radius);\n    this.quadraticCurveTo(x, y, x + radius, y);\n    this.closePath();\n};\n\n// 重绘图像的函数\nfunction redraw() {\n    const canvas = document.getElementById('cardCanvas');\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.roundRect(0, 0, canvas.width, canvas.height, 20); // 调整半径以适应您的需求\n    ctx.clip(); // 裁剪 canvas 到圆角矩形\n    ctx.drawImage(img, imgProps.offsetX, imgProps.offsetY, img.width * imgProps.scale, img.height * imgProps.scale);\n}\n\n// 限制偏移量，使图像保持在画布范围内\nfunction limitOffset() {\n    const canvas = document.getElementById('cardCanvas');\n    imgProps.offsetX = Math.min(0, Math.max(canvas.width - img.width * imgProps.scale, imgProps.offsetX));\n    imgProps.offsetY = Math.min(0, Math.max(canvas.height - img.height * imgProps.scale, imgProps.offsetY));\n}\n\n// 允许拖动\nlet isDragging = false;\nlet startX, startY;\nlet canvas = document.getElementById('cardCanvas');\n\n// 检测是否是移动设备\nfunction iOS() {\n  return [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod'\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document)\n}\n\nconst isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || iOS();\n\n// 添加事件监听器\nif (isMobile) {\n    // 如果是移动设备，使用触摸事件\n    canvas.addEventListener('touchstart', function(e) {\n        isDragging = true;\n        startX = e.touches[0].clientX - imgProps.offsetX;\n        startY = e.touches[0].clientY - imgProps.offsetY;\n        e.preventDefault(); // 阻止默认的滑动行为\n    });\n\n    canvas.addEventListener('touchmove', function(e) {\n        if (isDragging) {\n            imgProps.offsetX = e.touches[0].clientX - startX;\n            imgProps.offsetY = e.touches[0].clientY - startY;\n            limitOffset(); // 更新拖动后的偏移量\n            redraw(); // 重新绘制图像\n            e.preventDefault(); // 阻止默认的滑动行为\n        }\n    });\n\n    canvas.addEventListener('touchend', function() {\n        isDragging = false;\n    });\n\n} else {\n    // 如果是电脑设备，使用鼠标事件\n    canvas.addEventListener('mousedown', function(e) {\n        isDragging = true;\n        startX = e.clientX - imgProps.offsetX;\n        startY = e.clientY - imgProps.offsetY;\n    });\n\n    canvas.addEventListener('mousemove', function(e) {\n        if (isDragging) {\n            imgProps.offsetX = e.clientX - startX;\n            imgProps.offsetY = e.clientY - startY;\n            limitOffset(); // 更新拖动后的偏移量\n            redraw(); // 重新绘制图像\n        }\n    });\n\n    canvas.addEventListener('mouseup', function() {\n        isDragging = false;\n    });\n}\n\n// 添加事件监听器\nif (isMobile) {\n    // 如果是移动设备，使用触摸事件\n    canvas.addEventListener('touchstart', function(e) {\n        if (!img) {\n            // 如果canvas为空，则阻止默认的滑动行为并弹出警告\n            e.preventDefault();\n            showAlarm(\"不可滑动，若要滑动网页请在该区域外（屏幕边缘/顶部）滑动\");\n            return;\n        }\n        isDragging = true;\n        startX = e.touches[0].clientX - imgProps.offsetX;\n        startY = e.touches[0].clientY - imgProps.offsetY;\n        e.preventDefault(); // 阻止默认的滑动行为\n    });\n\n    canvas.addEventListener('touchmove', function(e) {\n        if (isDragging) {\n            if (!img) {\n                // 如果canvas为空，则阻止默认的滑动行为并弹出警告\n                e.preventDefault();\n                showAlarm(\"不可滑动，若要滑动网页请在该区域外（屏幕边缘/顶部）滑动\");\n                return;\n            }\n            imgProps.offsetX = e.touches[0].clientX - startX;\n            imgProps.offsetY = e.touches[0].clientY - startY;\n            limitOffset(); // 更新拖动后的偏移量\n            redraw(); // 重新绘制图像\n            e.preventDefault(); // 阻止默认的滑动行为\n        }\n    });\n\n    canvas.addEventListener('touchend', function() {\n        isDragging = false;\n    });\n}\n\n// 弹出警告函数\nfunction showAlarm(message) {\n    // 创建提示框元素\n    const alertBox = document.createElement('div');\n    alertBox.textContent = message;\n    alertBox.classList.add('alert-box');\n    document.body.appendChild(alertBox);\n\n    // 在下一个动画帧中添加淡出效果\n    requestAnimationFrame(() => {\n        alertBox.style.opacity = '1'; // 淡入效果\n    });\n\n    // 设置定时器，在3秒后隐藏提示框\n    setTimeout(function() {\n        // 在下一个动画帧中添加淡出效果\n        requestAnimationFrame(() => {\n            alertBox.style.opacity = '0'; // 淡出效果\n        });\n        // 3秒后删除提示框\n        setTimeout(() => {\n            document.body.removeChild(alertBox);\n        }, 300);\n    }, 3000);\n}\n\n// 添加按钮事件监听器\ndocument.querySelector('.scale-controls button:first-child').addEventListener('click', function() {\n    scaleInput.value = parseFloat(scaleInput.value) - 1; // 递减1\n    updateScale();\n});\n\ndocument.querySelector('.scale-controls button:last-child').addEventListener('click', function() {\n    scaleInput.value = parseFloat(scaleInput.value) + 1; // 递增1\n    updateScale();\n});\n\n// 添加输入框事件监听器\nscaleInput.addEventListener('change', function() {\n    updateScale();\n});\n\n// 立绘翻转按钮事件监听器\ndocument.getElementById('flipButton').addEventListener('click', function() {\n    flipImage();\n});\n\n\n// 更新图像大小的函数\nfunction updateScale() {\n    const newScale = parseFloat(scaleInput.value) / 100; // 获取输入框的值并转换为小数形式\n    const initialScale = imgProps.originalScale; // 获取初始记录的缩放比例\n\n    // 如果输入的缩放比例小于初始记录的值，则将输入的值调整为初始记录的值\n    if (newScale < initialScale) {\n        scaleInput.value = (initialScale * 100).toFixed(2); // 将输入框的值设为初始记录的值\n\n        // 创建提示框元素\n        const alertBox = document.createElement('div');\n        alertBox.textContent = '图片不得过小';\n        alertBox.classList.add('alert-box');\n        document.body.appendChild(alertBox);\n\n        // 在下一个动画帧中添加淡出效果\n        requestAnimationFrame(() => {\n            alertBox.style.opacity = '1'; // 淡入效果\n        });\n\n        // 设置定时器，在3秒后隐藏提示框\n        setTimeout(function() {\n            // 在下一个动画帧中添加淡出效果\n            requestAnimationFrame(() => {\n                alertBox.style.opacity = '0'; // 淡出效果\n            });\n            // 3秒后删除提示框\n            setTimeout(() => {\n                document.body.removeChild(alertBox);\n            }, 300);\n        }, 3000);\n\n        imgProps.scale = initialScale;\n        imgProps.offsetX = 1;\n        imgProps.offsetY *= 1;\n\n        // 限制偏移量以确保图像保持在画布范围内\n        limitOffset();\n\n        // 重新绘制图像\n        redraw();\n\n        return; // 结束函数，不进行后续的操作\n    }\n\n    const scaleDiff = newScale / imgProps.scale; // 计算缩放比例变化\n\n    // 更新图像的缩放比例和偏移量\n    imgProps.scale = newScale;\n    imgProps.offsetX *= scaleDiff;\n    imgProps.offsetY *= scaleDiff;\n\n    // 限制偏移量以确保图像保持在画布范围内\n    limitOffset();\n\n    // 重新绘制图像\n    redraw();\n}\n\n// 图片翻转函数\nfunction flipImage() {\n    if (img) {\n        const canvas = document.getElementById('cardCanvas');\n        const ctx = canvas.getContext('2d');\n\n        // 清除画布\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        // 将图片水平翻转\n        ctx.translate(canvas.width, 0);\n        ctx.scale(-1, 1);\n\n        // 重新绘制图像\n        redraw();\n    }\n}\n\n// 获取select元素\nconst attributeSelect = document.getElementById('attributeSelect');\nconst gradeSelect = document.getElementById('gradeSelect');\n\n// 添加事件监听器\nattributeSelect.addEventListener('change', function() {\n    // 获取选中的属性值\n    const selectedAttribute = attributeSelect.value;\n\n    // 更新支援卡类型图片的src属性\n    const typeImg = document.querySelector('.type img');\n    typeImg.src = `images/card_type/${selectedAttribute}.png`;\n});\n\ngradeSelect.addEventListener('change', function() {\n    // 获取选中的品级值\n    const selectedGrade = gradeSelect.value;\n\n    // 更新边框和标签图片的src属性\n    const borderImg = document.querySelector('.border-overlay img');\n    const tagImg = document.querySelector('.tag img');\n    borderImg.src = `images/card_borders/${selectedGrade}.png`;\n    tagImg.src = `images/card_tag/${selectedGrade}.png`;\n});\n\n// 初始化时触发一次事件，以确保初始值对应的元素会被更新\nattributeSelect.dispatchEvent(new Event('change'));\ngradeSelect.dispatchEvent(new Event('change'));\n\n// 添加保存按钮功能\ndocument.getElementById('saveButton').addEventListener('click', function() {\n    saveCardPreview();\n});\n\n// 保存卡片预览功能\nfunction saveCardPreview() {\n    const cardPreview = document.querySelector('.border-container');\n    html2canvas(cardPreview, {\n        backgroundColor: null // 使用透明背景\n    }).then(canvas => {\n        // 创建一个链接\n        const link = document.createElement('a');\n        link.href = canvas.toDataURL(); // 将画布转换为数据 URL\n        link.download = 'card_preview.png'; // 设置下载文件名\n        link.click(); // 模拟点击链接进行下载\n    });\n    // 创建提示框元素\n    const alertBox = document.createElement('div');\n    alertBox.textContent = '（应该）下载成功了~';\n    alertBox.classList.add('alert-box', 'success');\n    document.body.appendChild(alertBox);\n\n    // 在下一个动画帧中添加淡出效果\n    requestAnimationFrame(() => {\n        alertBox.style.opacity = '1'; // 淡入效果\n    });\n\n    // 设置定时器，在3秒后隐藏提示框\n    setTimeout(function() {\n        // 在下一个动画帧中添加淡出效果\n        requestAnimationFrame(() => {\n            alertBox.style.opacity = '0'; // 淡出效果\n        });\n        // 3秒后删除提示框\n        setTimeout(() => {\n            document.body.removeChild(alertBox);\n        }, 300);\n    }, 3000);\n}\n\n// 获取所有按钮和 GitHub 图标链接元素\nconst buttons = document.querySelectorAll('.button');\nconst githubLink = document.querySelector('.github-link');\n\n// 遍历所有按钮，为它们添加鼠标悬停和点击事件监听器\nbuttons.forEach(button => {\n    button.addEventListener('mouseover', function() {\n        this.style.backgroundColor = '#0056b3'; // 改变背景颜色为悬停状态\n    });\n\n    button.addEventListener('mouseleave', function() {\n        this.style.backgroundColor = '#007bff'; // 恢复默认背景颜色\n    });\n\n    button.addEventListener('mousedown', function() {\n        this.style.backgroundColor = '#0056b3'; // 改变背景颜色为点击状态\n    });\n\n    button.addEventListener('mouseup', function() {\n        this.style.backgroundColor = '#007bff'; // 恢复默认背景颜色\n    });\n});\n\n// 为 GitHub 图标链接添加鼠标悬停和点击事件监听器\ngithubLink.addEventListener('mouseover', function() {\n    this.querySelector('img').style.filter = 'invert(100%)'; // 反转颜色\n});\n\ngithubLink.addEventListener('mouseleave', function() {\n    this.querySelector('img').style.filter = 'invert(0%)'; // 恢复默认颜色\n});\n\ngithubLink.addEventListener('mousedown', function() {\n    this.querySelector('img').style.filter = 'invert(100%)'; // 反转颜色\n});\n\ngithubLink.addEventListener('mouseup', function() {\n    this.querySelector('img').style.filter = 'invert(0%)'; // 恢复默认颜色\n});\n\n// 获取弹窗元素和关闭按钮\nconst modal = document.getElementById('helpModal');\nconst helpButton = document.getElementById('helpButton');\nconst closeButton = document.getElementsByClassName('close')[0];\n\n// 点击问号按钮显示弹窗\nhelpButton.onclick = function() {\n    modal.style.display = 'block';\n}\n\n// 点击关闭按钮或者弹窗外部区域关闭弹窗\ncloseButton.onclick = function() {\n    this.parentElement.parentElement.style.display = 'none'; // 修改这里\n}\n\nwindow.onclick = function(event) {\n    if (event.target == modal) {\n        modal.style.display = 'none';\n    }\n}\n"},{"url":"/pong/index.html","content":"\n\n\n    \n    \n    Cyberpongk\n    \n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n            font-family: 'Segoe UI', Tahoma, 'Microsoft YaHei', sans-serif;\n        }\n\n        body {\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            min-height: 100vh;\n            background: linear-gradient(135deg, #0c1027, #1a1f4b, #0c1027);\n            background-size: 400% 400%;\n            animation: gradientBG 15s ease infinite;\n            overflow: hidden;\n            color: #e1e6ff;\n            padding: 20px;\n        }\n\n        /* 新增开始页面样式 */\n        .start-screen {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(8, 15, 32, 0.95);\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            z-index: 2000;\n            backdrop-filter: blur(5px);\n            transition: opacity 0.8s ease, transform 0.8s ease;\n        }\n\n        .start-screen.hidden {\n            opacity: 0;\n            pointer-events: none;\n            transform: translateY(20px);\n        }\n\n        .start-container {\n            width: 100%;\n            max-width: 700px;\n            padding: 30px;\n            background: rgba(12, 22, 45, 0.85);\n            border: 1px solid rgba(101, 80, 255, 0.3);\n            border-radius: 15px;\n            box-shadow: 0 0 50px rgba(101, 80, 255, 0.4);\n            position: relative;\n            overflow: hidden;\n        }\n\n        .start-container::before {\n            content: '';\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(45deg,\n                transparent 0%,\n                rgba(101, 80, 255, 0.1) 50%,\n                transparent 100%);\n            animation: scanLine 8s linear infinite;\n            z-index: -1;\n        }\n\n        .start-title {\n            text-align: center;\n            font-size: 3.5rem;\n            color: #e1e6ff;\n            text-shadow: 0 0 20px rgba(101, 80, 255, 0.8);\n            margin-bottom: 20px;\n            letter-spacing: 3px;\n            font-weight: 800;\n            position: relative;\n        }\n\n        .start-title::after {\n            content: '';\n            position: absolute;\n            bottom: -10px;\n            left: 50%;\n            transform: translateX(-50%);\n            width: 150px;\n            height: 3px;\n            background: linear-gradient(90deg, transparent, #6550ff, transparent);\n        }\n\n        .start-subtitle {\n            text-align: center;\n            color: #a0a8ff;\n            font-size: 1.2rem;\n            margin-bottom: 40px;\n            max-width: 600px;\n            line-height: 1.6;\n        }\n\n        .start-options {\n            margin-bottom: 40px;\n        }\n\n        .option-group {\n            margin-bottom: 25px;\n        }\n\n        .option-title {\n            font-size: 1.4rem;\n            color: #e1e6ff;\n            margin-bottom: 15px;\n            display: flex;\n            align-items: center;\n        }\n\n        .option-title::before {\n            content: '▶';\n            color: #ffcc00;\n            margin-right: 10px;\n            font-size: 0.8rem;\n        }\n\n        .difficulty-options {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));\n            gap: 12px;\n        }\n\n        .start-difficulty-option {\n            background: rgba(16, 24, 48, 0.7);\n            border: 1px solid rgba(101, 80, 255, 0.3);\n            color: #e1e6ff;\n            padding: 12px 5px;\n            border-radius: 8px;\n            cursor: pointer;\n            text-align: center;\n            transition: all 0.3s ease;\n            position: relative;\n            overflow: hidden;\n        }\n\n        .start-difficulty-option:hover {\n            background: rgba(101, 80, 255, 0.4);\n            transform: translateY(-3px);\n            box-shadow: 0 5px 15px rgba(101, 80, 255, 0.3);\n        }\n\n        .start-difficulty-option.active {\n            background: rgba(101, 80, 255, 0.6);\n            border-color: #6550ff;\n            box-shadow: 0 0 15px rgba(101, 80, 255, 0.5);\n        }\n\n        .ai-toggle-container {\n            display: flex;\n            align-items: center;\n            background: rgba(16, 24, 48, 0.7);\n            border: 1px solid rgba(255, 165, 0, 0.3);\n            border-radius: 8px;\n            padding: 15px;\n            transition: all 0.3s ease;\n        }\n\n        .ai-toggle-container:hover {\n            background: rgba(255, 165, 0, 0.2);\n            transform: translateY(-3px);\n            box-shadow: 0 5px 15px rgba(255, 165, 0, 0.2);\n        }\n\n        .ai-toggle-label {\n            flex-grow: 1;\n            font-size: 1.1rem;\n            color: #e1e6ff;\n        }\n\n        .ai-toggle {\n            position: relative;\n            width: 60px;\n            height: 30px;\n        }\n\n        .ai-toggle input {\n            opacity: 0;\n            width: 0;\n            height: 0;\n        }\n\n        .ai-toggle-slider {\n            position: absolute;\n            cursor: pointer;\n            top: 0;\n            left: 0;\n            right: 0;\n            bottom: 0;\n            background-color: rgba(255, 68, 68, 0.5);\n            transition: .4s;\n            border-radius: 30px;\n        }\n\n        .ai-toggle-slider:before {\n            position: absolute;\n            content: \"\";\n            height: 22px;\n            width: 22px;\n            left: 4px;\n            bottom: 4px;\n            background-color: #e1e6ff;\n            transition: .4s;\n            border-radius: 50%;\n        }\n\n        input:checked + .ai-toggle-slider {\n            background-color: rgba(0, 200, 83, 0.7);\n        }\n\n        input:checked + .ai-toggle-slider:before {\n            transform: translateX(30px);\n        }\n\n        .start-button {\n            display: block;\n            width: 100%;\n            max-width: 300px;\n            margin: 0 auto;\n            background: linear-gradient(135deg, #6550ff, #8a7cff);\n            border: none;\n            color: #e1e6ff;\n            padding: 15px;\n            font-size: 1.4rem;\n            border-radius: 8px;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            font-weight: bold;\n            letter-spacing: 1px;\n            text-transform: uppercase;\n            position: relative;\n            overflow: hidden;\n            z-index: 1;\n        }\n\n        .start-button::before {\n            content: '';\n            position: absolute;\n            top: -2px;\n            left: -2px;\n            right: -2px;\n            bottom: -2px;\n            background: linear-gradient(135deg,\n                #6550ff, #8a7cff,\n                #ffcc00, #ff3366,\n                #6550ff, #8a7cff);\n            background-size: 300% 300%;\n            z-index: -1;\n            border-radius: 10px;\n            animation: gradientBG 3s ease infinite;\n        }\n\n        .start-button:hover {\n            transform: scale(1.05);\n            box-shadow: 0 0 30px rgba(101, 80, 255, 0.6);\n        }\n\n        .start-button:active {\n            transform: scale(0.98);\n        }\n\n        @keyframes scanLine {\n            0% { transform: translateY(-100%); }\n            100% { transform: translateY(100%); }\n        }\n\n        @keyframes gradientBG {\n            0% { background-position: 0% 50%; }\n            50% { background-position: 100% 50%; }\n            100% { background-position: 0% 50%; }\n        }\n\n        .game-container {\n            position: relative;\n            width: 100%;\n            max-width: 900px;\n            background: rgba(12, 16, 39, 0.8);\n            border-radius: 16px;\n            box-shadow: 0 0 40px rgba(101, 80, 255, 0.3);\n            overflow: hidden;\n            border: 1px solid rgba(101, 80, 255, 0.3);\n            backdrop-filter: blur(10px);\n        }\n\n        .game-header {\n            text-align: center;\n            padding: 5px;\n            background: rgba(0, 0, 0, 0.4);\n            border-bottom: 1px solid rgba(101, 80, 255, 0.3);\n        }\n\n        .game-title {\n            color: #e1e6ff;\n            font-size: 2.5rem;\n            margin-bottom: 10px;\n            text-shadow: 0 0 15px #6550ff;\n            letter-spacing: 2px;\n            font-weight: 700;\n        }\n\n        .game-subtitle {\n            color: #a0a8ff;\n            font-size: 1.1rem;\n            opacity: 0.8;\n        }\n\n        .game-stats {\n            display: flex;\n            justify-content: space-between;\n            padding: 5px 30px;\n            background: rgba(16, 20, 45, 0.7);\n            position: relative;\n        }\n\n        .player-stats {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            position: relative;\n        }\n\n        .player-name {\n            font-size: 1.2rem;\n            margin-bottom: 5px;\n            color: #a0a8ff;\n        }\n\n        .player-score {\n            font-size: 2.5rem;\n            font-weight: bold;\n            color: #ffcc00;\n            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);\n            position: relative;\n        }\n\n        .score-animation {\n            position: absolute;\n            font-size: 3rem;\n            color: #ff3366;\n            opacity: 0;\n            animation: scorePopup 1s forwards;\n            pointer-events: none;\n            z-index: 10;\n            text-shadow: 0 0 15px rgba(255, 51, 102, 0.7);\n        }\n\n        @keyframes scorePopup {\n            0% {\n                transform: translateY(0);\n                opacity: 1;\n            }\n            100% {\n                transform: translateY(-100px);\n                opacity: 0;\n            }\n        }\n\n        .game-content {\n            position: relative;\n            display: flex;\n            justify-content: center;\n            padding: 20px;\n        }\n\n        #game-canvas {\n            background: rgba(8, 12, 33, 0.7);\n            border-radius: 8px;\n            box-shadow: 0 0 30px rgba(101, 80, 255, 0.2);\n            border: 1px solid rgba(101, 80, 255, 0.2);\n        }\n\n        .controls-info {\n            text-align: center;\n            padding: 15px;\n            font-size: 1rem;\n            color: #a0a8ff;\n            background: rgba(16, 20, 45, 0.6);\n            border-top: 1px solid rgba(101, 80, 255, 0.2);\n        }\n\n        .particle {\n            position: absolute;\n            pointer-events: none;\n            border-radius: 50%;\n            background: #ffcc00;\n            opacity: 0.8;\n        }\n\n        .center-line {\n            position: absolute;\n            top: 0;\n            bottom: 0;\n            left: 50%;\n            width: 2px;\n            background: linear-gradient(to bottom,\n                transparent 0%,\n                rgba(101, 80, 255, 0.5) 10%,\n                rgba(101, 80, 255, 0.8) 50%,\n                rgba(101, 80, 255, 0.5) 90%,\n                transparent 100%);\n            transform: translateX(-50%);\n        }\n\n        .glow-effect {\n            position: absolute;\n            top: 0;\n            left: 0;\n            right: 0;\n            bottom: 0;\n            border-radius: 16px;\n            box-shadow: inset 0 0 30px rgba(101, 80, 255, 0.5);\n            pointer-events: none;\n            z-index: -1;\n        }\n\n        .victory-overlay {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(12, 16, 39, 0.85);\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            z-index: 100;\n            opacity: 0;\n            pointer-events: none;\n            transition: opacity 0.5s ease;\n        }\n\n        .victory-message {\n            font-size: 4rem;\n            font-weight: bold;\n            color: #ffcc00;\n            text-shadow: 0 0 20px rgba(255, 204, 0, 0.8);\n            margin-bottom: 30px;\n            text-align: center;\n            animation: pulse 1.5s infinite;\n        }\n\n        .restart-btn {\n            background: rgba(101, 80, 255, 0.5);\n            border: 2px solid #a0a8ff;\n            color: #e1e6ff;\n            padding: 12px 35px;\n            font-size: 1.2rem;\n            border-radius: 8px;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            font-weight: bold;\n            letter-spacing: 1px;\n        }\n\n        .restart-btn:hover {\n            background: rgba(101, 80, 255, 0.8);\n            transform: scale(1.05);\n            box-shadow: 0 0 20px rgba(101, 80, 255, 0.5);\n        }\n\n        @keyframes pulse {\n            0% { transform: scale(1); text-shadow: 0 0 20px rgba(255, 204, 0, 0.8); }\n            50% { transform: scale(1.1); text-shadow: 0 0 30px rgba(255, 204, 0, 1); }\n            100% { transform: scale(1); text-shadow: 0 0 20px rgba(255, 204, 0, 0.8); }\n        }\n\n        .obstacle-warning {\n            position: absolute;\n            border-radius: 50%;\n            pointer-events: none;\n            z-index: 5;\n            animation: warningPulse 0.5s infinite alternate;\n        }\n\n        @keyframes warningPulse {\n            0% { opacity: 0.3; transform: scale(0.8); }\n            100% { opacity: 0.7; transform: scale(1.1); }\n        }\n\n        /* 事件弹窗样式 */\n        .event-notification {\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            background: rgba(12, 16, 39, 0.95);\n            border: 2px solid;\n            border-radius: 12px;\n            padding: 15px 20px;\n            min-width: 250px;\n            max-width: 350px;\n            z-index: 1000;\n            transform: translateX(100%);\n            transition: transform 0.5s ease, opacity 0.5s ease;\n            backdrop-filter: blur(10px);\n            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n        }\n\n        .event-notification.show {\n            transform: translateX(0);\n            opacity: 1;\n        }\n\n        .event-notification.positive {\n            border-color: #00ff88;\n            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);\n        }\n\n        .event-notification.neutral {\n            border-color: #888888;\n            box-shadow: 0 0 20px rgba(136, 136, 136, 0.3);\n        }\n\n        .event-notification.negative {\n            border-color: #ff4444;\n            box-shadow: 0 0 20px rgba(255, 68, 68, 0.3);\n        }\n\n        .event-title {\n            font-size: 1.2rem;\n            font-weight: bold;\n            margin-bottom: 5px;\n            color: #e1e6ff;\n        }\n\n        .event-description {\n            font-size: 0.9rem;\n            color: #a0a8ff;\n            line-height: 1.4;\n        }\n\n        .event-trigger {\n            font-size: 0.8rem;\n            color: #ffcc00;\n            margin-bottom: 8px;\n            font-weight: bold;\n        }\n\n        @keyframes slideInRight {\n            from {\n                transform: translateX(100%);\n                opacity: 0;\n            }\n            to {\n                transform: translateX(0);\n                opacity: 1;\n            }\n        }\n\n        @keyframes slideOutRight {\n            from {\n                transform: translateX(0);\n                opacity: 1;\n            }\n            to {\n                transform: translateX(100%);\n                opacity: 0;\n            }\n        }\n\n        /* 暂停/重新开始按钮样式 */\n        .pause-button {\n            position: fixed;\n            top: 20px;\n            right: 5%;\n            transform: translateX(50%);\n            background: rgba(101, 80, 255, 0.8);\n            border: 2px solid rgba(101, 80, 255, 0.9);\n            color: #e1e6ff;\n            padding: 12px 24px;\n            font-size: 1rem;\n            border-radius: 8px;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            font-weight: bold;\n            letter-spacing: 1px;\n            z-index: 1000;\n            backdrop-filter: blur(10px);\n            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);\n        }\n\n        .pause-button:hover {\n            background: rgba(101, 80, 255, 1);\n            transform: translateX(50%) scale(1.05);\n            box-shadow: 0 0 20px rgba(101, 80, 255, 0.6);\n        }\n\n        .pause-button.paused {\n            background: rgba(255, 68, 68, 0.8);\n            border-color: rgba(255, 68, 68, 0.9);\n        }\n\n        .pause-button.paused:hover {\n            background: rgba(255, 68, 68, 1);\n            box-shadow: 0 0 20px rgba(255, 68, 68, 0.6);\n        }\n\n        /* 调试窗口样式 */\n        .debug-panel {\n            position: fixed;\n            top: 20px;\n            left: 20px;\n            background: rgba(12, 16, 39, 0.95);\n            border: 2px solid rgba(255, 68, 68, 0.5);\n            border-radius: 12px;\n            padding: 15px;\n            width: 60px;\n            height: 60px;\n            z-index: 1000;\n            transition: all 0.3s ease;\n            backdrop-filter: blur(10px);\n            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n            cursor: pointer;\n            overflow: hidden;\n        }\n\n        .debug-panel:hover {\n            width: 280px;\n            height: 420px;\n            cursor: default;\n        }\n\n        .debug-icon {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            font-size: 24px;\n            color: #ff4444;\n            transition: opacity 0.3s ease;\n        }\n\n        .debug-panel:hover .debug-icon {\n            opacity: 0;\n        }\n\n        .debug-content {\n            opacity: 0;\n            transition: opacity 0.3s ease 0.1s;\n            height: 100%;\n            display: flex;\n            flex-direction: column;\n            font-size: 0.85rem;\n        }\n\n        .debug-panel:hover .debug-content {\n            opacity: 1;\n        }\n\n        .debug-title {\n            color: #e1e6ff;\n            font-size: 1.1rem;\n            font-weight: bold;\n            margin-bottom: 15px;\n            text-align: center;\n            border-bottom: 1px solid rgba(255, 68, 68, 0.3);\n            padding-bottom: 8px;\n        }\n\n        .debug-section {\n            margin-bottom: 12px;\n        }\n\n        .debug-section-title {\n            color: #ff4444;\n            font-weight: bold;\n            margin-bottom: 5px;\n            font-size: 0.9rem;\n        }\n\n        .debug-item {\n            color: #a0a8ff;\n            margin: 2px 0;\n            display: flex;\n            justify-content: space-between;\n        }\n\n        .debug-label {\n            color: #e1e6ff;\n        }\n\n        .debug-value {\n            color: #ffcc00;\n            font-weight: bold;\n        }\n\n        /* 难度调整窗口样式 */\n        .difficulty-panel {\n            position: fixed;\n            top: 50%;\n            right: 20px;\n            transform: translateY(-50%);\n            background: rgba(12, 16, 39, 0.95);\n            border: 2px solid rgba(101, 80, 255, 0.5);\n            border-radius: 12px;\n            padding: 15px;\n            width: 60px;\n            height: 60px;\n            z-index: 1000;\n            transition: all 0.3s ease;\n            backdrop-filter: blur(10px);\n            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n            cursor: pointer;\n            overflow: hidden;\n        }\n\n        .difficulty-panel:hover {\n            width: 200px;\n            height: 320px;\n            cursor: default;\n        }\n\n        .difficulty-icon {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            font-size: 24px;\n            color: #6550ff;\n            transition: opacity 0.3s ease;\n        }\n\n        .difficulty-panel:hover .difficulty-icon {\n            opacity: 0;\n        }\n\n        .difficulty-content {\n            opacity: 0;\n            transition: opacity 0.3s ease 0.1s;\n            height: 100%;\n            display: flex;\n            flex-direction: column;\n        }\n\n        .difficulty-panel:hover .difficulty-content {\n            opacity: 1;\n        }\n\n        .difficulty-title {\n            color: #e1e6ff;\n            font-size: 1.1rem;\n            font-weight: bold;\n            margin-bottom: 15px;\n            text-align: center;\n        }\n\n        .difficulty-option {\n            background: rgba(101, 80, 255, 0.3);\n            border: 1px solid rgba(101, 80, 255, 0.5);\n            color: #e1e6ff;\n            padding: 8px 12px;\n            margin: 3px 0;\n            border-radius: 6px;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            font-size: 0.9rem;\n            text-align: center;\n        }\n\n        .difficulty-option:hover {\n            background: rgba(101, 80, 255, 0.6);\n            transform: scale(1.02);\n        }\n\n        .difficulty-option.active {\n            background: rgba(101, 80, 255, 0.8);\n            border-color: #6550ff;\n            box-shadow: 0 0 10px rgba(101, 80, 255, 0.5);\n        }\n\n        /* 电脑回球增强选项样式 */\n        .ai-enhancement-option {\n            background: rgba(255, 165, 0, 0.3);\n            border: 1px solid rgba(255, 165, 0, 0.5);\n            color: #e1e6ff;\n            padding: 8px 12px;\n            margin: 8px 0;\n            border-radius: 6px;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            font-size: 0.9rem;\n            text-align: center;\n        }\n\n        .ai-enhancement-option:hover {\n            background: rgba(255, 165, 0, 0.6);\n            transform: scale(1.02);\n        }\n\n        .ai-enhancement-option.active {\n            background: rgba(255, 165, 0, 0.8);\n            border-color: #ffa500;\n            box-shadow: 0 0 10px rgba(255, 165, 0, 0.5);\n        }\n\n        @media (max-width: 768px) {\n            .game-title {\n                font-size: 2rem;\n            }\n\n            .game-subtitle {\n                font-size: 0.9rem;\n            }\n\n            .player-name {\n                font-size: 1rem;\n            }\n\n            .player-score {\n                font-size: 2rem;\n            }\n\n            .victory-message {\n                font-size: 2.5rem;\n            }\n\n            .event-notification {\n                top: 10px;\n                right: 10px;\n                min-width: 200px;\n                max-width: 280px;\n                padding: 12px 15px;\n            }\n\n            .event-title {\n                font-size: 1rem;\n            }\n\n            .event-description {\n                font-size: 0.8rem;\n            }\n\n\n            .difficulty-panel {\n                right: 10px;\n                width: 50px;\n                height: 50px;\n            }\n\n            .difficulty-panel:hover {\n                width: 180px;\n                height: 280px;\n            }\n\n            .difficulty-icon {\n                font-size: 20px;\n            }\n\n            .debug-panel {\n                left: 10px;\n                width: 50px;\n                height: 50px;\n            }\n\n            .debug-panel:hover {\n                width: 260px;\n                height: 300px;\n            }\n\n            .debug-icon {\n                font-size: 20px;\n            }\n\n            .pause-button {\n                top: 10px;\n                padding: 10px 20px;\n                font-size: 0.9rem;\n            }\n        }\n    \n\n\n    \n    \n        \n            CYBERPONGK\n            直面强敌，守住底线，转战回击为了最佳的游戏体验，请打开敌方回球增强\n\n            \n                \n                    作战难度\n                    \n                        万泉部诗人\n                        野比大雄\n                        少女B\n                        小埋\n                        空&白\n                    \n                \n\n                \n                    敌方强化模块\n                    \n                        激活敌方回球增强协议\n                        \n                            \n                            \n                        \n                    \n                \n            \n\n            启动战斗系统\n        \n    \n\n    \n        \n        \n            CYBERPONGK\n            Itsuyo的摸鱼大（存疑）作 · Crafted with Deepsuck\n        \n\n        \n            \n                玩家\n                0\n            \n\n            \n                电脑\n                0\n            \n        \n\n        \n            \n            \n        \n\n        \n            \n            重新开始\n        \n\n        \n            使用鼠标移动控制你的挡板 | 首先获得3分者获胜 | 收集事件获得特殊效果！\n        \n    \n\n    \n    \n        ⚙️\n        \n            难度设置\n            万泉部诗人\n            野比大雄\n            少女B\n            小埋\n            空&白\n\n            \n            \n                敌方回球增强\n            \n        \n    \n\n    \n    \n        🐛\n        \n            调试信息\n            \n            \n                球状态\n                \n                    速度:\n                    0\n                \n                \n                    位置:\n                    0,0\n                \n                \n                    透明度:\n                    1.0\n                \n            \n\n            \n                电脑数据\n                \n                    速度:\n                    3\n                \n                \n                    位置:\n                    0\n                \n                \n                    速度倍数:\n                    1.0\n                \n            \n\n            \n                事件状态\n                \n                    活跃事件:\n                    0\n                \n                \n                    障碍物:\n                    0\n                \n            \n\n            \n                系统\n                \n                    FPS:\n                    0\n                \n                \n                    游戏时间:\n                    0s\n                \n            \n        \n    \n\n    \n    暂停\n\n    \n        // 新增开始页面功能\n        document.addEventListener('DOMContentLoaded', function() {\n            const startScreen = document.getElementById('start-screen');\n            const startButton = document.getElementById('start-button');\n            const startDifficultyOptions = document.querySelectorAll('.start-difficulty-option');\n            const startAiToggle = document.getElementById('start-ai-enhancement');\n\n            // 设置默认选项（简单难度）\n            let selectedDifficulty = 1.75;\n\n            // 开始页面难度选择\n            startDifficultyOptions.forEach(option => {\n                option.addEventListener('click', function() {\n                    // 移除所有active类\n                    startDifficultyOptions.forEach(opt => opt.classList.remove('active'));\n                    // 添加active类到当前选项\n                    this.classList.add('active');\n                    // 更新选择的难度\n                    selectedDifficulty = parseFloat(this.dataset.speed);\n                });\n            });\n\n            // AI回球增强选项\n            startAiToggle.addEventListener('change', function() {\n                aiEnhancementEnabled = this.checked;\n            });\n\n            // 开始按钮事件\n            startButton.addEventListener('click', function() {\n                // 应用选择的难度到游戏内\n                computer.speed = selectedDifficulty;\n\n                // 同步游戏内难度选择\n                document.querySelectorAll('.difficulty-option').forEach(option => {\n                    if (parseFloat(option.dataset.speed) === selectedDifficulty) {\n                        option.classList.add('active');\n                    } else {\n                        option.classList.remove('active');\n                    }\n                });\n\n                // 同步AI增强选项\n                const gameAiToggle = document.getElementById('ai-enhancement-toggle');\n                if (aiEnhancementEnabled) {\n                    gameAiToggle.classList.add('active');\n                } else {\n                    gameAiToggle.classList.remove('active');\n                }\n\n                aiEnhancementEnabled = aiEnhancementEnabled;\n\n                // 隐藏开始页面\n                startScreen.classList.add('hidden');\n\n                // 设置电脑名称\n                const computerNameElement = document.getElementById('computer-player-name');\n                const selectedDifficultyOption = document.querySelector('.difficulty-option.active');\n                computerNameElement.textContent = selectedDifficultyOption.textContent;\n\n                // 重置游戏（如果已经玩过）\n                resetGame();\n            });\n        });\n\n        // 获取Canvas和Context\n        const canvas = document.getElementById('game-canvas');\n        const ctx = canvas.getContext('2d');\n\n        // 玩家和电脑的分数\n        const playerScoreElement = document.getElementById('player-score');\n        const computerScoreElement = document.getElementById('computer-score');\n        let playerScore = 0;\n        let computerScore = 0;\n\n        // 胜利界面元素\n        const victoryOverlay = document.getElementById('victory-overlay');\n        const victoryMessage = document.getElementById('victory-message');\n        const restartBtn = document.getElementById('restart-btn');\n\n        // 添加帧率锁定相关变量\n        const FPS = 120; // 目标帧率\n        const FRAME_INTERVAL = 1000 / FPS; // 每帧时间(ms)\n        let lastTime = 0;\n        let deltaTime = 0;\n        let accumulatedTime = 0;\n        let frameCount = 0;\n        let lastFpsUpdate = 0;\n\n        // 游戏状态\n        let isGameOver = false;\n        let isResetting = false;\n        let isPaused = false; // 添加暂停状态\n        let gameTime = 0; // 游戏运行时间（毫秒）\n        let nextObstacleTime = 15000; // 第一次障碍物出现时间（15秒后）\n        let nextEventTime = 10000; // 第一次事件出现时间（10秒后）\n\n        // 电脑回球增强功能状态\n        let aiEnhancementEnabled = false;\n\n        // 死球检测相关变量\n        let ballStuckDetection = {\n            lastY: 0,\n            stuckTime: 0,\n            checkInterval: 100, // 每100ms检查一次\n            lastCheckTime: 0,\n            stuckThreshold: 2000, // 2秒内卡在边缘判定为死球\n            edgeThreshold: 30 // 距离边缘30像素内算作边缘\n        };\n\n        // 记录上一个触球的玩家 ('player' 或 'computer')\n        let lastTouchedBy = null;\n\n        // 游戏对象\n        const ball = {\n            x: canvas.width / 2,\n            y: canvas.height / 2,\n            radius: 12,\n            speed: 4,\n            velocityX: 5,\n            velocityY: 5,\n            color: '#ffcc00',\n            trail: [],\n            lastCollision: 0, // 记录上次碰撞时间\n            alpha: 1.0, // 球的透明度\n            speedMultiplier: 1.0 // 速度倍数\n        };\n\n        // 玩家挡板\n        const player = {\n            x: 20,\n            y: canvas.height / 2 - 70,\n            width: 15,\n            height: 120,\n            speed: 8,\n            color: '#6550ff',\n            score: 0,\n            originalHeight: 120,\n            glowEffect: false,\n            glowEndTime: 0,\n            rgbEffect: false, // 添加rgb效果属性\n            rgbEndTime: 0 // 添加rgb效果结束时间\n        };\n\n        // 电脑挡板\n        const computer = {\n            x: canvas.width - 35,\n            y: canvas.height / 2 - 70,\n            width: 15,\n            height: 120,\n            speed: 3,\n            color: '#ff3366',\n            score: 0,\n            originalHeight: 120,\n            glowEffect: false,\n            glowEndTime: 0,\n            rgbEffect: false, // 添加rgb效果属性\n            rgbEndTime: 0, // 添加rgb效果结束时间\n            speedMultiplier: 1.0\n        };\n\n        // 粒子数组\n        const particles = [];\n\n        // 障碍物数组\n        const obstacles = [];\n\n        // 事件数组\n        const events = [];\n\n        // 全局效果\n        const globalEffects = {\n            speedVariation: { active: false, endTime: 0 },\n            obstacleSpeedUp: { active: false, endTime: 0, originalInterval: 0 },\n            thunderCloud: { active: false, endTime: 0, flashTime: 0 },\n            // 新增效果\n            immortalTotem: { active: false, endTime: 0, triggeredBy: null },\n            eventFrenzy: { active: false, endTime: 0, originalEventInterval: 0 },\n            heavenMaker: { active: false, endTime: 0, stackCount: 0 },\n            heavyBall: { active: false, endTime: 0, stackCount: 0 }\n        };\n\n        // 事件类型定义\n        const eventTypes = {\n            // 正面事件\n            PADDLE_GROW: {\n                type: 'positive',\n                color: '#00ff88',\n                name: 'Bo♂ki',\n                description: '板子增长20%，持续20秒'\n            },\n            LIGHTNING_PADDLE: {\n                type: 'positive',\n                color: '#ffff00',\n                name: '咖喱棒',\n                description: '获得金闪闪效果，触球增速80%，持续20秒'\n            },\n            SLOW_COMPUTER: {\n                type: 'positive',\n                color: '#00ccff',\n                name: '寒冰菇',\n                description: '电脑板子移动速度-20%，直到下次进球'\n            },\n            \n            // 中性事件\n            SPEED_VARIATION: {\n                type: 'neutral',\n                color: '#888888',\n                name: '致命节奏',\n                description: '球速在70%-130%间变动，持续15秒'\n            },\n            OBSTACLE_RUSH: {\n                type: 'neutral',\n                color: '#aa6600',\n                name: '移动迷宫',\n                description: '障碍物生成速度提升500%，持续30秒'\n            },\n            SPEED_RESET: {\n                type: 'neutral',\n                color: '#666666',\n                name: '食光鸡',\n                description: '球速重置为初始速度'\n            },\n            \n            // 负面事件\n            THUNDER_CLOUD: {\n                type: 'negative',\n                color: '#444444',\n                name: '骤雨的狭间',\n                description: '中央雷云遮挡视野，球经过时改变角度'\n            },\n            PADDLE_SHRINK: {\n                type: 'negative',\n                color: '#660000',\n                name: '阳痿',\n                description: '板子缩短20%，持续20秒'\n            },\n            BALL_FADE: {\n                type: 'negative',\n                color: '#333333',\n                name: '我名为暗影',\n                description: '球透明度降为10%，持续15秒'\n            },\n            \n            // 新增事件\n            // 正面\n            IMMORTAL_TOTEM: {\n                type: 'positive',\n                color: '#ff00ff',\n                name: '不死图腾',\n                description: '触发方在45秒内第一个失球均不计入分数'\n            },\n            // 中性\n            EVENT_FRENZY: {\n                type: 'neutral',\n                color: '#888888',\n                name: 'EVENT☆START',\n                description: '事件刷新率增加为400%，持续30秒'\n            },\n            HEAVEN_MAKER: {\n                type: 'neutral',\n                color: '#cccccc',\n                name: 'MADE IN HEAVEN',\n                description: '球的大小变为原来的50%，速度变为原来的125%，持续25秒'\n            },\n            HEAVY_BALL: {\n                type: 'neutral',\n                color: '#666666',\n                name: '遇水变大变高',\n                description: '球的大小变为原来的200%，速度变为原来的80%，持续25秒'\n            }\n        };\n\n        // 鼠标移动事件监听\n        canvas.addEventListener('mousemove', (e) => {\n            if (isGameOver || isPaused) return; // 添加暂停检查\n            const rect = canvas.getBoundingClientRect();\n            player.y = e.clientY - rect.top - player.height / 2;\n        });\n\n        // 重新开始按钮事件\n        restartBtn.addEventListener('click', () => {\n            resetGame();\n        });\n\n        // 难度调整事件监听器\n        document.querySelectorAll('.difficulty-option').forEach(option => {\n            option.addEventListener('click', (e) => {\n                // 移除所有active类\n                document.querySelectorAll('.difficulty-option').forEach(opt => opt.classList.remove('active'));\n                // 添加active类到当前选项\n                e.target.classList.add('active');\n                // 更新电脑速度\n                const newSpeed = parseFloat(e.target.dataset.speed);\n                computer.speed = newSpeed;\n                // 更新电脑名称\n                const computerNameElement = document.getElementById('computer-player-name');\n                computerNameElement.textContent = e.target.textContent;\n            });\n        });\n\n        // 电脑回球增强选项事件监听器\n        document.getElementById('ai-enhancement-toggle').addEventListener('click', (e) => {\n            aiEnhancementEnabled = !aiEnhancementEnabled;\n            if (aiEnhancementEnabled) {\n                e.target.classList.add('active');\n            } else {\n                e.target.classList.remove('active');\n            }\n        });\n\n        // 暂停按钮事件监听器\n        const pauseButton = document.getElementById('pause-button');\n        pauseButton.addEventListener('click', () => {\n            isPaused = !isPaused;\n            if (isPaused) {\n                pauseButton.textContent = '继续';\n                pauseButton.classList.add('paused');\n            } else {\n                pauseButton.textContent = '暂停';\n                pauseButton.classList.remove('paused');\n            }\n        });\n\n        // 显示事件通知弹窗\n        function showEventNotification(eventObj, triggeredBy) {\n            // 移除现有的通知\n            const existingNotification = document.querySelector('.event-notification');\n            if (existingNotification) {\n                existingNotification.remove();\n            }\n\n            // 创建新的通知元素\n            const notification = document.createElement('div');\n            notification.className = `event-notification ${eventObj.typeData.type}`;\n            \n            const triggerText = triggeredBy === 'player' ? '玩家触发' : '电脑触发';\n            \n            notification.innerHTML = `\n                ${triggerText}\n                ${eventObj.typeData.name}\n                ${eventObj.typeData.description}\n            `;\n\n            // 添加到页面\n            document.body.appendChild(notification);\n\n            // 触发显示动画\n            setTimeout(() => {\n                notification.classList.add('show');\n            }, 100);\n\n            // 3秒后自动隐藏\n            setTimeout(() => {\n                notification.classList.remove('show');\n                setTimeout(() => {\n                    if (notification.parentNode) {\n                        notification.remove();\n                    }\n                }, 500);\n            }, 3000);\n        }\n\n        // 显示死球检测通知\n        function showDeadBallNotification() {\n            // 移除现有的通知\n            const existingNotification = document.querySelector('.event-notification');\n            if (existingNotification) {\n                existingNotification.remove();\n            }\n\n            // 创建新的通知元素\n            const notification = document.createElement('div');\n            notification.className = 'event-notification negative';\n\n            notification.innerHTML = `\n                系统检测\n                卡球检测被触发\n                检测到边线死球bug，重新发球\n            `;\n\n            // 添加到页面\n            document.body.appendChild(notification);\n\n            // 触发显示动画\n            setTimeout(() => {\n                notification.classList.add('show');\n            }, 100);\n\n            // 3秒后自动隐藏\n            setTimeout(() => {\n                notification.classList.remove('show');\n                setTimeout(() => {\n                    if (notification.parentNode) {\n                        notification.remove();\n                    }\n                }, 500);\n            }, 3000);\n        }\n\n        // 死球检测函数\n        function checkDeadBall() {\n            const currentTime = Date.now();\n\n            // 每100ms检查一次\n            if (currentTime - ballStuckDetection.lastCheckTime < ballStuckDetection.checkInterval) {\n                return false;\n            }\n\n            ballStuckDetection.lastCheckTime = currentTime;\n\n            // 检查球是否在上下边缘附近\n            const isNearTopEdge = ball.y = (canvas.height - ballStuckDetection.edgeThreshold);\n\n            if (isNearTopEdge || isNearBottomEdge) {\n                // 检查球的Y坐标是否在很小范围内变化（表示卡住了）\n                const yDifference = Math.abs(ball.y - ballStuckDetection.lastY);\n\n                if (yDifference < 5) { // Y坐标变化小于5像素\n                    ballStuckDetection.stuckTime += ballStuckDetection.checkInterval;\n\n                    // 如果卡住时间超过阈值，触发死球检测\n                    if (ballStuckDetection.stuckTime >= ballStuckDetection.stuckThreshold) {\n                        return true;\n                    }\n                } else {\n                    // 球在移动，重置卡住时间\n                    ballStuckDetection.stuckTime = 0;\n                }\n            } else {\n                // 球不在边缘，重置卡住时间\n                ballStuckDetection.stuckTime = 0;\n            }\n\n            ballStuckDetection.lastY = ball.y;\n            return false;\n        }\n\n        // 重置游戏\n        function resetGame() {\n            playerScore = 0;\n            computerScore = 0;\n            playerScoreElement.textContent = '0';\n            computerScoreElement.textContent = '0';\n            victoryOverlay.style.opacity = '0';\n            victoryOverlay.style.pointerEvents = 'none';\n            isGameOver = false;\n            gameTime = 0;\n            nextObstacleTime = 20000;\n            nextEventTime = 10000;\n            obstacles.length = 0;\n            events.length = 0;\n            lastTouchedBy = null;\n\n            // 重置电脑名称\n            document.getElementById('computer-player-name').textContent = '电脑';\n\n            // 重置死球检测\n            ballStuckDetection.lastY = 0;\n            ballStuckDetection.stuckTime = 0;\n            ballStuckDetection.lastCheckTime = 0;\n            \n            // 移除所有事件通知\n            const notifications = document.querySelectorAll('.event-notification');\n            notifications.forEach(notification => notification.remove());\n            \n            // 重置挡板状态\n            player.height = player.originalHeight;\n            player.glowEffect = false;\n            player.glowEndTime = 0;\n            player.rgbEffect = false; // 重置rgb效果\n            player.rgbEndTime = 0; // 重置rgb效果结束时间\n            computer.height = computer.originalHeight;\n            computer.glowEffect = false;\n            computer.glowEndTime = 0;\n            computer.speedMultiplier = 1.0;\n            computer.rgbEffect = false; // 重置rgb效果\n            computer.rgbEndTime = 0; // 重置rgb效果结束时间\n            \n            // 重置球状态\n            ball.alpha = 1.0;\n            ball.speedMultiplier = 1.0;\n            ball.radius = 12; // 重置球的半径\n            \n            // 重置全局效果\n            globalEffects.speedVariation.active = false;\n            globalEffects.obstacleSpeedUp.active = false;\n            globalEffects.thunderCloud.active = false;\n            // 重置新增效果\n            globalEffects.immortalTotem.active = false;\n            globalEffects.immortalTotem.triggeredBy = null;\n            globalEffects.eventFrenzy.active = false;\n            globalEffects.heavenMaker.active = false;\n            globalEffects.heavenMaker.stackCount = 0;\n            globalEffects.heavyBall.active = false;\n            globalEffects.heavyBall.stackCount = 0;\n\n            const computerNameElement = document.getElementById('computer-player-name');\n            const selectedDifficultyOption = document.querySelector('.difficulty-option.active');\n            computerNameElement.textContent = selectedDifficultyOption.textContent;\n            \n            resetBall();\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        // 碰撞粒子效果\n        function createParticles(x, y, color, count = 15) {\n            for (let i = 0; i < count; i++) {\n                particles.push({\n                    x: x,\n                    y: y,\n                    radius: Math.random() * 3 + 1,\n                    color: color,\n                    speed: Math.random() * 3 + 2,\n                    angle: Math.random() * Math.PI * 2,\n                    life: 30\n                });\n            }\n        }\n\n        // 创建得分特效\n        function createScoreEffect(isPlayer) {\n            const scoreEffect = document.createElement('div');\n            scoreEffect.className = 'score-animation';\n            scoreEffect.textContent = '+1';\n\n            const statsContainer = isPlayer ?\n                playerScoreElement.parentElement :\n                computerScoreElement.parentElement;\n\n            statsContainer.appendChild(scoreEffect);\n\n            // 动画结束后移除元素\n            setTimeout(() => {\n                scoreEffect.remove();\n            }, 1000);\n        }\n\n        // 创建事件\n        function createEvent() {\n            // 在中间90%区域生成事件\n            const minX = canvas.width * 0.05;\n            const maxX = canvas.width * 0.95;\n            const minY = canvas.height * 0.05;\n            const maxY = canvas.height * 0.95;\n\n            const x = minX + Math.random() * (maxX - minX);\n            const y = minY + Math.random() * (maxY - minY);\n\n            // 随机选择事件类型\n            const eventTypeKeys = Object.keys(eventTypes);\n            const randomEventType = eventTypeKeys[Math.floor(Math.random() * eventTypeKeys.length)];\n            const eventType = eventTypes[randomEventType];\n\n            events.push({\n                x: x,\n                y: y,\n                radius: 15,\n                type: randomEventType,\n                typeData: eventType,\n                spawnTime: Date.now(),\n                duration: 20000, // 20秒后消失\n                pulsePhase: 0\n            });\n        }\n\n        // 触发事件效果\n        function triggerEvent(eventObj, triggeredBy) {\n            const currentTime = Date.now();\n            \n            // 显示事件通知\n            showEventNotification(eventObj, triggeredBy);\n            \n            switch (eventObj.type) {\n                case 'PADDLE_GROW':\n                    if (triggeredBy === 'player') {\n                        player.height = Math.min(player.height * 1.2, canvas.height * 0.8);\n                        player.glowEndTime = Math.max(player.glowEndTime, currentTime + 20000);\n                    } else {\n                        computer.height = Math.min(computer.height * 1.2, canvas.height * 0.8);\n                        computer.glowEndTime = Math.max(computer.glowEndTime, currentTime + 20000);\n                    }\n                    break;\n                    \n                case 'LIGHTNING_PADDLE':\n                    if (triggeredBy === 'player') {\n                        player.glowEffect = true;\n                        player.glowEndTime = Math.max(player.glowEndTime, currentTime + 20000);\n                    } else {\n                        computer.glowEffect = true;\n                        computer.glowEndTime = Math.max(computer.glowEndTime, currentTime + 20000);\n                    }\n                    break;\n                    \n                case 'SLOW_COMPUTER':\n                    // 这个事件只对玩家有用，但电脑也可以触发（只是没有效果）\n                    if (triggeredBy === 'player') {\n                        computer.speedMultiplier = Math.max(computer.speedMultiplier * 0.8, 0.1);\n                    }\n                    break;\n                    \n                case 'SPEED_VARIATION':\n                    globalEffects.speedVariation.active = true;\n                    globalEffects.speedVariation.endTime = Math.max(\n                        globalEffects.speedVariation.endTime, \n                        currentTime + 15000\n                    );\n                    break;\n                    \n                case 'OBSTACLE_RUSH':\n                    if (!globalEffects.obstacleSpeedUp.active) {\n                        globalEffects.obstacleSpeedUp.originalInterval = nextObstacleTime - gameTime;\n                    }\n                    globalEffects.obstacleSpeedUp.active = true;\n                    globalEffects.obstacleSpeedUp.endTime = Math.max(\n                        globalEffects.obstacleSpeedUp.endTime,\n                        currentTime + 30000\n                    );\n                    break;\n                    \n                case 'SPEED_RESET':\n                    ball.speed = 4;\n                    ball.speedMultiplier = 1.0;\n                    break;\n                    \n                case 'THUNDER_CLOUD':\n                    globalEffects.thunderCloud.active = true;\n                    globalEffects.thunderCloud.endTime = Math.max(\n                        globalEffects.thunderCloud.endTime,\n                        currentTime + 30000\n                    );\n                    break;\n                    \n                case 'PADDLE_SHRINK':\n                    if (triggeredBy === 'player') {\n                        player.height = Math.max(player.height * 0.8, 40);\n                        player.glowEndTime = Math.max(player.glowEndTime, currentTime + 20000);\n                    } else {\n                        computer.height = Math.max(computer.height * 0.8, 40);\n                        computer.glowEndTime = Math.max(computer.glowEndTime, currentTime + 20000);\n                    }\n                    break;\n                    \n                case 'BALL_FADE':\n                    ball.alpha = Math.min(ball.alpha, 0.1);\n                    // 这里需要一个计时器来恢复透明度\n                    setTimeout(() => {\n                        ball.alpha = Math.min(ball.alpha + 0.9, 1.0);\n                    }, 15000);\n                    break;\n                    \n                // 新增事件处理\n                case 'IMMORTAL_TOTEM':\n                    // 不死图腾效果，不可叠加\n                    if (!globalEffects.immortalTotem.active) {\n                        globalEffects.immortalTotem.active = true;\n                        globalEffects.immortalTotem.endTime = currentTime + 45000; // 45秒\n                        globalEffects.immortalTotem.triggeredBy = triggeredBy;\n\n                        // 为触发方添加RGB变色效果\n                        if (triggeredBy === 'player') {\n                            player.rgbEffect = true; // 使用rgbEffect而不是glowEffect\n                            player.rgbEndTime = currentTime + 45000;\n                        } else {\n                            computer.rgbEffect = true; // 使用rgbEffect而不是glowEffect\n                            computer.rgbEndTime = currentTime + 45000;\n                        }\n                    }\n                    break;\n\n                case 'EVENT_FRENZY':\n                    // 事件狂潮效果，不可叠加\n                    if (!globalEffects.eventFrenzy.active) {\n                        globalEffects.eventFrenzy.active = true;\n                        globalEffects.eventFrenzy.endTime = currentTime + 30000; // 30秒\n                        globalEffects.eventFrenzy.originalEventInterval = nextEventTime - gameTime;\n                    }\n                    break;\n                    \n                case 'HEAVEN_MAKER':\n                    // 天堂制造效果，可叠加\n                    if (!globalEffects.heavenMaker.active) {\n                        globalEffects.heavenMaker.active = true;\n                        globalEffects.heavenMaker.endTime = currentTime + 25000; // 25秒\n                        globalEffects.heavenMaker.stackCount = 1;\n                    } else {\n                        // 叠加效果，延长时间并增加叠加次数\n                        globalEffects.heavenMaker.endTime = Math.max(globalEffects.heavenMaker.endTime, currentTime + 25000);\n                        globalEffects.heavenMaker.stackCount++;\n                    }\n                    // 应用效果：球变小，速度变快\n                    ball.radius = Math.max(ball.radius * 0.5, 3); // 最小半径3像素\n                    ball.speedMultiplier *= 1.25;\n                    break;\n                    \n                case 'HEAVY_BALL':\n                    // 沉重效果，可叠加\n                    if (!globalEffects.heavyBall.active) {\n                        globalEffects.heavyBall.active = true;\n                        globalEffects.heavyBall.endTime = currentTime + 25000; // 25秒\n                        globalEffects.heavyBall.stackCount = 1;\n                    } else {\n                        // 叠加效果，延长时间并增加叠加次数\n                        globalEffects.heavyBall.endTime = Math.max(globalEffects.heavyBall.endTime, currentTime + 25000);\n                        globalEffects.heavyBall.stackCount++;\n                    }\n                    // 应用效果：球变大，速度变慢\n                    ball.radius = Math.min(ball.radius * 2, 50); // 最大半径50像素\n                    ball.speedMultiplier *= 0.8;\n                    break;\n            }\n            \n            // 创建事件触发粒子效果\n            createParticles(eventObj.x, eventObj.y, eventObj.typeData.color, 25);\n        }\n\n        // 创建障碍物\n        function createObstacles() {\n            // 确保障碍物在中间75%区域生成\n            const minX = canvas.width * 0.125; // 12.5% 左边距\n            const maxX = canvas.width * 0.875; // 87.5% 右边距\n            const minY = canvas.height * 0.125; // 12.5% 上边距\n            const maxY = canvas.height * 0.875; // 87.5% 下边距\n\n            // 随机位置\n            const x = minX + Math.random() * (maxX - minX);\n            const y = minY + Math.random() * (maxY - minY);\n\n            // 随机大小 (20-40像素)\n            const size = 20 + Math.random() * 20;\n\n            // 随机形状 (圆形或方形)\n            const type = Math.random() > 0.5 ? 'circle' : 'rect';\n\n            // 随机存在时间 (8-20秒)\n            const duration = 8000 + Math.random() * 12000;\n\n            // 预警时间 (1秒)\n            const warningTime = 1000;\n\n            // 随机选择对称模式 (1, 2, 3, 5, 9, 0, 4, 0个障碍物)\n            const symmetryMode = Math.floor(Math.random() * 8); // 0-7\n\n            // 障碍物位置数组\n            const positions = [];\n\n            // 中心点\n            const centerX = canvas.width / 2;\n            const centerY = canvas.height / 2;\n\n            // 根据对称模式生成障碍物位置（放射性轴对称）\n            switch (symmetryMode) {\n                case 0: // 1个障碍物（中心）\n                    positions.push({x: centerX, y: centerY});\n                    break;\n\n                case 1: // 2个障碍物（放射性轴对称）\n                    positions.push({x: x, y: y});\n                    positions.push({x: 2 * centerX - x, y: 2 * centerY - y});\n                    break;\n\n                case 2: // 3个障碍物（放射性轴对称）\n                    positions.push({x: centerX, y: centerY});\n                    positions.push({x: x, y: y});\n                    positions.push({x: 2 * centerX - x, y: 2 * centerY - y});\n                    break;\n\n                case 3: // 5个障碍物（放射性轴对称）\n                    positions.push({x: centerX, y: centerY});\n                    positions.push({x: x, y: y});\n                    positions.push({x: 2 * centerX - x, y: 2 * centerY - y});\n                    positions.push({x: x, y: 2 * centerY - y});\n                    positions.push({x: 2 * centerX - x, y: y});\n                    break;\n\n                case 4: // 9个障碍物（放射性轴对称）\n                    positions.push({x: centerX, y: centerY});\n                    positions.push({x: x, y: y});\n                    positions.push({x: 2 * centerX - x, y: 2 * centerY - y});\n                    positions.push({x: x, y: 2 * centerY - y});\n                    positions.push({x: 2 * centerX - x, y: y});\n                    positions.push({x: centerX, y: 2 * centerY - y});\n                    positions.push({x: 2 * centerX - x, y: centerY});\n                    positions.push({x: x, y: centerY});\n                    positions.push({x: centerX, y: y});\n                    break;\n\n                case 5: // None\n                    break;\n\n                case 6: // 4个障碍物（补）\n                    positions.push({x: x, y: y});\n                    positions.push({x: 2 * centerX - x, y: 2 * centerY - y});\n                    positions.push({x: x, y: 2 * centerY - y});\n                    positions.push({x: 2 * centerX - x, y: y});\n                    break;\n\n                case 7: //None\n                    break;\n            }\n\n            // 创建障碍物\n            for (const pos of positions) {\n                obstacles.push({\n                    x: pos.x,\n                    y: pos.y,\n                    size: size,\n                    type: type,\n                    warningTime: warningTime,\n                    warningProgress: 0,\n                    duration: duration,\n                    active: false,\n                    spawnTime: Date.now()\n                });\n            }\n        }\n\n        // 更新障碍物状态\n        function updateObstacles() {\n            const now = Date.now();\n\n            for (let i = obstacles.length - 1; i >= 0; i--) {\n                const obs = obstacles[i];\n\n                // 更新预警进度\n                if (!obs.active) {\n                    const elapsed = now - obs.spawnTime;\n                    obs.warningProgress = Math.min(1, elapsed / obs.warningTime);\n\n                    // 如果预警时间结束，激活障碍物\n                    if (elapsed >= obs.warningTime) {\n                        obs.active = true;\n                        obs.activateTime = now;\n                    }\n                }\n\n                // 检查是否应该移除障碍物\n                if (obs.active && now - obs.activateTime >= obs.duration) {\n                    obstacles.splice(i, 1);\n                }\n            }\n        }\n\n        // 更新事件状态\n        function updateEvents() {\n            const now = Date.now();\n\n            for (let i = events.length - 1; i >= 0; i--) {\n                const event = events[i];\n                \n                // 更新脉冲动画\n                event.pulsePhase += 0.1;\n                \n                // 检查是否应该移除事件\n                if (now - event.spawnTime >= event.duration) {\n                    events.splice(i, 1);\n                }\n            }\n        }\n\n        // 更新全局效果\n        function updateGlobalEffects() {\n            const now = Date.now();\n            \n            // 速度变化效果\n            if (globalEffects.speedVariation.active) {\n                if (now > globalEffects.speedVariation.endTime) {\n                    globalEffects.speedVariation.active = false;\n                    ball.speedMultiplier = 1.0;\n                } else {\n                    // 在70%-130%之间变动\n                    ball.speedMultiplier = 0.7 + 0.6 * (0.5 + 0.5 * Math.sin(now * 0.01));\n                }\n            }\n            \n            // 障碍物加速效果\n            if (globalEffects.obstacleSpeedUp.active) {\n                if (now > globalEffects.obstacleSpeedUp.endTime) {\n                    globalEffects.obstacleSpeedUp.active = false;\n                }\n            }\n            \n            // 雷云效果\n            if (globalEffects.thunderCloud.active) {\n                if (now > globalEffects.thunderCloud.endTime) {\n                    globalEffects.thunderCloud.active = false;\n                } else {\n                    // 更新闪电时间\n                    if (now > globalEffects.thunderCloud.flashTime) {\n                        globalEffects.thunderCloud.flashTime = now + 1000 + Math.random() * 2000;\n                    }\n                }\n            }\n            \n            // 新增效果更新\n            // 不死图腾效果\n            if (globalEffects.immortalTotem.active) {\n                if (now > globalEffects.immortalTotem.endTime) {\n                    globalEffects.immortalTotem.active = false;\n                    globalEffects.immortalTotem.triggeredBy = null;\n                    \n                    // 结束RGB变色效果\n                    const triggeredBy = globalEffects.immortalTotem.triggeredBy;\n                    if (triggeredBy === 'player') {\n                        player.glowEffect = false;\n                        player.glowEndTime = 0;\n                    } else if (triggeredBy === 'computer') {\n                        computer.glowEffect = false;\n                        computer.glowEndTime = 0;\n                    }\n                }\n            }\n            \n            // 事件狂潮效果\n            if (globalEffects.eventFrenzy.active) {\n                if (now > globalEffects.eventFrenzy.endTime) {\n                    globalEffects.eventFrenzy.active = false;\n                }\n            }\n            \n            // 天堂制造效果\n            if (globalEffects.heavenMaker.active) {\n                if (now > globalEffects.heavenMaker.endTime) {\n                    // 恢复球的大小和速度\n                    for (let i = 0; i < globalEffects.heavenMaker.stackCount; i++) {\n                        ball.radius = Math.min(ball.radius * 2, 50); // 恢复大小\n                        ball.speedMultiplier /= 1.25; // 恢复速度\n                    }\n                    globalEffects.heavenMaker.active = false;\n                    globalEffects.heavenMaker.stackCount = 0;\n                }\n            }\n            \n            // 沉重效果\n            if (globalEffects.heavyBall.active) {\n                if (now > globalEffects.heavyBall.endTime) {\n                    // 恢复球的大小和速度\n                    for (let i = 0; i < globalEffects.heavyBall.stackCount; i++) {\n                        ball.radius = Math.max(ball.radius * 0.5, 3); // 恢复大小\n                        ball.speedMultiplier /= 0.8; // 恢复速度\n                    }\n                    globalEffects.heavyBall.active = false;\n                    globalEffects.heavyBall.stackCount = 0;\n                }\n            }\n            \n            // 更新挡板效果\n            if (now > player.glowEndTime) {\n                player.glowEffect = false;\n                if (player.height !== player.originalHeight) {\n                    player.height = player.originalHeight;\n                }\n            }\n            \n            if (now > computer.glowEndTime) {\n                computer.glowEffect = false;\n                if (computer.height !== computer.originalHeight) {\n                    computer.height = computer.originalHeight;\n                }\n            }\n\n            // 添加rgb效果更新\n            if (now > player.rgbEndTime) {\n                player.rgbEffect = false;\n            }\n\n            if (now > computer.rgbEndTime) {\n                computer.rgbEffect = false;\n            }\n        }\n\n        // 绘制圆形（用于球和粒子）\n        function drawCircle(x, y, radius, color, alpha = 1.0) {\n            ctx.save();\n            ctx.globalAlpha = alpha;\n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n\n            // 添加发光效果\n            const gradient = ctx.createRadialGradient(\n                x, y, 0,\n                x, y, radius\n            );\n            gradient.addColorStop(0, color);\n            gradient.addColorStop(1, 'rgba(101, 80, 255, 0)');\n\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.closePath();\n            ctx.restore();\n        }\n\n        // 绘制挡板\n        function drawPaddle(x, y, width, height, color, glowEffect = false, rgbEffect = false) {\n            if (rgbEffect) {\n                // 使用RGB效果绘制挡板\n                drawPaddleRGB(x, y, width, height);\n                return;\n            }\n\n            ctx.save();\n            \n            // 如果有发光效果，先绘制发光\n            if (glowEffect) {\n                ctx.shadowColor = '#ffff00';\n                ctx.shadowBlur = 20;\n                ctx.shadowOffsetX = 0;\n                ctx.shadowOffsetY = 0;\n            }\n            \n            ctx.beginPath();\n            ctx.rect(x, y, width, height);\n\n            // 创建渐变效果\n            const gradient = ctx.createLinearGradient(x, y, x + width, y);\n            gradient.addColorStop(0, color);\n            gradient.addColorStop(1, glowEffect ? '#ffff88' : '#a0a8ff');\n\n            ctx.fillStyle = gradient;\n            ctx.fill();\n            ctx.closePath();\n\n            // 添加边框发光\n            ctx.beginPath();\n            ctx.rect(x - 2, y - 2, width + 4, height + 4);\n            ctx.strokeStyle = glowEffect ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 255, 255, 0.3)';\n            ctx.lineWidth = glowEffect ? 2 : 1;\n            ctx.stroke();\n            ctx.closePath();\n            \n            ctx.restore();\n        }\n\n        // 绘制RGB挡板效果\n        function drawPaddleRGB(x, y, width, height) {\n            ctx.save();\n\n            // 创建随时间变化的RGB效果\n            const hue = (Date.now() / 5) % 360;\n            const color1 = `hsl(${hue}, 100%, 60%)`;\n            const color2 = `hsl(${(hue + 120) % 360}, 100%, 60%)`;\n            const color3 = `hsl(${(hue + 240) % 360}, 100%, 60%)`;\n\n            // 创建三色渐变\n            const gradient = ctx.createLinearGradient(x, y, x + width, y + height);\n            gradient.addColorStop(0, color1);\n            gradient.addColorStop(0.5, color2);\n            gradient.addColorStop(1, color3);\n\n            // 绘制挡板主体\n            ctx.fillStyle = gradient;\n            ctx.fillRect(x, y, width, height);\n\n            // 添加发光边框\n            ctx.strokeStyle = '#ffffff';\n            ctx.lineWidth = 2;\n            ctx.shadowColor = '#ffffff';\n            ctx.shadowBlur = 15;\n            ctx.strokeRect(x - 2, y - 2, width + 4, height + 4);\n\n            ctx.restore();\n        }\n\n        // 绘制球轨迹\n        function drawBallTrail() {\n            for (let i = 0; i < ball.trail.length; i++) {\n                const alpha = (i / ball.trail.length) * ball.alpha;\n                const radius = ball.radius * alpha;\n\n                ctx.save();\n                ctx.globalAlpha = alpha * 0.6;\n                ctx.beginPath();\n                ctx.arc(ball.trail[i].x, ball.trail[i].y, radius, 0, Math.PI * 2);\n                ctx.fillStyle = ball.color;\n                ctx.fill();\n                ctx.closePath();\n                ctx.restore();\n            }\n        }\n\n        // 绘制网格背景\n        function drawGrid() {\n            const gridSize = 30;\n            ctx.strokeStyle = 'rgba(101, 80, 255, 0.1)';\n            ctx.lineWidth = 1;\n\n            // 垂直线\n            for (let x = 0; x < canvas.width; x += gridSize) {\n                ctx.beginPath();\n                ctx.moveTo(x, 0);\n                ctx.lineTo(x, canvas.height);\n                ctx.stroke();\n            }\n\n            // 水平线\n            for (let y = 0; y < canvas.height; y += gridSize) {\n                ctx.beginPath();\n                ctx.moveTo(0, y);\n                ctx.lineTo(canvas.width, y);\n                ctx.stroke();\n            }\n        }\n\n        // 绘制粒子\n        function drawParticles() {\n            for (let i = 0; i < particles.length; i++) {\n                const p = particles[i];\n\n                // 更新粒子位置\n                p.x += Math.cos(p.angle) * p.speed;\n                p.y += Math.sin(p.angle) * p.speed;\n                p.life--;\n\n                // 绘制粒子\n                ctx.save();\n                ctx.globalAlpha = p.life / 30;\n                ctx.beginPath();\n                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);\n                ctx.fillStyle = p.color;\n                ctx.fill();\n                ctx.closePath();\n                ctx.restore();\n\n                // 移除死亡粒子\n                if (p.life  centerY + cloudHeight || stream.life  {\n                    ctx.fillText(char, stream.x, stream.y + i * 12);\n                });\n\n                ctx.restore();\n            });\n        }\n\n        function drawLightningBranches(centerX, centerY, cloudWidth, cloudHeight) {\n            ctx.globalAlpha = 0.6;\n\n            // 生成主闪电路径\n            const path = generateLightningPath(\n                centerX + (Math.random() - 0.5) * cloudWidth * 0.5,\n                centerY - cloudHeight * 0.4,\n                centerX + (Math.random() - 0.5) * cloudWidth * 0.5,\n                centerY + cloudHeight * 0.4\n            );\n\n            // 绘制主闪电\n            drawLightning(path, 3);\n\n            // 生成分支闪电（1-3个）\n            const branchCount = 1 + Math.floor(Math.random() * 3);\n            for (let i = 0; i < branchCount; i++) {\n                const branchPoint = path[Math.floor(path.length * (i + 1) / (branchCount + 1))];\n                const branchPath = generateLightningPath(\n                    branchPoint.x,\n                    branchPoint.y,\n                    branchPoint.x + (Math.random() - 0.5) * cloudWidth * 0.3,\n                    branchPoint.y + cloudHeight * 0.2\n                );\n                drawLightning(branchPath, 2);\n            }\n        }\n\n        function generateLightningPath(startX, startY, endX, endY) {\n            const segments = 8;\n            const path = [{x: startX, y: startY}];\n            const variance = canvas.width * 0.05;\n\n            for (let i = 1; i  0.5 ? '1' : '0').join('');\n        }\n\n        // 重置球位置\n        function resetBall() {\n            // 保存原始速度方向\n            const originalVelocityX = ball.velocityX;\n            const originalVelocityY = ball.velocityY;\n\n            // 重置球位置和速度\n            ball.x = canvas.width / 2;\n            ball.y = canvas.height / 2;\n            ball.speed = 4;\n            ball.velocityX = Math.random() > 0.5 ? 5 : -5;\n            ball.velocityY = Math.random() * 4 - 2;\n            ball.trail = [];\n            isResetting = false;\n\n            // 重置死球检测\n            ballStuckDetection.lastY = ball.y;\n            ballStuckDetection.stuckTime = 0;\n            ballStuckDetection.lastCheckTime = Date.now();\n\n            // 防止球在障碍物上重生\n            let safePositionFound = false;\n            let attempts = 0;\n            const maxAttempts = 30;\n            const safeRadius = ball.radius * 2; // 安全距离半径\n\n            while (!safePositionFound && attempts < maxAttempts) {\n                // 方法1：尝试在中心附近随机位置生成\n                if (attempts < 20) {\n                    ball.x = canvas.width / 2 + (Math.random() - 0.5) * (canvas.width / 4);\n                    ball.y = canvas.height / 2 + (Math.random() - 0.5) * (canvas.height / 4);\n                }\n                // 方法2：向量叠加调整（前20次失败后启用）\n                else {\n                    let totalDx = 0;\n                    let totalDy = 0;\n                    let collisionCount = 0;\n\n                    for (const obs of obstacles) {\n                        if (obs.active && obstacleCollision(ball, obs)) {\n                            const dx = ball.x - obs.x;\n                            const dy = ball.y - obs.y;\n                            const distance = Math.sqrt(dx * dx + dy * dy);\n                            const minDistance = ball.radius + obs.size + safeRadius;\n\n                            if (distance < minDistance) {\n                                const angle = Math.atan2(dy, dx);\n                                const moveDistance = minDistance - distance;\n                                totalDx += moveDistance * Math.cos(angle);\n                                totalDy += moveDistance * Math.sin(angle);\n                                collisionCount++;\n                            }\n                        }\n                    }\n\n                    if (collisionCount > 0) {\n                        // 标准化总位移向量\n                        const totalMove = Math.sqrt(totalDx * totalDx + totalDy * totalDy);\n                        ball.x += (totalDx / collisionCount) * 1.2;\n                        ball.y += (totalDy / collisionCount) * 1.2;\n                    }\n                }\n\n                // 边界检查\n                ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));\n                ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));\n\n                // 最终碰撞检查\n                safePositionFound = true;\n                for (const obs of obstacles) {\n                    if (obs.active && obstacleCollision(ball, obs)) {\n                        safePositionFound = false;\n                        break;\n                    }\n                }\n\n                attempts++;\n            }\n        }\n\n        // 碰撞检测 - 挡板\n        function collision(b, p) {\n            return (\n                b.x + b.radius > p.x &&\n                b.x - b.radius < p.x + p.width &&\n                b.y + b.radius > p.y &&\n                b.y - b.radius < p.y + p.height\n            );\n        }\n\n        // 碰撞检测 - 障碍物\n        function obstacleCollision(ball, obstacle) {\n            if (!obstacle.active) return false;\n\n            if (obstacle.type === 'circle') {\n                // 圆形障碍物碰撞检测\n                const dx = ball.x - obstacle.x;\n                const dy = ball.y - obstacle.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n\n                return distance < ball.radius + obstacle.size;\n            } else {\n                // 矩形障碍物碰撞检测\n                const halfSize = obstacle.size / 2;\n                const closestX = Math.max(obstacle.x - halfSize, Math.min(ball.x, obstacle.x + halfSize));\n                const closestY = Math.max(obstacle.y - halfSize, Math.min(ball.y, obstacle.y + halfSize));\n\n                const dx = ball.x - closestX;\n                const dy = ball.y - closestY;\n\n                return (dx * dx + dy * dy) < (ball.radius * ball.radius);\n            }\n        }\n\n        // 碰撞检测 - 事件\n        function eventCollision(ball, event) {\n            const dx = ball.x - event.x;\n            const dy = ball.y - event.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            return distance < ball.radius + event.radius;\n        }\n\n        // 处理球与障碍物的碰撞\n        function handleObstacleCollision() {\n            for (const obs of obstacles) {\n                if (obstacleCollision(ball, obs)) {\n                    // 创建碰撞粒子\n                    createParticles(ball.x, ball.y, '#ff6666', 30);\n\n                    if (obs.type === 'circle') {\n                        // 圆形障碍物碰撞反弹\n                        const dx = ball.x - obs.x;\n                        const dy = ball.y - obs.y;\n                        const distance = Math.sqrt(dx * dx + dy * dy);\n\n                        // 法线向量\n                        const nx = dx / distance;\n                        const ny = dy / distance;\n\n                        // 计算点积\n                        const dot = ball.velocityX * nx + ball.velocityY * ny;\n\n                        // 反射向量\n                        ball.velocityX = ball.velocityX - 2 * dot * nx;\n                        ball.velocityY = ball.velocityY - 2 * dot * ny;\n                    } else {\n                        // 矩形障碍物碰撞反弹\n                        const halfSize = obs.size / 2;\n\n                        // 计算球相对于障碍物中心的向量\n                        const dx = ball.x - obs.x;\n                        const dy = ball.y - obs.y;\n\n                        // 判断碰撞发生在矩形的哪一侧\n                        if (Math.abs(dx) > Math.abs(dy)) {\n                            // 水平碰撞\n                            ball.velocityX = -ball.velocityX;\n\n                            // 调整位置防止卡住\n                            if (dx > 0) {\n                                ball.x = obs.x + halfSize + ball.radius;\n                            } else {\n                                ball.x = obs.x - halfSize - ball.radius;\n                            }\n                        } else {\n                            // 垂直碰撞\n                            ball.velocityY = -ball.velocityY;\n\n                            // 调整位置防止卡住\n                            if (dy > 0) {\n                                ball.y = obs.y + halfSize + ball.radius;\n                            } else {\n                                ball.y = obs.y - halfSize - ball.radius;\n                            }\n                        }\n                    }\n\n                    // 增加球速\n                    ball.speed += 0.025;\n\n                    // 记录碰撞时间\n                    ball.lastCollision = Date.now();\n\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // 处理球与事件的碰撞\n        function handleEventCollision() {\n            for (let i = events.length - 1; i >= 0; i--) {\n                const event = events[i];\n                if (eventCollision(ball, event)) {\n                    // 触发事件效果\n                    if (lastTouchedBy) {\n                        triggerEvent(event, lastTouchedBy);\n                    }\n                    \n                    // 移除事件\n                    events.splice(i, 1);\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // 处理雷云对球的影响\n        function handleThunderCloudEffect() {\n            if (!globalEffects.thunderCloud.active) return;\n            \n            const centerX = canvas.width / 2;\n            const centerY = canvas.height / 2;\n            const cloudWidth = canvas.width * 0.3;\n            const cloudHeight = canvas.height * 0.3;\n            \n            // 检查球是否在雷云区域内\n            if (ball.x > centerX - cloudWidth / 2 && \n                ball.x < centerX + cloudWidth / 2 &&\n                ball.y > centerY - cloudHeight / 2 && \n                ball.y < centerY + cloudHeight / 2) {\n                \n                // 随机改变球的角度 -10到10度\n                const angleChange = (Math.random() - 0.5) * 20 * Math.PI / 180;\n                const currentAngle = Math.atan2(ball.velocityY, ball.velocityX);\n                const newAngle = currentAngle + angleChange;\n                const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);\n                \n                ball.velocityX = speed * Math.cos(newAngle);\n                ball.velocityY = speed * Math.sin(newAngle);\n                \n                // 触发闪电效果\n                globalEffects.thunderCloud.flashTime = Date.now() + 200;\n            }\n        }\n\n        // 检查球是否卡在障碍物中，如果是则校正位置\n        function correctBallPosition() {\n            for (const obs of obstacles) {\n                if (!obs.active) continue;\n\n                // 计算球与障碍物的距离和方向\n                const dx = ball.x - obs.x;\n                const dy = ball.y - obs.y;\n\n                if (obs.type === 'circle') {\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    const minDistance = ball.radius + obs.size;\n\n                    if (distance < minDistance) {\n                        // 计算需要移动的方向\n                        const angle = Math.atan2(dy, dx);\n                        const moveDistance = minDistance - distance;\n\n                        // 将球移动到障碍物边缘\n                        ball.x += Math.cos(angle) * moveDistance;\n                        ball.y += Math.sin(angle) * moveDistance;\n                    }\n                } else {\n                    // 矩形障碍物处理\n                    const halfSize = obs.size / 2;\n                    const overlapX = Math.abs(dx) - (ball.radius + halfSize);\n                    const overlapY = Math.abs(dy) - (ball.radius + halfSize);\n\n                    if (overlapX < 0 && overlapY < 0) {\n                        // 确定最小重叠方向\n                        if (Math.abs(overlapX) < Math.abs(overlapY)) {\n                            // X轴方向重叠较小，沿X轴移动\n                            ball.x += dx > 0 ? -overlapX : overlapX;\n                        } else {\n                            // Y轴方向重叠较小，沿Y轴移动\n                            ball.y += dy > 0 ? -overlapY : overlapY;\n                        }\n                    }\n                }\n            }\n        }\n\n        // 更新游戏状态\n        function update(dt) {\n            if (isGameOver || isPaused) return; // 添加暂停检查\n\n            // 更新游戏时间（每帧约16ms）\n            gameTime += dt;\n\n            // 死球检测\n            if (checkDeadBall()) {\n                showDeadBallNotification();\n                resetBall();\n                // 重置球但不计分\n                return;\n            }\n\n            // 检查是否需要生成新障碍物\n            let obstacleInterval = 15000; // 默认15秒\n            if (globalEffects.obstacleSpeedUp.active) {\n                obstacleInterval *= 0.2; // 减少到20%\n            }\n\n            if (gameTime >= nextObstacleTime) {\n                createObstacles();\n                nextObstacleTime = gameTime + obstacleInterval + Math.random() * 5000;\n            }\n\n            // 检查是否需要生成新事件\n            if (gameTime >= nextEventTime) {\n                createEvent();\n                // 设置下一次事件出现时间：5-30秒后\n                let eventInterval = 5000 + Math.random() * 25000;\n\n\n                // 事件狂潮效果：事件刷新率增加为400%\n                if (globalEffects.eventFrenzy.active) {\n                    eventInterval *= 0.25; // 减少到25%，即400%的刷新率\n                }\n\n                nextEventTime = gameTime + eventInterval;\n            }\n\n            // 更新各种状态\n            updateObstacles();\n            updateEvents();\n            updateGlobalEffects();\n\n            // 检查并校正球的位置，防止卡在障碍物中\n            correctBallPosition();\n\n            // 更新球轨迹\n            ball.trail.push({x: ball.x, y: ball.y});\n            if (ball.trail.length > 10) {\n                ball.trail.shift();\n            }\n\n            // 移动球\n            const effectiveSpeed = ball.speed * ball.speedMultiplier;\n            const velocityMagnitude = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);\n            ball.x += (ball.velocityX / velocityMagnitude) * effectiveSpeed * (dt / FRAME_INTERVAL);\n            ball.y += (ball.velocityY / velocityMagnitude) * effectiveSpeed * (dt / FRAME_INTERVAL);\n\n            // 简单的电脑AI - 跟随球移动\n            const effectiveComputerSpeed = computer.speed * computer.speedMultiplier;\n            if (computer.y + (computer.height / 2) < ball.y) {\n                computer.y += effectiveComputerSpeed;\n            } else {\n                computer.y -= effectiveComputerSpeed;\n            }\n\n            // 确保电脑挡板不会超出边界\n            if (computer.y < 0) {\n                computer.y = 0;\n            } else if (computer.y + computer.height > canvas.height) {\n                computer.y = canvas.height - computer.height;\n            }\n\n            // 确保玩家挡板不会超出边界\n            if (player.y < 0) {\n                player.y = 0;\n            } else if (player.y + player.height > canvas.height) {\n                player.y = canvas.height - player.height;\n            }\n\n            // 上下边界反弹\n            if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {\n                ball.velocityY = -ball.velocityY;\n\n                // 边界碰撞粒子效果\n                createParticles(\n                    ball.x,\n                    ball.y < ball.radius ? 0 : canvas.height,\n                    '#ffffff'\n                );\n            }\n\n            // 处理雷云效果\n            handleThunderCloudEffect();\n\n            // 处理球与事件的碰撞\n            const hitEvent = handleEventCollision();\n\n            // 处理球与障碍物的碰撞\n            const hitObstacle = handleObstacleCollision();\n\n            // 如果没有碰到障碍物或事件，检查挡板碰撞\n            if (!hitObstacle && !hitEvent) {\n                // 确定球与哪个挡板碰撞\n                const paddle = ball.x < canvas.width / 2 ? player : computer;\n                const paddleOwner = ball.x < canvas.width / 2 ? 'player' : 'computer';\n                const currentTime = Date.now();\n\n                // 添加防卡顿机制：同一挡板在50ms内只允许碰撞一次\n                if (collision(ball, paddle) && currentTime - ball.lastCollision > 50) {\n                    // 记录触球者\n                    lastTouchedBy = paddleOwner;\n\n                    // 球击中挡板的位置（从-0.5到0.5）\n                    const hitPoint = (ball.y - (paddle.y + paddle.height / 2)) / (paddle.height / 2);\n\n                    // 计算反弹角度（基于击中位置）\n                    let angle = hitPoint * (Math.PI / 4);\n\n                    // 电脑回球增强功能\n                    if (aiEnhancementEnabled && paddleOwner === 'computer') {\n                        // 生成-75到75度的随机角度\n                        const randomAngle = (Math.random() - 0.5) * (120 * Math.PI / 180); // -60到60度转换为弧度\n                        angle = randomAngle;\n                    }\n\n                    // 确定方向\n                    const direction = ball.x < canvas.width / 2 ? 1 : -1;\n\n                    // 更新球的速度\n                    ball.velocityX = direction * ball.speed * Math.cos(angle);\n                    ball.velocityY = ball.speed * Math.sin(angle);\n\n                    // 增加球速\n                    ball.speed += 0.025;\n\n                    // 雷电板子效果\n                    if (paddle.glowEffect) {\n                        ball.speed *= 1.8; // 增加80%速度\n                        setTimeout(() => {\n                            ball.speed /= 1.8; // 0.8秒后恢复\n                        }, 800);\n                    }\n\n                    // 创建碰撞粒子\n                    createParticles(ball.x, ball.y, paddle.color);\n\n                    // 记录碰撞时间\n                    ball.lastCollision = currentTime;\n\n                    // 防止球卡在挡板内\n                    if (direction === 1) {\n                        ball.x = paddle.x + paddle.width + ball.radius + 1;\n                    } else {\n                        ball.x = paddle.x - ball.radius - 1;\n                    }\n                }\n            }\n\n            // 计分\n            if (!isResetting && (ball.x - ball.radius < 0 || ball.x + ball.radius > canvas.width)) {\n                isResetting = true;\n                let shouldScore = true;\n                let scoringPlayer = null;\n\n                if (ball.x - ball.radius < 0) {\n                    scoringPlayer = 'computer';\n                } else {\n                    scoringPlayer = 'player';\n                }\n\n                // 检查不死图腾效果\n                if (globalEffects.immortalTotem.active) {\n                    const triggeredBy = globalEffects.immortalTotem.triggeredBy;\n\n                    // 如果触发方失球，不计分但结束不死图腾效果\n                    if ((scoringPlayer === 'computer' && triggeredBy === 'player') ||\n                        (scoringPlayer === 'player' && triggeredBy === 'computer')) {\n                        shouldScore = false;\n\n                        // 结束不死图腾效果\n                        globalEffects.immortalTotem.active = false;\n                        globalEffects.immortalTotem.endTime = 0;\n                        globalEffects.immortalTotem.triggeredBy = null;\n\n                        // 结束触发方的RGB变色效果\n                        if (triggeredBy === 'player') {\n                            player.rgbEffect = false; // 使用rgbEffect\n                            player.rgbEndTime = 0;\n                        } else {\n                            computer.rgbEffect = false; // 使用rgbEffect\n                            computer.rgbEndTime = 0;\n                        }\n\n                        // 显示不死图腾触发通知\n                        const notification = document.createElement('div');\n                        notification.className = 'event-notification positive';\n                        notification.innerHTML = `\n                            不死图腾触发\n                            是不死图腾碎裂的声音！\n                            本次失球不计分，效果已结束\n                        `;\n                        document.body.appendChild(notification);\n                        setTimeout(() => {\n                            notification.classList.add('show');\n                        }, 100);\n                        setTimeout(() => {\n                            notification.classList.remove('show');\n                            setTimeout(() => {\n                                if (notification.parentNode) {\n                                    notification.remove();\n                                }\n                            }, 500);\n                        }, 3000);\n                    }\n                }\n\n                // 正常计分\n                if (shouldScore) {\n                    if (scoringPlayer === 'computer') {\n                        computerScore++;\n                        computerScoreElement.textContent = computerScore;\n                        createScoreEffect(false); // 电脑得分特效\n                    } else {\n                        playerScore++;\n                        playerScoreElement.textContent = playerScore;\n                        createScoreEffect(true); // 玩家得分特效\n                    }\n                }\n\n                // 重置电脑速度倍数（进球后重置）\n                computer.speedMultiplier = 1.0;\n\n                // 创建得分粒子效果\n                createParticles(\n                    ball.x,\n                    ball.y,\n                    ball.x - ball.radius < 0 ? computer.color : player.color,\n                    30\n                );\n\n                // 延迟后重置球\n                setTimeout(() => {\n                    resetBall();\n                }, 1000);\n            }\n\n            // 检查胜利条件\n            if (!isGameOver && (playerScore >= 3 || computerScore >= 3)) {\n                isGameOver = true;\n                if (playerScore >= 3) {\n                    victoryMessage.textContent = `玩家获胜！`;\n                } else {\n                    // 获取当前选中的难度名称\n                    const activeOption = document.querySelector('.difficulty-option.active');\n                    const difficultyName = activeOption ? activeOption.textContent : '电脑';\n                    victoryMessage.textContent = `${difficultyName}获胜！`;\n                }\n                victoryOverlay.style.opacity = '1';\n                victoryOverlay.style.pointerEvents = 'auto';\n            }\n\n            // 更新调试信息\n            updateDebugInfo();\n        }\n\n        // 绘制游戏\n        function draw() {\n            // 半透明背景（创造拖尾效果）\n            ctx.fillStyle = 'rgba(8, 12, 33, 0.15)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            // 绘制网格背景\n            drawGrid();\n\n            // 绘制雷云效果\n            drawThunderCloud();\n\n            // 绘制障碍物\n            drawObstacles();\n\n            // 绘制事件\n            drawEvents();\n\n            // 绘制球轨迹\n            drawBallTrail();\n\n            // 绘制粒子\n            drawParticles();\n\n            // 绘制中间虚线\n            ctx.beginPath();\n            ctx.setLineDash([10, 15]);\n            ctx.moveTo(canvas.width / 2, 0);\n            ctx.lineTo(canvas.width / 2, canvas.height);\n            ctx.strokeStyle = 'rgba(101, 80, 255, 0.4)';\n            ctx.lineWidth = 2;\n            ctx.stroke();\n            ctx.setLineDash([]);\n\n            // 绘制挡板\n            drawPaddle(player.x, player.y, player.width, player.height, player.color, player.glowEffect, player.rgbEffect);\n            drawPaddle(computer.x, computer.y, computer.width, computer.height, computer.color, computer.glowEffect, computer.rgbEffect);\n\n\n            // 绘制球\n            drawCircle(ball.x, ball.y, ball.radius, ball.color, ball.alpha);\n\n            // 绘制球内部光点\n            ctx.save();\n            ctx.globalAlpha = ball.alpha;\n            ctx.beginPath();\n            ctx.arc(ball.x - 3, ball.y - 3, 4, 0, Math.PI * 2);\n            ctx.fillStyle = '#ffffff';\n            ctx.fill();\n            ctx.closePath();\n            ctx.restore();\n        }\n\n        // 更新调试信息\n        function updateDebugInfo() {\n            // 球状态\n            document.getElementById('debug-ball-speed').textContent = ball.speed.toFixed(2);\n            document.getElementById('debug-ball-position').textContent = `${Math.round(ball.x)},${Math.round(ball.y)}`;\n            document.getElementById('debug-ball-alpha').textContent = ball.alpha.toFixed(2);\n\n            // 电脑数据\n            document.getElementById('debug-computer-speed').textContent = computer.speed.toFixed(2);\n            document.getElementById('debug-computer-position').textContent = Math.round(computer.y);\n            document.getElementById('debug-computer-multiplier').textContent = computer.speedMultiplier.toFixed(2);\n\n            // 事件状态\n            let activeEvents = 0;\n            if (globalEffects.speedVariation.active) activeEvents++;\n            if (globalEffects.obstacleSpeedUp.active) activeEvents++;\n            if (globalEffects.thunderCloud.active) activeEvents++;\n            if (player.glowEffect) activeEvents++;\n            if (computer.speedMultiplier !== 1.0) activeEvents++;\n            \n            document.getElementById('debug-active-events').textContent = activeEvents;\n            document.getElementById('debug-obstacles').textContent = obstacles.length;\n\n            // 系统信息\n            const currentFps = Math.round(1000 / (deltaTime || 16.67));\n            document.getElementById('debug-fps').textContent = currentFps;\n            document.getElementById('debug-game-time').textContent = `${Math.round(gameTime / 1000)}s`;\n        }\n\n        // 游戏循环\n        function gameLoop(timestamp) {\n            // 计算时间差\n            if (lastTime === 0) lastTime = timestamp;\n            deltaTime = timestamp - lastTime;\n            lastTime = timestamp;\n            accumulatedTime += deltaTime;\n            // 更新FPS计数\n            frameCount++;\n            if (timestamp - lastFpsUpdate >= 1000) {\n                const fps = Math.round(frameCount * 1000 / (timestamp - lastFpsUpdate));\n                console.log(`FPS: ${fps}`);\n                frameCount = 0;\n                lastFpsUpdate = timestamp;\n            }\n            // 执行固定次数的更新（时间补偿）\n            while (accumulatedTime >= FRAME_INTERVAL) {\n                update(FRAME_INTERVAL);\n                accumulatedTime -= FRAME_INTERVAL;\n            }\n            draw();\n            requestAnimationFrame(gameLoop);\n        }\n\n        // 启动游戏\n        lastTime = 0;\n        accumulatedTime = 0;\n        requestAnimationFrame(gameLoop);\n    \n\n\n"},{"url":"/uma/styles.css","content":"/* styles.css */\n\n.alert-box {\n    position: fixed;\n    top: 10px;\n    left: 50%;\n    transform: translateX(-50%);\n    background-color: rgba(255, 0, 0, 0.8);\n    color: white;\n    padding: 10px 20px;\n    border-radius: 5px;\n    z-index: 9999;\n    opacity: 0; /* 初始设置为透明 */\n    transition: opacity 0.5s ease; /* 添加过渡效果 */\n}\n\n.alert-box.success {\n    background-color: rgba(0, 255, 0, 0.8); /* 成功时的背景颜色 */\n}\n\n.alert-box.show {\n    opacity: 1; /* 显示时设置为不透明 */\n}\n\nbody {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background-color: #f0f0f0;\n}\n\n.container {\n    display: flex;\n    justify-content: space-between;\n    width: 90%; /* 设置容器宽度 */\n    max-width: 960px; /* 设置最大宽度 */\n    margin-top: 20px; /* 添加顶部间距 */\n}\n\n.card-preview {\n    width: 60%; /* 设置预览框宽度 */\n    height: 512px;\n    position: relative;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.border-container {\n    position: relative;\n    display: inline-block;\n}\n\n.border-image {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n\n#cardCanvas {\n    position: absolute;\n    top: 12px; /* 调整以适应边框内 */\n    left: 17px; /* 调整以适应边框内 */\n}\n\n.canvas-overlay {\n    position: absolute;\n    display: table;\n}\n\n.border-overlay {\n    position: relative;\n    pointer-events: none; /* 允许鼠标事件穿透 */\n    user-select: none; /* 禁止文本选中 */\n    -webkit-user-drag: none; /* 禁止拖拽 */\n    display: inline-block;\n}\n\n.tag, .type {\n    position: absolute;\n}\n\n.tag {\n    top: 2px;\n    left: 35px;\n}\n\n.type {\n    top: 1.5px;\n    left: 298px;\n}\n\n.controls {\n    width: 35%; /* 设置控制框宽度 */\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.control-label {\n    font-weight: bold;\n}\n\n.input-field {\n    width: 100%;\n    padding: 5px;\n    border: 1px solid #ccc;\n    border-radius: 5px;\n}\n\n.button {\n    background-color: #007bff;\n    color: white;\n    border: none;\n    padding: 10px;\n    border-radius: 5px;\n    cursor: pointer;\n}\n\n/* 添加按钮悬停/点击效果 */\n.button:hover,\n.button:active {\n    background-color: #0056b3; /* 悬停/点击状态时的背景颜色 */\n    transition: background-color 0.3s ease; /* 添加渐变效果 */\n}\n\n.github-link img {\n    transition: filter 0.3s ease; /* 添加渐变效果 */\n}\n\n.github-link:hover img,\n.github-link:active img {\n    filter: invert(100%); /* 悬停/点击状态时反转颜色 */\n}\n\n.scale-label {\n    display: inline-block;\n}\n\n.scale-controls {\n    display: flex; /* 修改为flex布局 */\n    align-items: center; /* 垂直居中对齐 */\n}\n\n.scale-controls .button {\n    margin: 0 5px; /* 添加按钮之间的间距 */\n}\n\n/* 新添加的 CSS 样式 */\n.header {\n    text-align: center;\n    margin-top: 20px;\n    font-size: 24px;\n    font-weight: bold;\n}\n\n.sub-header {\n    text-align: center;\n    font-size: 14px;\n    color: #888;\n}\n\n.github-link {\n    position: absolute;\n    top: 20px;\n    right: 20px;\n}\n\n.github-link img {\n    width: 40px;\n    height: 40px;\n}\n\n/* 在你的 styles.css 文件中添加以下样式 */\n\n.modal {\n    display: none; /* 默认隐藏 */\n    position: fixed; /* 固定定位 */\n    z-index: 1; /* 设置 z-index，确保弹窗位于其他元素之上 */\n    left: 0;\n    top: 0;\n    width: 100%; /* 设置宽度为屏幕宽度 */\n    height: 100%; /* 设置高度为屏幕高度 */\n    overflow: auto; /* 添加滚动条，以防内容过长 */\n    background-color: rgba(0, 0, 0, 0.4); /* 半透明黑色背景 */\n}\n\n.modal-content {\n    background-color: #fefefe; /* 弹窗内容背景色 */\n    margin: 15% auto; /* 调整上下居中位置 */\n    padding: 20px;\n    border: 1px solid #888;\n    transform: translate(0%, 0%);\n    width: 70%; /* 设置弹窗内容宽度 */\n    max-width: 600px; /* 设置最大宽度 */\n    border-radius: 10px; /* 圆角边框 */\n}\n\n/* 关闭按钮样式 */\n.close {\n    color: #aaa;\n    float: right;\n    font-size: 28px;\n    font-weight: bold;\n}\n\n.close:hover,\n.close:focus {\n    color: black;\n    text-decoration: none;\n    cursor: pointer;\n}\n\n\n/* 问号按钮样式 */\n.help-button {\n    position: fixed;\n    bottom: 20px;\n    left: 20px;\n}\n\n.help-button button {\n    background-color: #007bff;\n    color: white;\n    border: none;\n    border-radius: 50%;\n    width: 30px;\n    height: 30px;\n    font-size: 16px;\n    cursor: pointer;\n}\n\n/* 添加按钮悬停/点击效果 */\n.help-button button:hover,\n.help-button button:active {\n    background-color: #0056b3; /* 悬停/点击状态时的背景颜色 */\n    transition: background-color 0.3s ease; /* 添加渐变效果 */\n}\n\n/* 帮助内容弹窗样式 */\n.modal-content {\n    max-height: 80%;\n    overflow-y: auto;\n}\n\n.modal-content h2 {\n    margin-top: 0;\n}\n\n.modal-content h3 {\n    margin-top: 20px;\n}\n\n.modal-content ul,\n.modal-content ol {\n    margin-bottom: 20px;\n}\n\n/* 在样式表中添加媒体查询以适配手机端 */\n@media only screen and (max-width: 600px) {\n    /* 调整全局样式 */\n    .container {\n        flex-direction: column;\n    }\n\n    .card-preview {\n        width: 100%; /* 将预览框宽度调整为100% */\n        height: auto; /* 自适应高度 */\n    }\n\n    .controls {\n        width: 100%; /* 将控制框宽度调整为100% */\n    }\n\n    /* 调整按钮样式 */\n    .button {\n        width: 100%; /* 将按钮宽度调整为100% */\n    }\n\n    /* 调整预览框和控制框之间的间距 */\n    .container {\n        margin-top: 10px; /* 减小顶部间距 */\n        margin-bottom: 10px; /* 增加底部间距 */\n    }\n\n    /* 调整帮助按钮样式 */\n    .help-button {\n        bottom: 70px; /* 调整按钮位置 */\n        left: calc(50% - 50px); /* 居中显示按钮 */\n    }\n\n    .help-button button {\n        width: 60px; /* 调整按钮大小 */\n        height: 60px;\n        font-size: 24px; /* 调整按钮文字大小 */\n    }\n\n    /* 调整帮助内容弹窗样式 */\n    .modal-content {\n        margin: 10% auto; /* 调整上下居中位置 */\n        width: 90%; /* 调整弹窗内容宽度 */\n    }\n\n    .modal-content h2,\n    .modal-content h3,\n    .modal-content p {\n        font-size: 14px; /* 调整字体大小 */\n    }\n    /* 调整标题和旁边图片的大小 */\n    div[style=\"text-align: center;color: #62b912;font-size: 38px;font-weight: 600;\"] {\n        text-align: center;\n        margin-top: 10px; /* 缩小标题顶部间距 */\n        font-size: 24px; /* 缩小标题字体大小 */\n        font-weight: 600;\n    }\n\n    div[style=\"text-align: center;color: #62b912;font-size: 38px;font-weight: 600;\"] img {\n        width: 30px; /* 缩小旁边图片大小 */\n        height: 30px;\n    }\n\n    /* 调整帮助按钮样式 */\n    .help-button {\n        position: fixed; /* 保持在屏幕上 */\n        bottom: 20px; /* 将按钮放在底部 */\n        left: 20px; /* 将按钮放在左侧 */\n    }\n\n    .help-button button {\n        width: 40px; /* 缩小按钮大小 */\n        height: 40px;\n        font-size: 16px; /* 缩小按钮文字大小 */\n    }\n}\n\n/* 新增的 CSS 样式 */\n\n/* 使用弹性布局使标题和图片水平居中 */\n.title-container {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden; /* 隐藏溢出内容 */\n    text-align: center;\n    color: #62b912;\n    font-size: 38px;\n    font-weight: 600;\n}\n\n/* 限制标题和图片的最大宽度 */\n.title-container h1,\n.title-container img {\n    max-width: 100%;\n}\n\n/* 在小屏幕下（例如移动端）缩小标题字体大小 */\n@media screen and (max-width: 600px) {\n    .title-container {\n        font-size: 20px; /* 将字体大小调整为20像素 */\n    }\n    .left-icon,\n    .right-icon {\n        transform: scale(0.6); /* 缩小图标到原大小的 45% */\n    }\n}\n"},{"url":"/uma/html2canvas.js","content":"/*!\n * html2canvas 1.4.1 \n * Copyright (c) 2022 Niklas von Hertzen \n * Released under MIT License\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.html2canvas = factory());\n}(this, (function () { 'use strict';\n\n    /*! *****************************************************************************\n    Copyright (c) Microsoft Corporation.\n\n    Permission to use, copy, modify, and/or distribute this software for any\n    purpose with or without fee is hereby granted.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n    PERFORMANCE OF THIS SOFTWARE.\n    ***************************************************************************** */\n    /* global Reflect, Promise */\n\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n\n    function __extends(d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }\n\n    var __assign = function() {\n        __assign = Object.assign || function __assign(t) {\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\n                s = arguments[i];\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n            return t;\n        };\n        return __assign.apply(this, arguments);\n    };\n\n    function __awaiter(thisArg, _arguments, P, generator) {\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n        return new (P || (P = Promise))(function (resolve, reject) {\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    }\n\n    function __generator(thisArg, body) {\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n        function verb(n) { return function (v) { return step([n, v]); }; }\n        function step(op) {\n            if (f) throw new TypeError(\"Generator is already executing.\");\n            while (_) try {\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n                if (y = 0, t) op = [op[0] & 2, t.value];\n                switch (op[0]) {\n                    case 0: case 1: t = op; break;\n                    case 4: _.label++; return { value: op[1], done: false };\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                    default:\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                        if (t[2]) _.ops.pop();\n                        _.trys.pop(); continue;\n                }\n                op = body.call(thisArg, _);\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n        }\n    }\n\n    function __spreadArray(to, from, pack) {\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n            if (ar || !(i in from)) {\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                ar[i] = from[i];\n            }\n        }\n        return to.concat(ar || from);\n    }\n\n    var Bounds = /** @class */ (function () {\n        function Bounds(left, top, width, height) {\n            this.left = left;\n            this.top = top;\n            this.width = width;\n            this.height = height;\n        }\n        Bounds.prototype.add = function (x, y, w, h) {\n            return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);\n        };\n        Bounds.fromClientRect = function (context, clientRect) {\n            return new Bounds(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);\n        };\n        Bounds.fromDOMRectList = function (context, domRectList) {\n            var domRect = Array.from(domRectList).find(function (rect) { return rect.width !== 0; });\n            return domRect\n                ? new Bounds(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height)\n                : Bounds.EMPTY;\n        };\n        Bounds.EMPTY = new Bounds(0, 0, 0, 0);\n        return Bounds;\n    }());\n    var parseBounds = function (context, node) {\n        return Bounds.fromClientRect(context, node.getBoundingClientRect());\n    };\n    var parseDocumentSize = function (document) {\n        var body = document.body;\n        var documentElement = document.documentElement;\n        if (!body || !documentElement) {\n            throw new Error(\"Unable to get document size\");\n        }\n        var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));\n        var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));\n        return new Bounds(0, 0, width, height);\n    };\n\n    /*\n     * css-line-break 2.1.0 \n     * Copyright (c) 2022 Niklas von Hertzen \n     * Released under MIT License\n     */\n    var toCodePoints$1 = function (str) {\n        var codePoints = [];\n        var i = 0;\n        var length = str.length;\n        while (i < length) {\n            var value = str.charCodeAt(i++);\n            if (value >= 0xd800 && value "}]